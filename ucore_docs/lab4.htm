<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=Generator content="Microsoft Word 14 (filtered)">
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Arial;
	panose-1:2 11 6 4 2 2 2 2 2 4;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"\@宋体";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:楷体;
	panose-1:2 1 6 9 6 1 1 1 1 1;}
@font-face
	{font-family:"\@楷体";
	panose-1:2 1 6 9 6 1 1 1 1 1;}
@font-face
	{font-family:"Bitstream Vera Sans";}
@font-face
	{font-family:永中宋体;
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"\@永中宋体";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
h1
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:14.2pt;
	font-size:16.0pt;
	font-family:Arial;}
h2
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:54.0pt;
	text-indent:-54.0pt;
	font-size:10.0pt;
	font-family:Arial;
	font-style:italic;}
h4
	{margin-top:14.0pt;
	margin-right:0cm;
	margin-bottom:14.5pt;
	margin-left:1.0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:-35.45pt;
	line-height:156%;
	font-size:10.5pt;
	font-family:Arial;}
p.MsoNormalIndent, li.MsoNormalIndent, div.MsoNormalIndent
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:10.0pt;
	font-size:10.5pt;
	font-family:"Times New Roman";}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	layout-grid-mode:char;
	border:none;
	padding:0cm;
	font-size:9.0pt;
	font-family:"Times New Roman";}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:"Times New Roman";}
p.MsoBodyText, li.MsoBodyText, div.MsoBodyText
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:9.0pt;
	font-family:"Times New Roman";}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin:0cm;
	margin-bottom:.0001pt;
	text-indent:21.0pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
span.WW8Num6z0
	{font-family:Wingdings;}
p.1, li.1, div.1
	{margin-top:5.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:宋体;}
p.10, li.10, div.10
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:10.0pt;
	font-size:10.5pt;
	font-family:"Times New Roman";}
p.2, li.2, div.2
	{margin:0cm;
	margin-bottom:.0001pt;
	text-indent:10.0pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
span.a
	{font-family:"Bitstream Vera Sans";}
span.a0
	{font-family:"Bitstream Vera Sans";}
.MsoChpDefault
	{font-size:10.0pt;}
 /* Page Definitions */
@page WordSection1
	{size:595.3pt 841.9pt;
	margin:36.0pt 36.0pt 36.0pt 36.0pt;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>

</head>

<body lang=EN-US link=blue vlink=purple style='text-justify-trim:punctuation'>

<div class=WordSection1>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<p class=MsoNormal align=center style='text-align:center'><b><span lang=AR-SA
style='font-size:16.0pt;font-family:楷体'>实验四：内核线程管理</span></b></p>

<p class=MsoNormal style='margin-left:5.7pt;text-autospace:none'><b><span
style='font-size:17.0pt'>1 </span></b><b><span lang=ZH-CN style='font-size:
17.0pt;font-family:楷体'>实验目的</span></b></p>

<p class=MsoListParagraph style='margin-left:41.15pt;text-indent:-18.0pt;
text-autospace:none'><span style='font-family:Wingdings;letter-spacing:.05pt'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体;letter-spacing:.05pt'>了解内核线程创建</span><span
style='letter-spacing:.05pt'>/</span><span lang=ZH-CN style='font-family:楷体;
letter-spacing:.05pt'>执行的管理过程</span></p>

<p class=MsoListParagraph style='margin-left:41.15pt;text-indent:-18.0pt;
text-autospace:none'><span style='font-family:Wingdings;letter-spacing:.05pt'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体;letter-spacing:.05pt'>了解内核线程的切换和基本调度过程</span></p>

<p class=MsoNormal style='margin-left:5.7pt;text-autospace:none'><b><span
style='font-size:17.0pt'>2    </span></b><b><span lang=ZH-CN style='font-size:
17.0pt;font-family:楷体'>实验内容</span></b></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>实验</span><span style='font-size:12.0pt'>2/3</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>完成了物理和虚拟内存管理，这给创建内核线程（内核线程是一种特殊的进程）打下了提供内存管理的基础。当一个程序加载到内存中运行时，首先通过</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的内存管理分配合适的空间，然后就需要考虑如何使用</span><span style='font-size:12.0pt'>CPU</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>来</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>并发</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>执行多个程序。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>本次实验将首先接触的是内核线程的管理。内核线程是一种特殊的进程，内核线程与用户进程的区别有两个：内核线程只运行在内核态而用户进程会在在用户态和内核态交替运行；所有内核线程直接使用共同的</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>内核内存空间，不需为每个内核线程维护单独的内存空间而用户进程需要维护各自的用户内存空间。相关原理介绍可看附录</span><span
style='font-size:12.0pt'>B</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>：【原理】进程</span><span style='font-size:12.0pt'>/</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>线程的属性与特征解析。</span></p>

<p class=MsoNormal style='margin-left:6.5pt;text-autospace:none'><b><span
style='font-size:14.0pt'>2.1 </span></b><b><span lang=ZH-CN style='font-size:
14.0pt;font-family:楷体'>练习</span></b></p>

<p class=MsoNormal style='margin-right:34.95pt;text-align:justify;text-justify:
inter-ideograph;text-autospace:none'><b><span lang=ZH-CN style='font-family:
楷体;color:red'>练习</span></b><b><span style='color:red'>0</span></b><b><span
lang=ZH-CN style='font-family:楷体;color:red'>：填写已有实验</span></b></p>

<p class=MsoNormalIndent style='text-indent:0cm'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>本实验依赖实验</span><span style='font-size:
12.0pt'>1/2/3</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>。请把你做的实验</span><span
style='font-size:12.0pt'>1/2/3</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的代码填入本实验中代码中有</span><span style='font-size:12.0pt'>“LAB1”,“LAB2”,
“LAB3”</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的注释相应部分。</span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-align:justify;text-justify:
inter-ideograph;text-autospace:none'><b><span lang=ZH-CN style='font-family:
楷体;color:red'>练习</span></b><b><span style='color:red'>1</span></b><b><span
lang=ZH-CN style='font-family:楷体;color:red'>：分配并初始化一个进程控制块（需要编码）</span></b></p>

<p class=MsoNormalIndent style='text-indent:25.5pt'><b><span style='font-size:
12.0pt;color:red'>alloc_proc</span></b><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数（位于</span><span style='font-size:12.0pt'>kern/process/proc.c</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>）负责分配并返回一个新的</span><span
style='font-size:12.0pt'>struct proc_struct</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>结构，用于存储新建立的内核线程的管理信息。</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>需要对这个结构进行最基本的初始化，<b><span style='color:red'>你需要完成</span></b>这个初始化过程。【提示】在</span><span
style='font-size:12.0pt'>alloc_proc</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数的实现中，需要初始化的</span><span style='font-size:12.0pt'>proc_struct</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>结构中的成员变量至少包括：</span><span
style='font-size:12.0pt'>state/pid/runs/kstack/need_resched/parent/mm/context/tf/cr3/flags/name</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>。</span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-align:justify;text-justify:
inter-ideograph;text-autospace:none'><b><span lang=ZH-CN style='font-family:
楷体;color:red'>练习</span></b><b><span style='color:red'>2</span></b><b><span
lang=ZH-CN style='font-family:楷体;color:red'>：为新创建的内核线程分配资源（需要编码）</span></b></p>

<p class=MsoNormalIndent style='text-indent:25.5pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>创建一个内核线程需要分配和设置好很多资源。</span><span
style='font-size:12.0pt'>kernel_thread</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数通过调用</span><b><span style='font-size:12.0pt;
color:red'>do_fork</span></b><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数完成具体内核线程的创建工作。</span><span style='font-size:12.0pt'>do_kernel</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数会调用</span><span
style='font-size:12.0pt'>alloc_proc</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数来分配并初始化一个进程控制块，但</span><span style='font-size:12.0pt'>alloc_proc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>一般通过</span><span style='font-size:12.0pt'>do_fork</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>实际创建新的内核线程。</span><span
style='font-size:12.0pt'>do_fork</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。<b><span
style='color:red'>你需要完成</span></b>在</span><span style='font-size:12.0pt'>kern/process/proc.c</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中的</span><span
style='font-size:12.0pt'>do_fork</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数中的处理过程。它的大致执行步骤包括：</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=AR-SA style='font-family:楷体'>调用</span><span>alloc_proc</span><span
lang=AR-SA style='font-family:楷体'>，首先获得一块用户信息块。</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=AR-SA style='font-family:楷体'>为进程分配一个内核栈。</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=AR-SA style='font-family:楷体'>复制原进程的内存管理信息到新进程（但内核线程不必做此事）</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=AR-SA style='font-family:楷体'>复制原进程上下文到新进程</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=AR-SA style='font-family:楷体'>将新进程添加到进程列表</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=AR-SA style='font-family:楷体'>唤醒新进程</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=AR-SA style='font-family:楷体'>返回新进程号</span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-align:justify;text-justify:
inter-ideograph;text-autospace:none'><b><span lang=ZH-CN style='font-family:
楷体;color:red'>练习</span></b><b><span style='color:red'>3</span></b><b><span
lang=ZH-CN style='font-family:楷体;color:red'>：阅读代码，理解</span></b><b><span
style='color:red'>proc_run</span></b><b><span lang=ZH-CN style='font-family:
楷体;color:red'>和它调用的函数如何完成进程切换的。（无编码工作）</span></b></p>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><span lang=AR-SA style='font-family:楷体'>完成代码编写后，编译并运行代码：</span><span>make
qemu</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=AR-SA style='font-family:楷体'>如果可以得到如<b><span style='color:red'>附录</span></b></span><b><span
style='color:red'>A</span></b><span lang=AR-SA style='font-family:楷体'>所示的显示内容（仅供参考，不是标准答案输出），则基本正确。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-align:justify;text-justify:
inter-ideograph;text-autospace:none'><b><span lang=ZH-CN style='font-family:
楷体;color:red'>扩展练习</span></b><b><span style='color:red'>Challenge</span></b><b><span
lang=ZH-CN style='font-family:楷体;color:red'>：实现支持任意大小的内存分配算法</span></b></p>

<p class=MsoNormalIndent style='text-indent:25.5pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>这不是本实验的内容，其实是上一次实验内存的扩展，但考虑到现在的</span><span
style='font-size:12.0pt'>slab</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>算法比较复杂，有必要实现一个比较简单的任意大小内存分配算法。可参考本实验中的</span><span
style='font-size:12.0pt'>slab</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>如何调用基于页的内存分配算法（注意，不是要你关注</span><span style='font-size:12.0pt'>slab</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的具体实现）来实现</span><span
style='font-size:12.0pt'>first-fit/best-fit/worst-fit/buddy</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>等支持任意大小的内存分配算法。。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>【注意】下面是相关的</span><span
style='font-size:12.0pt'>Linux</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>实现文档，供参考</span></p>

<p class=MsoNormal><span>SLOB</span></p>

<p class=MsoNormal><a href="http://en.wikipedia.org/wiki/SLOB"><span>http://en.wikipedia.org/wiki/SLOB</span></a><span> 
</span><a href="http://lwn.net/Articles/157944/"><span>http://lwn.net/Articles/157944/</span></a></p>

<p class=MsoNormal><span>SLAB</span></p>

<p class=MsoNormal><a
href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/"><span>https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/</span></a></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:6.5pt;text-autospace:none'><b><span
style='font-size:14.0pt'>2.2 </span></b><b><span lang=ZH-CN style='font-size:
14.0pt;font-family:楷体'>项目组成</span></b></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=493 valign=top style='width:492.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyText><span style='font-size:9.0pt'>├── boot</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>├── kern</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  debug</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  driver</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  fs</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  init</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:blue'>init.c</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> └──
  ...</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  libs</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:red'>rb_tree.c</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:red'>rb_tree.h</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> └──
  ...</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  mm</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──<span
  style='color:red'> kmalloc.c</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:red'>kmalloc.h</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:blue'>memlayout.h</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:blue'>pmm.c</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:blue'>pmm.h</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:blue'>swap.c</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:blue'>vmm.c</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> └──
  ...</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──<span
  style='color:#FF6600'> process</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:#FF6600'>entry.S</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:#FF6600'>proc.c</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:#FF6600'>proc.h</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> └──
  <span style='color:#FF6600'>switch.S</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:#FF6600'>schedule</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:#FF6600'>sched.c</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> └──
  <span style='color:#FF6600'>sched.h</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  sync</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> │</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> └──
  sync.h</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> └──
  trap</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'>    
  ├── <span style='color:blue'>trapentry.S</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'>    
  └── ...</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>├── libs</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:red'>hash.c</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:blue'>stdlib.h</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> ├──
  <span style='color:red'>unistd.h</span></span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>│</span><span
  style='font-size:9.0pt'>&nbsp;&nbsp;</span><span style='font-size:9.0pt'> └──
  ...</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>├── Makefile</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>└── tools</span></p>
  </td>
 </tr>
</table>

<p class=MsoBodyText><span>       </span><span lang=AR-SA style='font-family:
楷体'>相对与实验三，实验四主要增加的文件如上表红色部分所示，主要修改的文件如上表紫色部分所示。主要改动如下：</span></p>

<p class=1 style='margin-left:21.0pt;text-indent:-21.0pt'><span
style='font-family:"永中宋体","serif"'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:"Times New Roman"'>kern/process/  </span><span
lang=AR-SA style='font-family:楷体'>（新增进程管理相关文件）</span></p>

<p class=1 style='margin-left:35.25pt'><span style='font-family:"Times New Roman"'>proc.[ch]</span><span
lang=AR-SA style='font-family:楷体'>：新增：实现进程、线程相关功能</span><span lang=ZH-CN
style='font-family:楷体'>，包括：</span><span lang=AR-SA style='font-family:楷体'>创建进程</span><span
style='font-family:"Times New Roman"'>/</span><span lang=AR-SA
style='font-family:楷体'>线程，初始化进程</span><span style='font-family:"Times New Roman"'>/</span><span
lang=AR-SA style='font-family:楷体'>线程，处理进程</span><span style='font-family:"Times New Roman"'>/</span><span
lang=AR-SA style='font-family:楷体'>线程退出等功能</span></p>

<p class=1><span style='font-family:"Times New Roman"'>              entry.S</span><span
lang=AR-SA style='font-family:楷体'>：新增：</span><span lang=ZH-CN style='font-family:
楷体'>内核线程</span><span lang=AR-SA style='font-family:楷体'>入口函数</span><span
style='font-family:"Times New Roman"'>kernel_thread_entry</span><span
lang=ZH-CN style='font-family:楷体'>的实现</span></p>

<p class=1><span style='font-family:"Times New Roman"'>              switch.S</span><span
lang=AR-SA style='font-family:楷体'>：新增：上下文切换，利用堆栈保存、恢复</span><span lang=ZH-CN
style='font-family:楷体'>进程上下文</span><span lang=ZH-CN style='font-family:"Times New Roman"'>
</span></p>

<p class=1 style='margin-left:21.0pt;text-indent:-21.0pt'><span
style='font-family:"永中宋体","serif"'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:"Times New Roman"'>kern/init/</span></p>

<p class=1><span style='font-family:"Times New Roman"'>              init.c</span><span
lang=AR-SA style='font-family:楷体'>：修改：</span><span lang=ZH-CN style='font-family:
楷体'>完成</span><span lang=AR-SA style='font-family:楷体'>进程系统初始化，</span><span
lang=ZH-CN style='font-family:楷体'>并在</span><span lang=AR-SA style='font-family:
楷体'>内核初始化后切入</span><span style='font-family:"Times New Roman"'>idle</span><span
lang=AR-SA style='font-family:楷体'>进程</span></p>

<p class=1 style='margin-left:21.0pt;text-indent:-21.0pt'><span
style='font-family:"永中宋体","serif"'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:"Times New Roman"'>kern/mm/ </span><span
lang=ZH-CN style='font-family:楷体'>（基本上与本次实验没有太直接的联系，了解</span><span
style='font-family:"Times New Roman"'>kmalloc</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span style='font-family:"Times New Roman"'>kfree</span><span
lang=ZH-CN style='font-family:楷体'>如何使用即可）</span></p>

<p class=1 style='margin-left:35.25pt'><span style='font-family:"Times New Roman"'>kmalloc.[ch]</span><span
lang=AR-SA style='font-family:楷体'>：新增：定义和实现了新的</span><span style='font-family:
"Times New Roman"'>kmalloc/kfree</span><span lang=AR-SA style='font-family:
楷体'>函数。具体实现是基于</span><span style='font-family:"Times New Roman"'>slab</span><span
lang=AR-SA style='font-family:楷体'>分配的简化算法</span><span lang=AR-SA
style='font-family:"Times New Roman"'> </span><span lang=AR-SA
style='font-family:楷体'>（</span><span lang=ZH-CN style='font-family:楷体'>只要求</span><span
lang=AR-SA style='font-family:楷体'>会调用这两个函数即可）</span></p>

<p class=1 style='text-indent:42.0pt'><span style='font-family:"Times New Roman"'>memlayout.h</span><span
lang=AR-SA style='font-family:楷体'>：增加</span><span style='font-family:"Times New Roman"'>slab</span><span
lang=AR-SA style='font-family:楷体'>物理内存分配相关的定义与宏</span><span style='font-family:
"Times New Roman"'>  </span><span lang=AR-SA style='font-family:楷体'>（可不用理会）。</span></p>

<p class=1 style='margin-left:35.25pt'><span style='font-family:"Times New Roman"'>pmm.[ch]</span><span
lang=ZH-CN style='font-family:楷体'>：修改：</span><span lang=AR-SA style='font-family:
楷体'>在</span><span style='font-family:"Times New Roman"'>pmm.c</span><span
lang=AR-SA style='font-family:楷体'>中添加了调用</span><span style='font-family:"Times New Roman"'>kmalloc_init</span><span
lang=AR-SA style='font-family:楷体'>函数</span><span style='font-family:"Times New Roman"'>,</span><span
lang=AR-SA style='font-family:楷体'>取消了老的</span><span style='font-family:"Times New Roman"'>kmalloc/kfree</span><span
lang=AR-SA style='font-family:楷体'>的实现；在</span><span style='font-family:"Times New Roman"'>pmm.h</span><span
lang=AR-SA style='font-family:楷体'>中取消了老的</span><span style='font-family:"Times New Roman"'>kmalloc/kfree</span><span
lang=AR-SA style='font-family:楷体'>的定义</span></p>

<p class=1><span style='font-family:"Times New Roman"'>      swap.c</span><span
lang=AR-SA style='font-family:楷体'>：修改：取消了用于</span><span style='font-family:
"Times New Roman"'>check</span><span lang=AR-SA style='font-family:楷体'>的</span><span
style='font-family:"Times New Roman"'>Line 185</span><span lang=AR-SA
style='font-family:楷体'>的执行</span></p>

<p class=1><span style='font-family:"Times New Roman"'>              vmm.c</span><span
lang=AR-SA style='font-family:楷体'>：修改：调用新的</span><span style='font-family:"Times New Roman"'>kmalloc/kfree</span></p>

<p class=1 style='margin-left:21.0pt;text-indent:-21.0pt'><span
style='font-family:"永中宋体","serif"'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:"Times New Roman"'>kern/trap/</span></p>

<p class=1><span style='font-family:"Times New Roman"'>              trapentry.S</span><span
lang=ZH-CN style='font-family:楷体'>：</span><span lang=AR-SA style='font-family:
楷体'>增加了汇编写的函数</span><span style='font-family:"Times New Roman"'>forkrets</span><span
lang=ZH-CN style='font-family:楷体'>，用于</span><span style='font-family:"Times New Roman"'>do_fork</span><span
lang=ZH-CN style='font-family:楷体'>调用的返回处理。</span></p>

<p class=1 style='margin-left:21.0pt;text-indent:-21.0pt'><span
style='font-family:"永中宋体","serif"'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:"Times New Roman"'>kern/schedule/</span></p>

<p class=1><span style='font-family:"Times New Roman"'>              sched.[ch]</span><span
lang=ZH-CN style='font-family:楷体'>：新增：</span><span lang=AR-SA style='font-family:
楷体'>实现</span><span style='font-family:"Times New Roman"'>FIFO</span><span
lang=AR-SA style='font-family:楷体'>策略的进程调度</span></p>

<p class=1 style='margin-left:21.0pt;text-indent:-21.0pt'><span
style='font-family:"永中宋体","serif"'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:"Times New Roman"'>kern/libs</span></p>

<p class=1><span style='font-family:"Times New Roman"'>     rb_tree.[ch]</span><span
lang=AR-SA style='font-family:楷体'>：新增：实现红黑树，被</span><span style='font-family:
"Times New Roman"'>slab</span><span lang=AR-SA style='font-family:楷体'>分配的简化算法使用（可不用理会）</span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-align:justify;text-justify:
inter-ideograph;text-autospace:none'><b><span lang=ZH-CN style='font-family:
楷体'>编译执行</span></b></p>

<p class=MsoNormal style='margin-top:.7pt;line-height:10.0pt;text-autospace:
none'><span>&nbsp;</span></p>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><span lang=AR-SA style='font-family:楷体'>编译并运行代码的命令如下：</span></p>

<p class=MsoBodyText style='margin-left:21.0pt'><span>make</span></p>

<p class=MsoBodyText style='margin-left:21.0pt'><span>make qemu</span></p>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><span lang=AR-SA style='font-family:楷体'>则可以得到如附录</span><span>A</span><span
lang=AR-SA style='font-family:楷体'>所示的显示内容（仅供参考，不是标准答案输出）</span></p>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><span style='font-size:10.5pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:5.7pt;text-autospace:none'><b><span
style='font-size:17.0pt'>3 </span></b><b><span lang=ZH-CN style='font-size:
17.0pt;font-family:楷体'>内核线程管理</span></b></p>

<p class=MsoNormal style='margin-left:6.5pt;text-autospace:none'><b><span
style='font-size:14.0pt'>3.1 </span></b><a name="OLE_LINK2"><a name="OLE_LINK1"><b><span
lang=AR-SA style='font-size:14.0pt;font-family:楷体'>实验执行流程概述</span></b></a></a></p>

<p class=1 style='text-align:justify;text-justify:inter-ideograph'><span
style='font-family:"Times New Roman"'>     lab2</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span style='font-family:"Times New Roman"'>lab3</span><span
lang=ZH-CN style='font-family:楷体'>完成了对内存的虚拟化，但整个控制流还是一条线串行执行。</span><span
style='font-family:"Times New Roman"'>lab4</span><span lang=ZH-CN
style='font-family:楷体'>将在此基础上进行</span><span style='font-family:"Times New Roman"'>CPU</span><span
lang=ZH-CN style='font-family:楷体'>的虚拟化，即让</span><span style='font-family:"Times New Roman"'>ucore</span><span
lang=ZH-CN style='font-family:楷体'>实现分时共享</span><span style='font-family:"Times New Roman"'>CPU</span><span
lang=ZH-CN style='font-family:楷体'>，实现多条控制流能够并发执行。从某种程度上，我们可以把控制流看作是一个内核线程。</span><span
lang=AR-SA style='font-family:楷体'>本次实验将首先接触的是内核线程的管理。内核线程是一种特殊的进程，内核线程与用户进程的区别有两个：内核线程只运行在内核态而用户进程会在在用户态和内核态交替运行；所有内核线程直接使用共同的</span><span>ucore</span><span
lang=AR-SA style='font-family:楷体'>内核内存空间，不需为每个内核线程维护单独的内存空间而用户进程需要维护各自的用户内存空间。</span><span
lang=ZH-CN style='font-family:楷体'>从内存空间占用情况这个角度上看，我们可以把线程看作是一种共享内存空间的轻量级进程。</span></p>

<p class=1 style='text-align:justify;text-justify:inter-ideograph;text-indent:
24.0pt'><span lang=ZH-CN style='font-family:楷体'>为了实现内核线程，需要设计管理线程的数据结构，即进程控制块（在这里也可叫做线程控制块）。如果要让内核线程运行，我们首先要创建内核线程对应的进程控制块，还需把这些进程控制块通过链表连在一起，便于随时进行插入，删除和查找操作等进程管理事务。这个链表就是进程控制块链表。然后在通过调度器（</span><span>scheduler</span><span
lang=ZH-CN style='font-family:楷体'>）来让不同的内核线程在不同的时间段占用</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>执行，实现对</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>的分时共享。那</span><span>lab4</span><span
lang=ZH-CN style='font-family:楷体'>中是如何一步一步实现这个过程的呢？</span></p>

<p class=1 style='text-align:justify;text-justify:inter-ideograph;text-indent:
24.0pt'><span lang=ZH-CN style='font-family:楷体'>我们还是从</span><span>lab4/kern/init/init.c</span><span
lang=ZH-CN style='font-family:楷体'>中的</span><span>kern_init</span><span
lang=ZH-CN style='font-family:楷体'>函数入手分析。在</span><span>kern_init</span><span
lang=ZH-CN style='font-family:楷体'>函数中，当完成虚拟内存的初始化工作后，就调用了</span><span>proc_init</span><span
lang=ZH-CN style='font-family:楷体'>函数，这个函数完成了</span><span>idleproc</span><span
lang=ZH-CN style='font-family:楷体'>内核线程和</span><span>initproc</span><span
lang=ZH-CN style='font-family:楷体'>内核线程的创建或复制工作，这也是本次实验要完成的练习。</span><span>idleproc</span><span
lang=ZH-CN style='font-family:楷体'>内核线程的工作就是不停地查询，看是否有其他内核线程可以执行了，如果有，马上让调度器选择那个内核线程执行（请参考</span><span>cpu_idle</span><span
lang=ZH-CN style='font-family:楷体'>函数的实现）。所以</span><span>idleproc</span><span
lang=ZH-CN style='font-family:楷体'>内核线程是在</span><span>ucore</span><span
lang=ZH-CN style='font-family:楷体'>操作系统没有其他内核线程可执行的情况下才会被调用。接着就是调用</span><span>kernel_thread</span><span
lang=ZH-CN style='font-family:楷体'>函数来创建</span><span>initproc</span><span
lang=ZH-CN style='font-family:楷体'>内核线程。</span><span>initproc</span><span
lang=ZH-CN style='font-family:楷体'>内核线程的工作就是显示“</span><span>Hello World</span><span
lang=ZH-CN style='font-family:楷体'>”，表明自己存在且能正常工作了。</span></p>

<p class=1 style='text-align:justify;text-justify:inter-ideograph;text-indent:
24.0pt'><span lang=ZH-CN style='font-family:楷体'>调度器会在特定的调度点上执行调度，完成进程切换。在</span><span>lab4</span><span
lang=ZH-CN style='font-family:楷体'>中，这个调度点就一处，即在</span><span>cpu_idle</span><span
lang=ZH-CN style='font-family:楷体'>函数中，此函数如果发现当前进程（也就是</span><span>idleproc</span><span
lang=ZH-CN style='font-family:楷体'>）的</span><span>need_resched</span><span
lang=ZH-CN style='font-family:楷体'>置为</span><span>1</span><span lang=ZH-CN
style='font-family:楷体'>（在初始化</span><span>idleproc</span><span lang=ZH-CN
style='font-family:楷体'>的进程控制块时就置为</span><span>1</span><span lang=ZH-CN
style='font-family:楷体'>了），则调用</span><span>schedule</span><span lang=ZH-CN
style='font-family:楷体'>函数，完成进程调度和进程切换。进程调度的过程其实比较简单，就是在进程控制块链表中查找到一个“合适”的内核线程，所谓“合适”就是指内核线程处于“</span><span>PROC_RUNNABLE</span><span
lang=ZH-CN style='font-family:楷体'>”状态。在接下来的</span><span>switch_to</span><span
lang=ZH-CN style='font-family:楷体'>函数</span><span>(</span><span lang=ZH-CN
style='font-family:楷体'>在后续有详细分析，有一定难度，需深入了解一下</span><span>)</span><span
lang=ZH-CN style='font-family:楷体'>完成具体的进程切换过程。一旦切换成功，那么</span><span>initproc</span><span
lang=ZH-CN style='font-family:楷体'>内核线程就可以通过显示字符串来表明本次实验成功。</span></p>

<p class=1 style='text-align:justify;text-justify:inter-ideograph;text-indent:
24.0pt'><span lang=ZH-CN style='font-family:楷体'>接下来将主要介绍了进程创建所需的重要数据结构</span><span
style='font-family:"Times New Roman"'>--</span><span lang=ZH-CN
style='font-family:楷体'>进程控制块</span><span style='font-family:"Times New Roman"'>
proc_struct</span><span lang=ZH-CN style='font-family:楷体'>，以及</span><span
style='font-family:"Times New Roman"'>ucore</span><span lang=ZH-CN
style='font-family:楷体;color:red'>创建并执行内核线程</span><span style='font-family:"Times New Roman"'>idleproc</span><span
lang=ZH-CN style='font-family:楷体'>和</span><span style='font-family:"Times New Roman"'>initproc</span><span
lang=ZH-CN style='font-family:楷体'>的两种不同方式，特别是创建</span><span style='font-family:
"Times New Roman"'>initproc</span><span lang=ZH-CN style='font-family:楷体'>的方式将被延续到实验五中，扩展为创建用户进程的主要方式。另外，还初步涉及了<span
style='color:red'>进程调度</span>（实验六涉及并会扩展）和<span style='color:red'>进程切换</span>内容。</span></p>

<p class=1 style='text-align:justify;text-justify:inter-ideograph;text-indent:
24.0pt'><span style='font-family:"Times New Roman"'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:6.5pt;text-autospace:none'><b><span
style='font-size:14.0pt'>3.2 </span></b><b><span lang=ZH-CN style='font-size:
14.0pt;font-family:楷体'>设计关键数据结构</span></b><b><span style='font-size:14.0pt'>--</span></b><b><span
lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>进程控制块</span></b></p>

<p class=MsoBodyText style='text-indent:24.0pt'><span lang=AR-SA
style='font-family:楷体'>在实验四中，进程管理信息用</span><span>struct proc_struct</span><span
lang=AR-SA style='font-family:楷体'>表示，在</span><i><span>kern/process/proc.h</span></i><span
lang=AR-SA style='font-family:楷体'>中定义如下：</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:27.7pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=441 valign=top style='width:441.0pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyText><span style='font-size:9.0pt'>struct proc_struct {</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>    enum proc_state
  state;        // Process state</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>    int
  pid;                        // Process ID</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>    int
  runs;                       // the running times of Proces</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>    uintptr_t
  kstack;             // Process kernel stack</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>    volatile bool
  need_resched; // need to be rescheduled to release CPU?</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>    struct proc_struct
  *parent; // the parent process</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>    struct mm_struct
  *mm;        // Process's memory management field</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>    struct context
  context;     // Switch here to run process</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>    struct trapframe
  *tf;       // Trap frame for current interrupt</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>    uintptr_t
  cr3;               // the base addr of Page Directroy Table(PDT)</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>    uint32_t
  flags;              // Process flag</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>    char
  name[PROC_NAME_LEN + 1];  // Process name</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>    list_entry_t
  list_link;    // Process link list </span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>    list_entry_t
  hash_link;    // Process hash list</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>};</span></p>
  </td>
 </tr>
</table>

<p class=MsoBodyText><span>&nbsp;</span></p>

<p class=MsoBodyText><span lang=AR-SA style='font-family:楷体'>下面重点解释一下几个比较重要的成员变量：</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:"永中宋体","serif"'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mm </span><span
lang=AR-SA style='font-family:楷体'>：内存管理的信息，包括内存映射列表、页表指针等。</span><span>mm</span><span
lang=ZH-CN style='font-family:楷体'>成员变量</span><span lang=AR-SA style='font-family:
楷体'>在</span><span>lab3</span><span lang=AR-SA style='font-family:楷体'>中用于虚存管理。但在实际</span><span>OS</span><span
lang=AR-SA style='font-family:楷体'>中，内核线程</span><span lang=ZH-CN
style='font-family:楷体'>常驻内存，</span><span lang=AR-SA style='font-family:楷体'>不需要考虑</span><span>swap
page</span><span lang=AR-SA style='font-family:楷体'>问题，</span><span lang=ZH-CN
style='font-family:楷体'>在</span><span>lab5</span><span lang=ZH-CN
style='font-family:楷体'>中涉及到了用户进程，才考虑进程用户内存空间的</span><span>swap page</span><span
lang=ZH-CN style='font-family:楷体'>问题</span><span lang=AR-SA style='font-family:
楷体'>，</span><span>mm</span><span lang=ZH-CN style='font-family:楷体'>才会发挥作用。</span><span
lang=AR-SA style='font-family:楷体'>所以</span><span lang=ZH-CN style='font-family:
楷体'>在</span><span>lab4</span><span lang=ZH-CN style='font-family:楷体'>中</span><span>mm</span><span
lang=AR-SA style='font-family:楷体'>对于内核线程就没有用了，</span><span lang=ZH-CN
style='font-family:楷体'>这样</span><span lang=AR-SA style='font-family:楷体'>内核线程</span><span
lang=ZH-CN style='font-family:楷体'>的</span><span>proc_struct</span><span
lang=ZH-CN style='font-family:楷体'>的成员变量</span><span>*mm=0</span><span
lang=AR-SA style='font-family:楷体'>是合理的。</span><span style='color:black'>mm</span><span
lang=AR-SA style='font-family:楷体'>里有个很重要的项</span><span>pgdir</span><span
lang=AR-SA style='font-family:楷体'>，记录的是该进程使用的一级页表的物理地址。</span><span lang=ZH-CN
style='font-family:楷体'>由于</span><span>*mm=NULL</span><span lang=AR-SA
style='font-family:楷体'>，所以在</span><span>proc_struct</span><span lang=AR-SA
style='font-family:楷体'>数据结构中</span><span lang=ZH-CN style='font-family:楷体'>需要</span><span
lang=AR-SA style='font-family:楷体'>有一个</span><span lang=ZH-CN style='font-family:
楷体'>代替</span><span>pgdir</span><span lang=ZH-CN style='font-family:楷体'>项来</span><span
lang=AR-SA style='font-family:楷体'>记录页表起始地址</span><span lang=ZH-CN
style='font-family:楷体'>，这就是</span><span>proc_struct</span><span lang=AR-SA
style='font-family:楷体'>数据结构中的</span><span>cr3</span><span lang=AR-SA
style='font-family:楷体'>成员变量。</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:"永中宋体","serif"'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>state</span><span
lang=AR-SA style='font-family:楷体'>：进程所处的状态。</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:"永中宋体","serif";
color:black'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>parent </span><span lang=AR-SA style='font-family:楷体'>：用户进程的父进程（创建它的进程）。在所有进程中，只有一个进程没有父进程，就是内核创建的第一个内核线程</span><span>idleproc</span><span
lang=AR-SA style='font-family:楷体'>。内核根据这个父子<span style='color:black'>关系建立</span></span><span
lang=ZH-CN style='font-family:楷体;color:black'>一个</span><span lang=AR-SA
style='font-family:楷体;color:black'>树形结构，用于维护一些特殊的操作，例如确定</span><span
lang=ZH-CN style='font-family:楷体;color:black'>某个</span><span lang=AR-SA
style='font-family:楷体;color:black'>进程是否可以对另外一</span><span lang=ZH-CN
style='font-family:楷体;color:black'>个</span><span lang=AR-SA style='font-family:
楷体;color:black'>进程进行</span><span lang=ZH-CN style='font-family:楷体;color:black'>某种</span><span
lang=AR-SA style='font-family:楷体;color:black'>操作等等。</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:"永中宋体","serif";
color:black'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>context</span><span lang=AR-SA style='font-family:楷体'>：进程的上下文，用于进程切换（参见</span><span>switch.S</span><span
lang=AR-SA style='font-family:楷体'>）。<span style='color:black'>在</span></span><span
style='color:black'> ucore </span><span lang=AR-SA style='font-family:楷体;
color:black'>中，所有的进程在内核中也是相对独立的（例如独立的内核堆栈以及上下文等等）。使用</span><span
style='color:black'> context </span><span lang=AR-SA style='font-family:楷体;
color:black'>保存寄存器的目的就在于在内核态中能够进行上下文之间的切换。实际利用</span><span style='color:black'>context</span><span
lang=AR-SA style='font-family:楷体;color:black'>进行上下文切换的函数是在</span><i><span
style='color:black'>kern/process/switch.S</span></i><span lang=AR-SA
style='font-family:楷体;color:black'>中定义</span><span style='color:black'>switch_to</span><span
lang=AR-SA style='font-family:楷体;color:black'>。</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:"永中宋体","serif"'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>tf</span><span
lang=AR-SA style='font-family:楷体'>：中断帧的指针，总是指向内核栈的某个位置：当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态。当内核需要跳回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值。除此之外，</span><span>ucore
</span><span lang=AR-SA style='font-family:楷体'>内核允许嵌套中断。因此为了保证嵌套中断发生时</span><span>tf
</span><span lang=AR-SA style='font-family:楷体'>总是能够指向当前的</span><span> trapframe</span><span
lang=AR-SA style='font-family:楷体'>，</span><span>ucore </span><span lang=AR-SA
style='font-family:楷体'>在内核栈上维护了</span><span> tf </span><span lang=AR-SA
style='font-family:楷体'>的链，可以参考</span><span> trap.c::trap</span><span
lang=AR-SA style='font-family:楷体'>函数做进一步的了解。</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>cr3: cr3 </span><span
lang=AR-SA style='font-family:楷体'>保存页表的物理地址，目的就是进程切换的时候方便直接使用</span><span> lcr3
</span><span lang=AR-SA style='font-family:楷体'>实现页表切换，避免每次都根据</span><span> mm </span><span
lang=AR-SA style='font-family:楷体'>来计算</span><span> cr3</span><span lang=AR-SA
style='font-family:楷体'>。</span><span>mm </span><span lang=AR-SA
style='font-family:楷体'>数据结构是用来实现用户空间的虚存管理的，但是内核线程没有用户空间，它执行的只是内核中的一小段代码（通常是一小段函数），所以它没有</span><span>
mm </span><span lang=AR-SA style='font-family:楷体'>结构，也就是</span><span>NULL</span><span
lang=AR-SA style='font-family:楷体'>。当某个进程是一个普通用户态进程的时候，</span><span>PCB </span><span
lang=AR-SA style='font-family:楷体'>中的</span><span> cr3 </span><span lang=AR-SA
style='font-family:楷体'>就是</span><span> mm </span><span lang=AR-SA
style='font-family:楷体'>中页表（</span><span>pgdir</span><span lang=AR-SA
style='font-family:楷体'>）的物理地址；而当它是内核线程的时候，</span><span>cr3 </span><span
lang=AR-SA style='font-family:楷体'>等于</span><span> boot_cr3</span><span
lang=AR-SA style='font-family:楷体'>。</span><span lang=AR-SA> </span><span
lang=AR-SA style='font-family:楷体'>而</span><span>boot_cr3</span><span
lang=AR-SA style='font-family:楷体'>指向了</span><span>ucore</span><span lang=AR-SA
style='font-family:楷体'>启动时建立好的饿内核虚拟空间的页目录表首地址。</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:"永中宋体","serif"'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>kstack:
</span><span lang=AR-SA style='font-family:楷体'>每个</span><span lang=ZH-CN
style='font-family:楷体'>线</span><span lang=AR-SA style='font-family:楷体'>程都有一个内核</span><span
lang=ZH-CN style='font-family:楷体'>栈</span><span lang=AR-SA style='font-family:
楷体'>，并且位于内核地址空间的不同位置。对于内核线程，该栈就是运行时的程序使用的栈；而对于普通进程，该栈是发生特权级改变的时候使保存被打断的硬件信息用的栈。</span><span>Ucore</span><span
lang=AR-SA style='font-family:楷体'>在创建进程时分配了</span><span> 2 </span><span
lang=AR-SA style='font-family:楷体'>个连续的物理页（参见</span><span> memlayout.h</span><span
lang=ZH-CN style='font-family:楷体'>中</span><span>KSTACKSIZE</span><span
lang=ZH-CN style='font-family:楷体'>的定义</span><span lang=AR-SA style='font-family:
楷体'>）作为内核栈的空间。这个栈很小，所以内核中的代码应该尽可能的紧凑，并且避免在栈上分配大的数据结构，以免栈溢出，导致系统崩溃。</span><span>kstack</span><span
lang=AR-SA style='font-family:楷体'>记录了分配给该进程</span><span>/</span><span
lang=AR-SA style='font-family:楷体'>线程的内核栈的位置。主要作用有以下几点。首先，当内核准备从一个进程切换到另一个的时候，需要根据</span><span>
kstack </span><span lang=AR-SA style='font-family:楷体'>的值正确的设置好</span><span> tss
</span><span lang=AR-SA style='font-family:楷体'>（可以回顾一下在</span><span lang=ZH-CN
style='font-family:楷体'>实验一</span><span lang=AR-SA style='font-family:楷体'>中讲述的</span><span>
tss </span><span lang=AR-SA style='font-family:楷体'>在中断处理过程中的作用），以便在进程切换以后再发生中断时能够使用正确的栈。其次，内核栈位于内核地址空间，并且是不共享的（每个线程都拥有自己的内核栈），因此不受到</span><span>
mm </span><span lang=AR-SA style='font-family:楷体'>的管理，当进程退出的时候，内核能够根据</span><span>
kstack </span><span lang=AR-SA style='font-family:楷体'>的值快速定位栈的位置并进行回收。</span><span>ucore
</span><span lang=AR-SA style='font-family:楷体'>的这种内核栈的设计借鉴的是</span><span> linux
</span><span lang=AR-SA style='font-family:楷体'>的方法（但由于内存管理实现的差异，它实现的远不如</span><span>
linux </span><span lang=AR-SA style='font-family:楷体'>的灵活），它使得每个线程的内核栈在不同的位置，这样从某种程度上方便调试，但同时也使得内核对栈溢出变得十分不敏感，因为一旦发生溢出，它极可能污染内核中其它的数据使得内核崩溃。如果能够通过页表，将所有进程的内核栈映射到固定的地址上去，能够避免这种问题，但又会使得进程切换过程中对栈的修改变得相当繁琐。感兴趣的同学可以参考</span><span>
linux kernel </span><span lang=AR-SA style='font-family:楷体'>的代码对此进行尝试。</span></p>

<p class=MsoBodyText style='margin-left:21.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:24.0pt'><span>&nbsp;</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=AR-SA style='font-family:楷体'>为了管理系统中所有的进程控制块，</span><span>ucore</span><span
lang=AR-SA style='font-family:楷体'>维护了<span style='color:black'>如下全局变量（位于</span></span><i><span
style='color:black'>kern/process/proc.c</span></i><span lang=AR-SA
style='font-family:楷体;color:black'>）：</span></p>

<p class=MsoBodyText style='margin-left:21.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:24.0pt'><span>&nbsp;</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:"永中宋体","serif"'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>static
struct proc *current</span><span lang=ZH-CN style='font-family:楷体'>：</span><span
lang=AR-SA style='font-family:楷体'>当前占用</span><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>且</span><span lang=AR-SA style='font-family:楷体'>处于</span><span>“</span><span
lang=AR-SA style='font-family:楷体'>运行</span><span>”</span><span lang=AR-SA
style='font-family:楷体'>状态进程控制块指针。通常这个变量是只读的，只有在进程切换的时候才进行修改，并且整个切换和修改过程需要保证操作的原子性，目前至少需要屏蔽中断</span><span
lang=ZH-CN style='font-family:楷体'>。</span><span lang=AR-SA style='font-family:
楷体'>可以参考</span><span> switch_to </span><span lang=AR-SA style='font-family:
楷体'>的实现。</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:"永中宋体","serif"'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>static
struct proc *initproc</span><span lang=ZH-CN style='font-family:楷体'>：本实验中，指向一个内核线程。</span><span
lang=AR-SA style='font-family:楷体'>本实验以后</span><span lang=ZH-CN
style='font-family:楷体'>，此指针将</span><span lang=AR-SA style='font-family:楷体'>指向第一个用户态进程</span><span
lang=ZH-CN style='font-family:楷体'>。</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:"永中宋体","serif"'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>static
list_entry_t hash_list[HASH_LIST_SIZE]</span><span lang=ZH-CN style='font-family:
楷体'>：</span><span lang=AR-SA style='font-family:楷体'>所有进程控制块的哈希表，</span><span>proc_struct</span><span
lang=AR-SA style='font-family:楷体'>中的成员变量</span><span>hash_link</span><span
lang=AR-SA style='font-family:楷体'>将基于</span><span>pid</span><span lang=AR-SA
style='font-family:楷体'>链接入这个哈希表中。</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:"永中宋体","serif"'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>list_entry_t
proc_list</span><span lang=ZH-CN style='font-family:楷体'>：</span><span
lang=AR-SA style='font-family:楷体'>所有进程控制块的双向线性列表，</span><span>proc_struct</span><span
lang=AR-SA style='font-family:楷体'>中的成员变量</span><span>list_link</span><span
lang=AR-SA style='font-family:楷体'>将链接入这个链表中。</span></p>

<p class=MsoNormal style='margin-left:6.5pt;text-autospace:none'><b><span
style='font-size:14.0pt'>3.3 </span></b><b><span lang=ZH-CN style='font-size:
14.0pt;font-family:楷体'>创建并执行内核线程</span></b></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>建立进程控制块（</span><span style='font-size:
12.0pt'>proc.c</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中的</span><span
style='font-size:12.0pt'>alloc_proc</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数）后，现在就可以通过进程控制块来创建具体的进程了。首先，考虑最简单的内核线程，它通常只是内核中的一小段代码或者函数，没有用户空间。而由于在操作系统启动后，已经对整个核心内存空间进行了管理，通过设置页表建立了核心虚拟空间（即</span><span
style='font-size:12.0pt'>boot_cr3</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>指向的二级页表描述的空间）。所以内核中的所有线程都不需要再建立各自的页表，只需共享这个核心虚拟空间就可以访问整个物理内存了。</span></p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:34.95pt;
margin-bottom:0cm;margin-left:18.0pt;margin-bottom:.0001pt;text-align:justify;
text-justify:inter-ideograph;text-indent:-18.0pt;text-autospace:none'><b><span>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span></b><b><span
lang=ZH-CN style='font-family:楷体'>创建第</span></b><b><span>0</span></b><b><span
lang=ZH-CN style='font-family:楷体'>个内核线程</span></b><b><span>idleproc</span></b></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>在</span><span style='font-size:12.0pt'>init.c::kern_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数调用了</span><span
style='font-size:12.0pt'>proc.c::proc_init</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>函数。</span><span style='font-size:12.0pt'>proc_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数启动了创建内核线程的步骤。首先当前的执行上下文（从</span><span
style='font-size:12.0pt'>kern_init </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>启动至今）就可以看成是</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>内核（也可看做是内核进程）中的一个内核线程的上下文。为此，</span><span
style='font-size:12.0pt'> ucore </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>通过给当前执行的上下文分配一个进程控制块以及对它进行相应初始化，将其打造成第</span><span
style='font-size:12.0pt'>0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>个内核线程</span><span style='font-size:12.0pt'> -- idleproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>。具体步骤如下：</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>首先调用</span><span style='font-size:12.0pt'>alloc_proc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数来通过</span><span
style='font-size:12.0pt'>kmalloc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数获得</span><span style='font-size:12.0pt'>proc_struct</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>结构的一块内存</span><span
style='font-size:12.0pt'>—proc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，这就是第</span><span style='font-size:12.0pt'>0</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>个进程控制块了，并把</span><span
style='font-size:12.0pt'>proc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>进行初步初始化（即把</span><span style='font-size:12.0pt'>proc_struct</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中的各个成员变量清零）。但有些成员变量设置了特殊的值：</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:26.7pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=460 valign=top style='width:460.3pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyText><span style='font-size:10.0pt;color:gray'>&nbsp;</span><span
  lang=AR-SA style='font-size:9.0pt;font-family:楷体;color:red'>练习</span><span
  style='font-size:9.0pt;color:red'>1</span><span style='font-size:9.0pt'>     //</span><span
  lang=AR-SA style='font-size:9.0pt;font-family:楷体'>设置进程为</span><span
  style='font-size:9.0pt'>“</span><span lang=AR-SA style='font-size:9.0pt;
  font-family:楷体'>初始</span><span style='font-size:9.0pt'>”</span><span
  lang=AR-SA style='font-size:9.0pt;font-family:楷体'>态</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>&nbsp;</span><span
  lang=AR-SA style='font-size:9.0pt;font-family:楷体;color:red'>练习</span><span
  style='font-size:9.0pt;color:red'>1 </span><span style='font-size:9.0pt'>    //</span><span
  lang=AR-SA style='font-size:9.0pt;font-family:楷体'>进程的</span><span
  style='font-size:9.0pt'>pid</span><span lang=AR-SA style='font-size:9.0pt;
  font-family:楷体'>还没设置好</span></p>
  <p class=MsoBodyText><span style='font-size:9.0pt'>&nbsp;</span><span
  lang=AR-SA style='font-size:9.0pt;font-family:楷体;color:red'>练习</span><span
  style='font-size:9.0pt;color:red'>1 </span><span style='font-size:9.0pt'>    //</span><span
  lang=AR-SA style='font-size:9.0pt;font-family:楷体'>进程在内核中使用的内核页表的起始地址</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormalIndent style='text-indent:21.0pt'><span lang=ZH-CN
style='font-family:楷体'>上</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>述三条语句中</span><span style='font-size:12.0pt'>,</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>第一条设置了进程的状态为</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>初始</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>态，这表示进程已经</span><span
style='font-size:12.0pt'> “</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>出生</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>了，正在获取资源茁壮成长中；第二条语句设置了进程的</span><span
style='font-size:12.0pt'>pid</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>为</span><span style='font-size:12.0pt'>-1</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，这表示进程的</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>身份证号</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>还没有办好；第三条语句表明由于该内核线程在内核中运行，故采用为</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>内核已经建立的页表，即设置为在</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>内核页表的起始地址</span><span
style='font-size:12.0pt'>boot_cr3</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>。后续实验中可进一步看出所有进程的内核虚地址空间（也包括物理地址空间）是相同的。既然内核线程共用一个映射内核空间的页表，这表示所有这些内核空间对所有内核线程都是</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>可见</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的，所以更精确地说，这些内核线程都应该是从属于同一个唯一的内核进程</span><span
style='font-size:12.0pt'>—ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>内核。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>接下来，</span><span style='font-size:12.0pt'>proc_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数对</span><span
style='font-size:12.0pt'>idleproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>内核线程进行进一步初始化：</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=487 valign=top style='width:487.0pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormalIndent style='text-indent:0cm'><span>idleproc-&gt;pid = 0;</span></p>
  <p class=MsoNormalIndent style='text-indent:0cm'><span>idleproc-&gt;state =
  PROC_RUNNABLE;</span></p>
  <p class=MsoNormalIndent style='text-indent:0cm'><span>idleproc-&gt;kstack = (uintptr_t)bootstack;</span></p>
  <p class=MsoNormalIndent style='text-indent:0cm'><span>idleproc-&gt;need_resched
  = 1;</span></p>
  <p class=MsoNormalIndent style='text-indent:0cm'><span>set_proc_name(idleproc,
  &quot;idle&quot;);</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>需要注意前</span><span style='font-size:
12.0pt'>4</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>条语句。第一条语句给了</span><span
style='font-size:12.0pt'>idleproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>合法的身份证号</span><span style='font-size:12.0pt'>--0</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，这名正言顺地表明了</span><span
style='font-size:12.0pt'>idleproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>是第</span><span style='font-size:12.0pt'>0</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>个内核线程。通常可以通过</span><span
style='font-size:12.0pt'>pid</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的赋值来表示线程的创建和身份确定。</span><span style='font-size:12.0pt'>“0”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>是第一个的表示方法是计算机领域所特有的，比如</span><span
style='font-size:12.0pt'>C</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>语言定义的第一个数组元素的小标也是</span><span style='font-size:12.0pt'>“0”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>。第二条语句改变了</span><span
style='font-size:12.0pt'>idleproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的状态，使得它从</span><span style='font-size:12.0pt'>“</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>出生</span><span
style='font-size:12.0pt'>”</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>转到了</span><span style='font-size:12.0pt'>“</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>准备工作</span><span
style='font-size:12.0pt'>”</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，就差</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>调度它执行了。第三条语句设置了</span><span
style='font-size:12.0pt'>idleproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>所使用的内核栈的起始地址。需要注意以后的其他线程的内核栈都需要通过分配获得，因为</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>启动时设置的内核栈直接分配给</span><span style='font-size:12.0pt'>idleproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>使用了。第四条很重要，因为</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>希望当前</span><span style='font-size:12.0pt'>CPU</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>应该做更有用的工作，而不是运行</span><span
style='font-size:12.0pt'>idleproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>这个</span><span style='font-size:12.0pt'>“</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>无所事事</span><span
style='font-size:12.0pt'>”</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的内核线程，所以把</span><span style='font-size:12.0pt'>idleproc-&gt;need_resched</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>设置为</span><span
style='font-size:12.0pt'>“1”</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，结合</span><span style='font-size:12.0pt'>idleproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的执行主体</span><span
style='font-size:12.0pt'>--cpu_idle</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数的实现，可以清楚看出如果当前</span><span style='font-size:12.0pt'>idleproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在执行，则只要此标志为</span><span
style='font-size:12.0pt'>1</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，马上就调用</span><span style='font-size:12.0pt'>schedule</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数要求调度器切换其他进程执行。</span></p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:34.95pt;
margin-bottom:0cm;margin-left:18.0pt;margin-bottom:.0001pt;text-align:justify;
text-justify:inter-ideograph;text-indent:-18.0pt;text-autospace:none'><b><span>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span></b><b><span
lang=ZH-CN style='font-family:楷体'>创建第</span></b><b><span>1</span></b><b><span
lang=ZH-CN style='font-family:楷体'>个内核线程</span></b><b><span>initproc</span></b></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>第</span><span style='font-size:12.0pt'>0</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>个内核线程主要工作是完成内核中各个子系统的初始化，然后就通过执行</span><span
style='font-size:12.0pt'>cpu_idle</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数开始过退休生活了。所以</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>接下来还需创建其他进程来完成各种工作，但</span><span
style='font-size:12.0pt'>idleproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>内核子线程自己不想做，于是就通过调用</span><span style='font-size:12.0pt'>kernel_thread</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数创建了一个内核线程</span><span
style='font-size:12.0pt'>init_main</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>。在实验四中，这个子内核线程的工作就是输出一些字符串，然后就返回了（参看</span><span
style='font-size:12.0pt'>init_main</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数）。但在后续的实验中，</span><span style='font-size:12.0pt'>init_main</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的工作就是创建特定的其他内核线程或用户进程（实验五涉及）。下面我们来分析一下创建内核线程的函数</span><span
style='font-size:12.0pt'>kernel_thread</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>：</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=487 valign=top style='width:487.0pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:10.5pt'>kernel_thread(int
  (*fn)(void *), void *arg, uint32_t clone_flags) {</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    struct trapframe tf;</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    memset(&amp;tf, 0,
  sizeof(struct trapframe));</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    tf.tf_cs = KERNEL_CS;</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    tf.tf_ds =
  tf_struct.tf_es = tf_struct.tf_ss = KERNEL_DS;</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    tf.tf_regs.reg_ebx =
  (uint32_t)fn;</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    tf.tf_regs.reg_edx =
  (uint32_t)arg;</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    tf.tf_eip =
  (uint32_t)kernel_thread_entry;</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    return
  do_fork(clone_flags | CLONE_VM, 0, &amp;tf);</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>}</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>注意，</span><span style='font-size:12.0pt'>kernel_thread</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数采用了局部变量</span><span
style='font-size:12.0pt'>tf</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>来放置保存内核线程的临时中断帧，并把中断帧的指针传递给</span><span style='font-size:12.0pt'>do_fork</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数，而</span><span
style='font-size:12.0pt'>do_fork</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数会调用</span><span style='font-size:12.0pt'>copy_thread</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数来在新创建的进程内核栈上专门给进程的中断帧分配一块空间。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>给中断帧分配完空间后，就需要构造新进程的中断帧，具体过程是：首先给</span><span
style='font-size:12.0pt'>tf</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>进行清零初始化，并设置中断帧的代码段（</span><span style='font-size:12.0pt'>tf.tf_cs</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>）和数据段</span><span
style='font-size:12.0pt'>(tf.tf_ds/tf_es/tf_ss)</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>为内核空间的段（</span><span style='font-size:
12.0pt'>KERNEL_CS/ KERNEL_DS</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>），这实际上也说明了</span><span style='font-size:12.0pt'>initproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>内核线程在内核空间中执行。而</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>内核线程从哪里开始执行呢？</span><span style='font-size:12.0pt'>tf.tf_eip</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的指出了是</span><span
style='font-size:12.0pt'>kernel_thread_entry</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>（位于</span><span style='font-size:12.0pt'>kern/process/entry.S</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中），</span><span
style='font-size:12.0pt'>kernel_thread_entry</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>是</span><span style='font-size:12.0pt'>entry.S</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中实现的汇编函数，它做的事情很简单：</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:20.7pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=466 valign=top style='width:466.3pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:10.5pt'>kernel_thread_entry:       
  # void kernel_thread(void)</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    pushl %edx             
  # push arg</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    call *%ebx             
  # call fn</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    pushl %eax             
  # save the return value of fn(arg)</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    call do_exit           
  # call do_exit to terminate current thread</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>从上可以看出，</span><span style='font-size:
12.0pt'>kernel_thread_entry</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数主要为内核线程的主体</span><span style='font-size:12.0pt'>fn</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数做了一个准备开始和结束运行的</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>壳</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，并把函数</span><span
style='font-size:12.0pt'>fn</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的参数</span><span style='font-size:12.0pt'>arg</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>（保存在</span><span
style='font-size:12.0pt'>edx</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>寄存器中）压栈，然后调用</span><span style='font-size:12.0pt'>fn</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数，把函数返回值</span><span
style='font-size:12.0pt'>eax</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>寄存器内容压栈，调用</span><span style='font-size:12.0pt'>do_exit</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数退出线程执行。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span style='font-size:
12.0pt'>do_fork</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>是创建线程的主要函数。</span><span style='font-size:12.0pt'>kernel_thread</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数通过调用</span><span
style='font-size:12.0pt'>do_fork</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数最终完成了内核线程的创建工作。下面我们来分析一下</span><span style='font-size:12.0pt'>do_fork</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数的实现（练习</span><span
style='font-size:12.0pt'>2</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>）。</span><span style='font-size:12.0pt'>do_fork</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数主要做了以下</span><span
style='font-size:12.0pt'>6</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>件事情：</span></p>

<p class=10 style='margin-left:57.0pt;text-indent:-36.0pt'><span
style='font-size:12.0pt'>1．<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>分配并初始化进程控制块（</span><span
style='font-size:12.0pt'>alloc_proc</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数）；</span></p>

<p class=10 style='margin-left:57.0pt;text-indent:-36.0pt'><span
style='font-size:12.0pt'>2．<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>分配并初始化内核栈（</span><span
style='font-size:12.0pt'>setup_stack</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数）；</span></p>

<p class=10 style='margin-left:57.0pt;text-indent:-36.0pt'><span
style='font-size:12.0pt'>3．<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>根据</span><span
style='font-size:12.0pt'>clone_flag</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>标志复制或共享进程内存管理结构（</span><span style='font-size:12.0pt'>copy_mm</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数）；</span></p>

<p class=10 style='margin-left:57.0pt;text-indent:-36.0pt'><span
style='font-size:12.0pt'>4．<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>设置进程在内核（将来也包括用户态）正常运行和调度所需的中断帧和执行上下文（</span><span
style='font-size:12.0pt'>copy_thread</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数）；</span></p>

<p class=10 style='margin-left:57.0pt;text-indent:-36.0pt'><span
style='font-size:12.0pt'>5．<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>把设置好的进程控制块放入</span><span
style='font-size:12.0pt'>hash_list</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>和</span><span style='font-size:12.0pt'>proc_list</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>两个全局进程链表中；</span></p>

<p class=10 style='margin-left:57.0pt;text-indent:-36.0pt'><span
style='font-size:12.0pt'>6．<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>自此，进程已经准备好执行了，把进程状态设置为</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>就绪</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>态；</span></p>

<p class=10 style='margin-left:57.0pt;text-indent:-36.0pt'><span
style='font-size:12.0pt'>7．<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>设置返回码为子进程的</span><span
style='font-size:12.0pt'>id</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>号。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>这里需要注意的是，如果上述前</span><span
style='font-size:12.0pt'>3</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>步执行没有成功，则需要做对应的出错处理，把相关已经占有的内存释放掉。</span><span
style='font-size:12.0pt'>copy_mm</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数目前只是把</span><span style='font-size:12.0pt'>current-&gt;mm</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>设置为</span><span
style='font-size:12.0pt'>NULL</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，这是由于目前在实验四中只能创建内核线程，</span><span style='font-size:12.0pt'>proc-&gt;mm</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>描述的是进程用户态空间的情况，所以目前</span><span
style='font-size:12.0pt'>mm</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>还用不上。</span><span style='font-size:12.0pt'>copy_thread</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数做的事情比较多，代码如下：</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:21.0pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=472 valign=top style='width:471.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:10.5pt'>static void</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>copy_thread(struct
  proc_struct *proc, uintptr_t esp, struct trapframe *tf) {</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>   //</span><span
  lang=AR-SA style='font-size:10.5pt;font-family:楷体'>在内核堆栈的顶部设置中断帧大小的一块栈空间</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    proc-&gt;tf = (struct
  trapframe *)(proc-&gt;kstack + KSTACKSIZE) - 1;</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    *(proc-&gt;tf) = *tf; 
  //</span><span lang=AR-SA style='font-size:10.5pt;font-family:楷体'>拷贝在</span><span
  style='font-size:10.5pt'>kernel_thread</span><span lang=AR-SA
  style='font-size:10.5pt;font-family:楷体'>函数建立的临时中断帧的初始值</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    proc-&gt;tf-&gt;tf_regs.reg_eax
  = 0;  //</span><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>设置子进程</span><span
  style='font-size:10.5pt'>/</span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>线程执行完</span><span style='font-size:10.5pt'>do_fork</span><span
  lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>后的返回值</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    proc-&gt;tf-&gt;tf_esp
  = esp;  //</span><span lang=AR-SA style='font-size:10.5pt;font-family:楷体'>设置中断帧中的栈指针</span><span
  style='font-size:10.5pt'>esp</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>   
  proc-&gt;tf-&gt;tf_eflags |= FL_IF; //</span><span lang=ZH-CN
  style='font-size:10.5pt;font-family:楷体'>使能中断</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    proc-&gt;context.eip =
  (uintptr_t)forkret;</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    proc-&gt;context.esp =
  (uintptr_t)(proc-&gt;tf);</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>}</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>此函数首先在内核堆栈的顶部设置中断帧大小的一块栈空间，并在此空间中拷贝在</span><span
style='font-size:12.0pt'>kernel_thread</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数建立的临时中断帧的初始值，并进一步设置中断帧中的栈指针</span><span
style='font-size:12.0pt'>esp</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>和标志寄存器</span><span style='font-size:12.0pt'>eflags</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，特别是</span><span
style='font-size:12.0pt'>eflags</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>设置了</span><span style='font-size:12.0pt'>FL_IF</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>标志，这表示此内核线程在执行过程中，能响应中断，打断当前的执行。执行到这步后，此进程的中断帧就建立好了，对于</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>而言，它的中断帧如下所示：</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:21.0pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=472 valign=top style='width:471.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:10.5pt'>//</span><span lang=AR-SA
  style='font-size:10.5pt;font-family:楷体'>所在地址位置</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>initproc-&gt;tf=
  (proc-&gt;kstack+KSTACKSIZE) – sizeof (struct trapframe);   </span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>//</span><span lang=AR-SA
  style='font-size:10.5pt;font-family:楷体'>具体内容</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>initproc-&gt;tf.tf_cs =
  KERNEL_CS;</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>initproc-&gt;tf.tf_ds =
  initproc-&gt;tf.tf_es = initproc-&gt;tf.tf_ss = KERNEL_DS;</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>initproc-&gt;tf.tf_regs.reg_ebx
  = (uint32_t)init_main;</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>initproc-&gt;tf.tf_regs.reg_edx
  = (uint32_t) ADDRESS of &quot;Hello</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>world!!&quot;;</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>initproc-&gt;tf.tf_eip =
  (uint32_t)kernel_thread_entry;</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>initproc-&gt;tf.tf_regs.reg_eax
  = 0; </span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>initproc-&gt;tf.tf_esp =
  esp;</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>initproc-&gt;tf.tf_eflags
  |= FL_IF;</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>设置好中断帧后，最后就是设置</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的进程上下文，（</span><span style='font-size:12.0pt'>process context</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，也称执行现场）了。只有设置好执行现场后，一旦</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>调度器选择了</span><span style='font-size:12.0pt'>initproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>执行，就需要根据</span><span
style='font-size:12.0pt'>initproc-&gt;context</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>中保存的执行现场来恢复</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的执行。这里设置了</span><span style='font-size:12.0pt'>initproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的执行现场中主要的两个信息：上次停止执行时的下一条指令地址</span><span
style='font-size:12.0pt'>context.eip</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>和上次停止执行时的堆栈地址</span><span style='font-size:12.0pt'>context.esp</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>。其实</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>还没有执行过，所以这其实就是</span><span style='font-size:12.0pt'>initproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>实际执行的第一条指令地址和堆栈指针。可以看出，由于</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的中断帧占用了实际给</span><span style='font-size:12.0pt'>initproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>分配的栈空间的顶部，所以</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>就只能把栈顶指针</span><span style='font-size:12.0pt'>context.esp</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>设置在</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的中断帧的起始位置。根据</span><span style='font-size:12.0pt'>context.eip</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的赋值，可以知道</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>实际开始执行的地方在</span><span style='font-size:12.0pt'>forkret</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数（主要完成</span><span
style='font-size:12.0pt'>do_fork</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数返回的处理工作）处。至此，</span><span style='font-size:12.0pt'>initproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>内核线程已经做好准备执行了。</span></p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:34.95pt;
margin-bottom:0cm;margin-left:18.0pt;margin-bottom:.0001pt;text-align:justify;
text-justify:inter-ideograph;text-indent:-18.0pt;text-autospace:none'><b><span>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span></b><b><span
lang=ZH-CN style='font-family:楷体'>调度并执行内核线程</span></b><b><span>initproc </span></b></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>在</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>执行完</span><span
style='font-size:12.0pt'>proc_init</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数后，就创建好了两个内核线程：</span><span style='font-size:12.0pt'>idleproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>和</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，这时</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>当前的执行现场就是</span><span
style='font-size:12.0pt'>idleproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，等到执行到</span><span style='font-size:12.0pt'>init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数的最后一个函数</span><span
style='font-size:12.0pt'>cpu_idle</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>之前，</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的所有初始化工作就结束了，</span><span
style='font-size:12.0pt'>idleproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>将通过执行</span><span style='font-size:12.0pt'>cpu_idle</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数让出</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，给其它内核线程执行，具体过程如下：</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:21.0pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=472 valign=top style='width:471.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:10.5pt'>void<br>
  cpu_idle(void)</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>{<br>
  </span><span style='font-size:10.5pt'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.5pt'>while</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>(1)</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>{<br>
  </span><span style='font-size:10.5pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.5pt'>if</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>(current-&gt;need_resched)</span><span
  style='font-size:10.5pt'>&nbsp;</span><span style='font-size:10.5pt'>{<br>
  </span><span style='font-size:10.5pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.5pt'>schedule();<br>
  </span><span style='font-size:10.5pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.5pt'>……</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>首先，判断当前内核线程</span><span
style='font-size:12.0pt'>idleproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的</span><span style='font-size:12.0pt'>need_resched</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>是否不为</span><span
style='font-size:12.0pt'>0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，回顾前面</span><span style='font-size:12.0pt'>“</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>创建第一个内核线程</span><span
style='font-size:12.0pt'>idleproc”</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>中的描述，</span><span style='font-size:12.0pt'>proc_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数在初始化</span><span
style='font-size:12.0pt'>idleproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中，就把</span><span style='font-size:12.0pt'>idleproc-&gt;need_resched</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>置为</span><span
style='font-size:12.0pt'>1</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>了，所以会马上调用</span><span style='font-size:12.0pt'>schedule</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数找其他处于</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>就绪</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>态的进程执行。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span style='font-size:
12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在实验四中只实现了一个最简单的</span><span
style='font-size:12.0pt'>FIFO</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>调度器，其核心就是</span><span style='font-size:12.0pt'>schedule</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数。它的执行逻辑很简单：</span></p>

<p class=10 style='margin-left:57.0pt;text-indent:-36.0pt'><span
style='font-size:12.0pt'>1．<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>设置当前内核线程</span><span
style='font-size:12.0pt'>current-&gt;need_resched</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>为</span><span style='font-size:12.0pt'>0</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>；</span></p>

<p class=10 style='margin-left:57.0pt;text-indent:-36.0pt'><span
style='font-size:12.0pt'>2．<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在</span><span
style='font-size:12.0pt'>proc_list</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>队列中查找下一个处于</span><span style='font-size:12.0pt'>“</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>就绪</span><span
style='font-size:12.0pt'>”</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>态的线程或进程</span><span style='font-size:12.0pt'>next</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>；</span></p>

<p class=10 style='margin-left:57.0pt;text-indent:-36.0pt'><span
style='font-size:12.0pt'>3．<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>找到这样的进程后，就调用</span><span
style='font-size:12.0pt'>proc_run</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数，保存当前进程</span><span style='font-size:12.0pt'>current</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的执行现场（进程上下文），恢复新进程的执行现场，完成进程切换。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>至此，新的进程</span><span style='font-size:
12.0pt'>next</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>就开始执行了。由于在</span><span
style='font-size:12.0pt'>proc10</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中只有两个内核线程，且</span><span style='font-size:12.0pt'>idleproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>要让出</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>给</span><span style='font-size:12.0pt'>initproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>执行，我们可以看到</span><span
style='font-size:12.0pt'>schedule</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数通过查找</span><span style='font-size:12.0pt'>proc_list</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>进程队列，只能找到一个处于</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>就绪</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>态的</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>内核线程。并通过</span><span style='font-size:12.0pt'>proc_run</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>和进一步的</span><span
style='font-size:12.0pt'>switch_to</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数完成两个执行现场的切换，具体流程如下：</span></p>

<p class=10 style='margin-left:57.0pt;text-indent:-36.0pt'><span
style='font-size:12.0pt'>1．<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>让</span><span
style='font-size:12.0pt'>current</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>指向</span><span style='font-size:12.0pt'>next</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>内核线程</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>；</span></p>

<p class=10 style='margin-left:57.0pt;text-indent:-36.0pt'><span
style='font-size:12.0pt'>2．<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>设置任务状态段</span><span
style='font-size:12.0pt'>ts</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中特权态</span><span style='font-size:12.0pt'>0</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>下的栈顶指针</span><span
style='font-size:12.0pt'>esp0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>为</span><span style='font-size:12.0pt'>next</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>内核线程</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的内核栈的栈顶，即</span><span style='font-size:12.0pt'>next-&gt;kstack</span><span
style='font-size:12.0pt'>&nbsp;</span><span style='font-size:12.0pt'>+</span><span
style='font-size:12.0pt'>&nbsp;</span><span style='font-size:12.0pt'>KSTACKSIZE
</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>；</span></p>

<p class=10 style='margin-left:57.0pt;text-indent:-36.0pt'><span
style='font-size:12.0pt'>3．<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>设置</span><span
style='font-size:12.0pt'>CR3</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>寄存器的值为</span><span style='font-size:12.0pt'>next</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>内核线程</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的页目录表起始地址</span><span style='font-size:12.0pt'>next-&gt;cr3</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，这实际上是完成进程间的页表切换；</span></p>

<p class=10 style='margin-left:57.0pt;text-indent:-36.0pt'><span
style='font-size:12.0pt'>4．<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>由</span><span
style='font-size:12.0pt'>switch_to</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数完成具体的两个线程的执行现场切换，即切换各个寄存器，当</span><span
style='font-size:12.0pt'>switch_to</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数执行完</span><span style='font-size:12.0pt'>“ret”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>指令后，就切换到</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>执行了。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>注意，在第二步设置任务状态段</span><span
style='font-size:12.0pt'>ts</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中特权态</span><span style='font-size:12.0pt'>0</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>下的栈顶指针</span><span
style='font-size:12.0pt'>esp0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的目的是建立好内核线程或将来用户线程在执行特权态切换（从特权态</span><span style='font-size:
12.0pt'>0&lt;--&gt;</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>特权态</span><span style='font-size:12.0pt'>3</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>，或从特权态</span><span style='font-size:
12.0pt'>3&lt;--&gt;</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>特权态</span><span style='font-size:12.0pt'>3</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>）时能够正确定位处于特权态</span><span
style='font-size:12.0pt'>0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>时进程的内核栈的栈顶，而这个栈顶其实放了一个</span><span style='font-size:12.0pt'>trapframe</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>结构的内存空间。如果是在特权态</span><span
style='font-size:12.0pt'>3</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>发生了中断</span><span style='font-size:12.0pt'>/</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>异常</span><span
style='font-size:12.0pt'>/</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>系统调用，则</span><span style='font-size:12.0pt'>CPU</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>会从特权态</span><span
style='font-size:12.0pt'>3--&gt;</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>特权态</span><span style='font-size:12.0pt'>0</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，且</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>从此栈顶（当前被打断进程的内核栈顶）开始压栈来保存被中断</span><span style='font-size:12.0pt'>/</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>异常</span><span
style='font-size:12.0pt'>/</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>系统调用打断的用户态执行现场；如果是在特权态</span><span style='font-size:12.0pt'>0</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>发生了中断</span><span
style='font-size:12.0pt'>/</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>异常</span><span style='font-size:12.0pt'>/</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>系统调用，则</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>会从从当前内核栈指针</span><span style='font-size:12.0pt'>esp</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>所指的位置开始压栈保存被中断</span><span
style='font-size:12.0pt'>/</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>异常</span><span style='font-size:12.0pt'>/</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>系统调用打断的内核态执行现场。反之，当执行完对中断</span><span
style='font-size:12.0pt'>/</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>异常</span><span style='font-size:12.0pt'>/</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>系统调用打断的处理后，最后会执行一个</span><span
style='font-size:12.0pt'>“iret”</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>指令。在执行此指令之前，</span><span style='font-size:12.0pt'>CPU</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的当前栈指针</span><span
style='font-size:12.0pt'>esp</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>一定指向上次产生中断</span><span style='font-size:12.0pt'>/</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>异常</span><span
style='font-size:12.0pt'>/</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>系统调用时</span><span style='font-size:12.0pt'>CPU</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>保存的被打断的指令地址</span><span
style='font-size:12.0pt'>CS</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>和</span><span style='font-size:12.0pt'>EIP</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，</span><span
style='font-size:12.0pt'>“iret”</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>指令会根据</span><span style='font-size:12.0pt'>ESP</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>所指的保存的址</span><span
style='font-size:12.0pt'>CS</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>和</span><span style='font-size:12.0pt'>EIP</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>恢复到上次被打断的地方继续执行。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>在页表设置方面，由于</span><span
style='font-size:12.0pt'>idleproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>和</span><span style='font-size:12.0pt'>initproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>都是共用一个内核页表</span><span
style='font-size:12.0pt'>boot_cr3</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，所以此时第三步其实没用，但考虑到以后的进程有各自的页表，其起始地址各不相同，只有完成页表切换，才能确保新的进程能够正常执行。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>第四步</span><span style='font-size:12.0pt'>proc_run</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数调用</span><span
style='font-size:12.0pt'>switch_to</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数，参数是前一个进程和后一个进程的执行现场：</span><span style='font-size:
12.0pt'>process context</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>。在上一节</span><span style='font-size:12.0pt'>“</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>设计进程控制块</span><span
style='font-size:12.0pt'>”</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中，描述了</span><span style='font-size:12.0pt'>context</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>结构包含的要保存和恢复的寄存器。我们再看看</span><span
style='font-size:12.0pt'>switch.S</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中的</span><span style='font-size:12.0pt'>switch_to</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数的执行流程：</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:21.0pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=472 valign=top style='width:471.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:10.5pt'>.globl switch_to</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>switch_to:                #
  switch_to(from, to)</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    # save from's registers</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    movl 4(%esp), %eax   #
  eax points to from</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    popl 0(%eax)         # esp--&gt;
  return address,  so save return addr in FROM’s context</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    movl %esp, 4(%eax)</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    ……</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    movl %ebp, 28(%eax)</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    # restore to's
  registers</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    movl 4(%esp),
  %eax          # not 8(%esp): popped return address already</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>                            
    # eax now points to to</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    movl 28(%eax), %ebp</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    ……</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    movl 4(%eax), %esp</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    pushl
  0(%eax)               # push TO’s context’s eip, so return addr = TO’s eip</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    ret                       
  # after ret, eip= TO’s eip</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>首先，保存前一个进程的执行现场，前两条汇编指令（如下所示）保存了进程在返回</span><span
style='font-size:12.0pt'>switch_to</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数后的指令地址到</span><span style='font-size:12.0pt'>context.eip</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:21.0pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=472 valign=top style='width:471.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span>   </span><span style='font-size:10.5pt'>movl
  4(%esp), %eax  # eax points to from</span></p>
  <p class=MsoNormal><span style='font-size:10.5pt'>    popl 0(%eax)       # esp--&gt;
  return address,  so save return addr in FROM’s context</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal><span>&nbsp;</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>在接下来的</span><span style='font-size:
12.0pt'>7</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>条汇编指令完成了保存前一个进程的其他</span><span
style='font-size:12.0pt'>7</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>个寄存器到</span><span style='font-size:12.0pt'>context</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中的相应成员变量中。至此前一个进程的执行现场保存完毕。再往后是恢复向一个进程的执行现场，这其实就是上述保存过程的逆执行过程，即从</span><span
style='font-size:12.0pt'>context</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的高地址的成员变量</span><span style='font-size:12.0pt'>ebp</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>开始，逐一把相关成员变量的值赋值给对应的寄存器，倒数第二条汇编指令</span><span
style='font-size:12.0pt'>“pushl 0(%eax)”</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>其实把</span><span style='font-size:12.0pt'>context</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中保存的下一个进程要执行的指令地址</span><span
style='font-size:12.0pt'>context.eip</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>放到了堆栈顶，这样接下来执行最后一条指令</span><span style='font-size:12.0pt'>“ret”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>时，会把栈顶的内容赋值给</span><span
style='font-size:12.0pt'>EIP</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>寄存器，这样就切换到下一个进程执行了，即当前进程已经是下一个进程了。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span style='font-size:
12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>会执行进程切换，让</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>执行。在对</span><span style='font-size:12.0pt'>initproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>进行初始化时，设置了</span><span
style='font-size:12.0pt'>initproc-&gt;context.eip = (uintptr_t)forkret</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，这样，当执行</span><span
style='font-size:12.0pt'>switch_to</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数并返回后，</span><span style='font-size:12.0pt'>initproc</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>将执行其实际上的执行入口地址</span><span
style='font-size:12.0pt'>forkret</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>。而</span><span style='font-size:12.0pt'>forkret</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>会调用位于</span><span
style='font-size:12.0pt'>kern/trap/trapentry.S</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>中的</span><span style='font-size:12.0pt'>forkrets</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数执行，具体代码如下：</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:21.0pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=472 valign=top style='width:471.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:10.5pt'>.globl</span><span
  style='font-size:10.5pt'>&nbsp;</span><span style='font-size:10.5pt'>__trapret<br>
  __trapret:<br>
  </span><span style='font-size:10.5pt'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.5pt'>#</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>restore</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>registers</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>from</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>stack<br>
  </span><span style='font-size:10.5pt'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.5pt'>popal<br>
  </span><span style='font-size:10.5pt'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.5pt'>#</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>restore</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>%ds</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>and</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>%es<br>
  </span><span style='font-size:10.5pt'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.5pt'>popl</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>%es<br>
  </span><span style='font-size:10.5pt'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.5pt'>popl</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>%ds<br>
  </span><span style='font-size:10.5pt'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.5pt'>#</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>get</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>rid</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>of</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>the</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>trap</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>number</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>and</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>error</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>code<br>
  </span><span style='font-size:10.5pt'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.5pt'>addl</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>$0x8,</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>%esp<br>
  </span><span style='font-size:10.5pt'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.5pt'>iret<br>
  .globl</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>forkrets<br>
  forkrets:<br>
  </span><span style='font-size:10.5pt'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.5pt'>#</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>set</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>stack</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>to</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>this</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>new</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>process's</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>trapframe<br>
  </span><span style='font-size:10.5pt'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.5pt'>movl</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>4(%esp),</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>%esp       //</span><span lang=AR-SA
  style='font-size:10.5pt;font-family:楷体'>把</span><span style='font-size:10.5pt'>esp</span><span
  lang=AR-SA style='font-size:10.5pt;font-family:楷体'>指向当前进程的中断帧</span><span
  style='font-size:10.5pt'><br>
  </span><span style='font-size:10.5pt'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.5pt'>jmp</span><span style='font-size:10.5pt'>&nbsp;</span><span
  style='font-size:10.5pt'>__trapret</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>可以看出，</span><span style='font-size:
12.0pt'>forkrets</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>函数首先把</span><span style='font-size:12.0pt'>esp</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>指向当前进程的中断帧，从</span><span
style='font-size:12.0pt'>_trapret</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>开始执行到</span><span style='font-size:12.0pt'>iret</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>前，</span><span
style='font-size:12.0pt'>esp</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>指向了</span><span style='font-size:12.0pt'>current-&gt;tf.tf_eip</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，而如果此时执行的是</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，则</span><span style='font-size:12.0pt'>current-&gt;tf.tf_eip=
kernel_thread_entry</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>，</span><span style='font-size:12.0pt'>initproc-&gt;tf.tf_cs = KERNEL_CS</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，所以当执行完</span><span
style='font-size:12.0pt'>iret</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>后，就开始在内核中执行</span><span style='font-size:12.0pt'>kernel_thread_entry</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数了，而</span><span
style='font-size:12.0pt'>initproc-&gt;tf.tf_regs.reg_ebx = init_main</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，所以在</span><span
style='font-size:12.0pt'>kernl_thread_entry</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>中执行</span><span style='font-size:12.0pt'>“call
%ebx”</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>后，就开始执行</span><span
style='font-size:12.0pt'>initproc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的主体了。</span><span style='font-size:12.0pt'>Initprocde</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的主体函数很简单就是输出一段字符串，然后就返回到</span><span
style='font-size:12.0pt'>kernel_tread_entry</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>函数，并进一步调用</span><span style='font-size:
12.0pt'>do_exit</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>执行退出操作了。本来</span><span style='font-size:12.0pt'>do_exit</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>应该完成一些资源回收工作等，但这些不是实验四涉及的，而是由后续的实验来完成。至此，实验四中的主要工作描述完毕。</span></p>

<p class=MsoNormal style='margin-left:5.7pt;text-autospace:none'><b><span
style='font-size:17.0pt'>4  </span></b><b><span lang=ZH-CN style='font-size:
17.0pt;font-family:楷体'>实验报告要求</span></b></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>从网站上下载</span><span style='font-size:
12.0pt'>lab4.zip</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>后，解压得到本文档和代码目录</span><span style='font-size:12.0pt'> lab4</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，完成实验中的各个练习。完成代码编写并检查无误后，在对应目录下执行</span><span
style='font-size:12.0pt'> make handin </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>任务，即会自动生成</span><span style='font-size:12.0pt'>
lab4-handin.tar.gz</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>。最后请一定提前或按时提交到网络学堂上。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>注意有</span><span style='font-size:12.0pt'>“LAB4”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的注释，代码中所有需要完成的地方（</span><span
style='font-size:12.0pt'>challenge</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>除外）都有</span><span style='font-size:12.0pt'>“LAB4”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>和</span><span
style='font-size:12.0pt'>“YOUR CODE”</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>的注释，请在提交时特别注意保持注释，并将</span><span style='font-size:12.0pt'>“YOUR
CODE”</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>替换为自己的学号，并且将所有标有对应注释的部分填上正确的代码。</span></p>

<p class=MsoNormal><span>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:5.7pt;text-autospace:none'><b><span
lang=ZH-CN style='font-size:17.0pt;font-family:楷体'>附录</span></b><b><span
style='font-size:17.0pt'>A</span></b><b><span lang=ZH-CN style='font-size:17.0pt;
font-family:楷体'>：实验四的参考输出如下：</span></b></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=493 valign=top style='width:492.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='line-height:8.5pt'><span style='font-size:9.0pt;
  color:#222222'>make qemu<br>
  (THU.CST) os is loading ...<br>
  <br>
  Special kernel symbols:<br>
  </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'>entry </span><span style='font-size:
  9.0pt;color:#222222'>&nbsp;</span><span style='font-size:9.0pt;color:#222222'>0xc010002c
  (phys)<br>
  </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'>etext </span><span style='font-size:
  9.0pt;color:#222222'>&nbsp;</span><span style='font-size:9.0pt;color:#222222'>0xc010d0f7
  (phys)<br>
  </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'>edata </span><span style='font-size:
  9.0pt;color:#222222'>&nbsp;</span><span style='font-size:9.0pt;color:#222222'>0xc012dad0
  (phys)<br>
  </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'>end </span><span style='font-size:9.0pt;
  color:#222222'>&nbsp;</span><span style='font-size:9.0pt;color:#222222'> </span><span
  style='font-size:9.0pt;color:#222222'>&nbsp;</span><span style='font-size:
  9.0pt;color:#222222'>0xc0130e78 (phys)<br>
  Kernel executable memory footprint: 196KB<br>
  memory management: default_pmm_manager<br>
  e820map:<br>
  </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'>memory: 0009f400, [00000000, 0009f3ff],
  type = 1.<br>
  </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'>memory: 00000c00, [0009f400, 0009ffff],
  type = 2.<br>
  </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'>memory: 00010000, [000f0000, 000fffff],
  type = 2.<br>
  </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'>memory: 07efd000, [00100000, 07ffcfff],
  type = 1.<br>
  </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'>memory: 00003000, [07ffd000, 07ffffff],
  type = 2.<br>
  </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'>memory: 00040000, [fffc0000, ffffffff],
  type = 2.<br>
  check_alloc_page() succeeded!<br>
  check_pgdir() succeeded!<br>
  check_boot_pgdir() succeeded!<br>
  -------------------- BEGIN --------------------<br>
  PDE(0e0) c0000000-f8000000 38000000 urw<br>
  </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'>|-- PTE(38000) c0000000-f8000000
  38000000 -rw<br>
  PDE(001) fac00000-fb000000 00400000 -rw<br>
  </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'>|-- PTE(000e0) faf00000-fafe0000
  000e0000 urw<br>
  </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'>|-- PTE(00001) fafeb000-fafec000
  00001000 -rw<br>
  --------------------- END ---------------------<br>
  check_slab() succeeded!<br>
  kmalloc_init() succeeded!<br>
  check_vma_struct() succeeded!<br>
  page fault at 0x00000100: K/W [no page found].<br>
  check_pgfault() succeeded!<br>
  check_vmm() succeeded.<br>
  ide 0: </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'> </span><span style='font-size:9.0pt;
  color:#222222'>&nbsp;</span><span style='font-size:9.0pt;color:#222222'> </span><span
  style='font-size:9.0pt;color:#222222'>&nbsp;</span><span style='font-size:
  9.0pt;color:#222222'>10000(sectors), 'QEMU HARDDISK'.<br>
  ide 1: </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'> </span><span style='font-size:9.0pt;
  color:#222222'>&nbsp;</span><span style='font-size:9.0pt;color:#222222'>
  262144(sectors), 'QEMU HARDDISK'.<br>
  SWAP: manager = fifo swap manager<br>
  BEGIN check_swap: count 1, total 31944<br>
  </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'>mm-&gt;sm_priv c0130e64 in fifo_init_mm<br>
  setup Page Table for vaddr 0X1000, so alloc a page<br>
  setup Page Table vaddr 0~4MB OVER!<br>
  set up init env for check_swap begin!<br>
  page fault at 0x00001000: K/W [no page found].<br>
  page fault at 0x00002000: K/W [no page found].<br>
  page fault at 0x00003000: K/W [no page found].<br>
  page fault at 0x00004000: K/W [no page found].<br>
  set up init env for check_swap over!<br>
  write Virt Page c in fifo_check_swap<br>
  write Virt Page a in fifo_check_swap<br>
  write Virt Page d in fifo_check_swap<br>
  write Virt Page b in fifo_check_swap<br>
  write Virt Page e in fifo_check_swap<br>
  page fault at 0x00005000: K/W [no page found].<br>
  swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2<br>
  write Virt Page b in fifo_check_swap<br>
  write Virt Page a in fifo_check_swap<br>
  page fault at 0x00001000: K/W [no page found].<br>
  swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3<br>
  swap_in: load disk swap entry 2 with swap_page in vadr 0x1000<br>
  write Virt Page b in fifo_check_swap<br>
  page fault at 0x00002000: K/W [no page found].<br>
  swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4<br>
  swap_in: load disk swap entry 3 with swap_page in vadr 0x2000<br>
  write Virt Page c in fifo_check_swap<br>
  page fault at 0x00003000: K/W [no page found].<br>
  swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5<br>
  swap_in: load disk swap entry 4 with swap_page in vadr 0x3000<br>
  write Virt Page d in fifo_check_swap<br>
  page fault at 0x00004000: K/W [no page found].<br>
  swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6<br>
  swap_in: load disk swap entry 5 with swap_page in vadr 0x4000<br>
  check_swap() succeeded!<br>
  ++ setup timer interrupts<br>
  this initproc, pid = 1, name = &quot;init&quot;<br>
  To U: &quot;Hello world!!&quot;.<br>
  To U: &quot;en.., Bye, Bye. :)&quot;<br>
  kernel panic at kern/process/proc.c:316:<br>
  </span><span style='font-size:9.0pt;color:#222222'>&nbsp;</span><span
  style='font-size:9.0pt;color:#222222'> </span><span style='font-size:9.0pt;
  color:#222222'>&nbsp;</span><span style='font-size:9.0pt;color:#222222'>process
  exit!!.<br>
  <br>
  Welcome to the kernel debug monitor!!<br>
  Type 'help' for a list of commands.<br>
  K&gt;</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-left:5.7pt;text-autospace:none'><b><span
lang=ZH-CN style='font-size:17.0pt;font-family:楷体'>附录</span></b><b><span
style='font-size:17.0pt'>B</span></b><b><span lang=ZH-CN style='font-size:17.0pt;
font-family:楷体'>：</span></b><b><span lang=ZH-CN style='font-size:17.0pt'> </span></b><b><span
lang=ZH-CN style='font-size:17.0pt;font-family:楷体'>【原理】进程的属性与特征解析</span></b></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>操作系统负责进程管理，即从程序加载到运行结束的全过程，这个程序运行过程将经历从</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>出生</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>到</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>死亡</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的完整</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>生命</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>历程。所谓</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>进程</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>就是指这个程序运行的整个执行过程。为了记录、描述和管理程序执行的动态变化过程，需要有一个数据结构，这就是进程控制块。进程与进程控制块是一一对应的。为此，</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>需要建立合适的进程控制块数据结构，并基于进程控制块来完成对进程的管理。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>为了让多个程序能够使用</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>执行任务，需要设计用于进程管理的内核数据结构</span><span style='font-size:12.0pt'>“</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>进程控制块</span><span
style='font-size:12.0pt'>”</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>。但到底如何设计进程控制块，如何管理进程？如果对进程的属性和特征了解不够，则无法有效地设计进程控制块和实现进程管理。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>再一次回到进程的定义：一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。这里有四个关键词：程序、数据集合、执行和动态执行过程。从</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的角度来看，所谓程序就是一段特定的指令机器码序列而已。</span><span style='font-size:12.0pt'>CPU</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>会一条一条地取出在内存中程序的指令并按照指令的含义执行各种功能；所谓数据集合就是使用的内存；所谓执行就是让</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>工作。这个数据集合和执行其实体现了进程对资源的占用。动态执行过程体现了程序执行的不同</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>生命</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>阶段：诞生、工作、休息</span><span
style='font-size:12.0pt'>/</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>等待、死亡。如果这一段指令执行完毕，也就意味着进程结束了。从开始执行到执行结束是一个进程的全过程。那么操作系统需要管理进程的什么？如果计算机系统中只有一个进程，那操作系统的工作就简单了。进程管理就是管理进程执行的指令，进程占用的资源，进程执行的状态。这可归结为对一个进程内的管理工作。但实际上在计算机系统的内存中，可以放很多程序，这也就意味着操作系统需要管理多个进程，那么，为了协调各进程对系统资源的使用，进程管理还需要做一些与进程协调有关的其他管理工作，包括进程调度、进程间的数据共享、进程间执行的同步互斥关系（后续相关实验涉及）等。下面逐一进行解析。</span></p>

<p class=MsoNormalIndent style='margin-left:21.0pt;text-indent:-21.0pt'><span
style='font-size:12.0pt'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>资源管理</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>在计算机系统中，进程会占用内存和</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，这都是有限的资源，如果不进行合理的管理，资源会耗尽或无法高效公平地使用，从而会导致计算机系统中的多个进程执行效率很低，甚至由于资源不够而无法正常执行。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>对于用户进程而言，操作系统是它的</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>上帝</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，操作系统给了用户进程可以运行所需的资源，最基本的资源就是内存和</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>。在实验二</span><span style='font-size:12.0pt'>/</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>三中涉及的内存管理方法和机制可直接应用到进程的内存资源管理中来。在有多个进程存在的情况下，对于</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>这种资源，则需要通过进程调度来合理选择一个进程，并进一步通过进程分派和进程切换让不同的进程分时复用</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，执行各自的工作。对于无法剥夺的共享资源，如果资源管理不当，多个进程会出现死锁或饥饿现象。</span></p>

<p class=MsoNormalIndent style='margin-left:21.0pt;text-indent:-21.0pt'><span
style='font-size:12.0pt'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>进程状态管理</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>用户进程有不同的状态（可理解为</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>生命</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的不同阶段），当操作系统把程序的放到内存中后，这个进程就</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>诞生</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>了，不过还没有开始执行，但已经消耗了内存资源，处于</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>创建</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>状态；当进程准备好各种资源，就等能够使用</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>时，进程处于</span><span style='font-size:12.0pt'>“</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>就绪</span><span
style='font-size:12.0pt'>”</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>状态；当进程终于占用</span><span style='font-size:12.0pt'>CPU</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，程序的指令被</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>一条一条执行的时候，这个进程就进入了</span><span style='font-size:12.0pt'>“</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>运行</span><span
style='font-size:12.0pt'>”</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>状态，这时除了继续占用内存资源外，还占用了</span><span style='font-size:12.0pt'>CPU</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>资源；当进程由于等待某个资源而无法继续执行时，进程可放弃</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>使用，即释放</span><span style='font-size:12.0pt'>CPU</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>资源，进入</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>等待</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>状态；当程序指令执行完毕，由操作系统回收进程所占用的资源时，进程进入了</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>死亡</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>状态。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>这些进程状态的转换时机需要操作系统管理起来，而且进程的创建和清除等服务必须由操作系统提供，而且在</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>运行</span><span style='font-size:12.0pt'>”</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>与</span><span
style='font-size:12.0pt'>“</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>就绪</span><span style='font-size:12.0pt'>”/“</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>等待</span><span
style='font-size:12.0pt'>”</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>状态之间的转换，涉及到保存和恢复进程的</span><span style='font-size:12.0pt'>“</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>执行现场</span><span
style='font-size:12.0pt'>”</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，也就是进程上下文，这是确保进程即使</span><span style='font-size:12.0pt'>“</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>断断续续</span><span
style='font-size:12.0pt'>”</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>地执行，也能正确完成工作的必要保证。</span></p>

<p class=MsoNormalIndent style='margin-left:21.0pt;text-indent:-21.0pt'><span>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体'>进程与线程</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>一个进程拥有一个存放程序和数据的的虚拟地址空间以及其他资源。一个进程基于程序的指令流执行，其执行过程可能与其它进程的执行过程交替进行。因此，一个具有执行状态（运行态、就绪态等）的进程是一个被操作系统分配资源（比如分配内存）并调度（比如分时使用</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>）的单位。在大多数操作系统中，这两个特点是进程的主要本质特征。但这两个特征相对独立，操作系统可以把这两个特征分别进行管理。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>这样可以把拥有资源所有权的单位通常仍称作进程，对资源的管理成为进程管理；把指令执行流的单位称为线程，对线程的管理就是线程调度和线程分派。对属于同一进程的所有线程而言，这些线程共享进程的虚拟地址空间和其他资源，但每个线程都有一个独立的栈，还有独立的线程运行上下文，用于包含表示线程执行现场的寄存器值等信息。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>在多线程环境中，进程被定义成资源分配与保护的单位，与进程相关联的信息主要有存放进程映像的虚拟地址空间等。在一个进程中，可能有一个或多个线程，每个线程有线程执行状态（运行、就绪、等待等），保存上次运行时的线程上下文、线程的执行栈等。考虑到</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>有不同的特权模式，参照进程的分类，线程又可进一步细化为用户线程和内核线程。</span></p>

<p class=MsoNormalIndent style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>到目前为止，我们就可以明确用户进程、内核进程（可把</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>看成一个内核进程）、用户线程、内核线程的区别了。从本质上看，线程就是一个特殊的不用拥有资源的轻量级进程，在</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的调度和执行管理中，并没有区分线程和进程。且由于</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>内核中的所有内核线程共享一个内核地址空间和其他资源，所以这些内核线程从属于同一个唯一的内核进程，即</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>内核本身。理解了进程或线程的上述属性和特征，就可以进行进程</span><span style='font-size:
12.0pt'>/</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>线程管理的设计与实现了。但是为了叙述上的简便，以下用户态的进程</span><span
style='font-size:12.0pt'>/</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>线程统称为用户进程。</span></p>

</div>

</body>

</html>
