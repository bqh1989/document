<html>

<head>
<meta name=标题 content="实验一：系统软件启动过程">
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=Generator content="Microsoft Word 14 (filtered)">
<title>实验一：系统软件启动过程</title>
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Arial;
	panose-1:2 11 6 4 2 2 2 2 2 4;}
@font-face
	{font-family:"Courier New";
	panose-1:2 7 3 9 2 2 5 2 4 4;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"\@宋体";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
@font-face
	{font-family:"Wingdings 2";
	panose-1:5 2 1 2 1 5 7 7 7 7;}
@font-face
	{font-family:黑体;
	panose-1:2 1 6 9 6 1 1 1 1 1;}
@font-face
	{font-family:"\@黑体";
	panose-1:2 1 6 9 6 1 1 1 1 1;}
@font-face
	{font-family:楷体;
	panose-1:2 1 6 9 6 1 1 1 1 1;}
@font-face
	{font-family:"\@楷体";
	panose-1:2 1 6 9 6 1 1 1 1 1;}
@font-face
	{font-family:微软雅黑;
	panose-1:2 11 5 3 2 2 4 2 2 4;}
@font-face
	{font-family:"\@微软雅黑";
	panose-1:2 11 5 3 2 2 4 2 2 4;}
@font-face
	{font-family:OpenSymbol;}
@font-face
	{font-family:StarSymbol;}
@font-face
	{font-family:"Bitstream Vera Sans";}
@font-face
	{font-family:新宋体;}
@font-face
	{font-family:"\@新宋体";}
@font-face
	{font-family:文泉驿正黑;}
@font-face
	{font-family:"Liberation Sans";}
@font-face
	{font-family:FreeSans;}
@font-face
	{font-family:"\@FreeSans";}
@font-face
	{font-family:"\@Liberation Sans";}
@font-face
	{font-family:"\@文泉驿正黑";}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
h1
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:14.2pt;
	font-size:16.0pt;
	font-family:Arial;
	font-weight:bold;}
h2
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:28.8pt;
	text-indent:-28.8pt;
	font-size:14.0pt;
	font-family:Arial;
	font-weight:bold;
	font-style:italic;}
h3
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:35.45pt;
	font-size:14.0pt;
	font-family:Arial;
	font-weight:bold;}
h4
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:43.2pt;
	text-indent:-43.2pt;
	font-size:12.0pt;
	font-family:Arial;
	font-weight:bold;
	font-style:italic;}
h5
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:50.4pt;
	text-indent:-50.4pt;
	font-size:12.0pt;
	font-family:Arial;
	font-weight:bold;}
h6
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:57.6pt;
	text-indent:-57.6pt;
	font-size:10.5pt;
	font-family:Arial;
	font-weight:bold;}
p.MsoToc2, li.MsoToc2, div.MsoToc2
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:21.0pt;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:"Times New Roman";}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	layout-grid-mode:char;
	border:none;
	padding:0cm;
	font-size:9.0pt;
	font-family:"Times New Roman";}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:"Times New Roman";}
p.MsoList, li.MsoList, div.MsoList
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p.MsoBodyText, li.MsoBodyText, div.MsoBodyText
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
a:link, span.MsoHyperlink
	{color:navy;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:maroon;
	text-decoration:underline;}
p.MsoDocumentMap, li.MsoDocumentMap, div.MsoDocumentMap
	{margin:0cm;
	margin-bottom:.0001pt;
	background:navy;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p
	{margin-right:0cm;
	margin-left:0cm;
	font-size:12.0pt;
	font-family:宋体;}
pre
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:宋体;}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:9.0pt;
	font-family:"Times New Roman";}
p.1, li.1, div.1
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:0cm;
	font-size:14.0pt;
	font-family:Arial;}
span.WW8Num2z0
	{font-family:Wingdings;}
span.WW8Num2z1
	{font-family:"Wingdings 2";}
span.WW8Num2z2
	{font-family:StarSymbol;}
span.WW8Num5z0
	{font-family:Wingdings;}
span.WW8Num6z0
	{font-family:Wingdings;}
span.WW8Num7z0
	{font-family:Wingdings;}
span.WW8Num9z0
	{font-family:Wingdings;}
span.WW8Num11z0
	{font-family:Wingdings;}
span.WW8Num14z0
	{font-family:Symbol;}
span.WW8Num15z0
	{font-family:Wingdings;}
span.WW8Num16z0
	{font-family:Wingdings;}
span.WW8Num17z0
	{font-family:Wingdings;}
span.WW8Num18z0
	{font-family:Wingdings;}
span.WW8Num20z0
	{font-family:Wingdings;}
span.WW8Num21z0
	{font-family:Wingdings;}
span.WW8Num22z0
	{font-family:Symbol;}
span.WW8Num22z1
	{font-family:"Courier New";}
span.WW8Num22z2
	{font-family:Wingdings;}
span.WW8Num23z0
	{font-family:Wingdings;}
span.WW8Num24z0
	{font-family:Wingdings;}
span.a0
	{font-family:OpenSymbol;}
span.a1
	{font-family:"Courier New";}
span.CharChar2
	{font-family:宋体;}
span.CharChar1
	{font-family:"Bitstream Vera Sans";}
span.CharChar
	{font-family:"Bitstream Vera Sans";}
span.CharChar3
	{font-family:"Bitstream Vera Sans";}
span.PlainTextChar
	{font-family:宋体;}
p.Heading, li.Heading, div.Heading
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:0cm;
	font-size:14.0pt;
	font-family:"Liberation Sans","sans-serif";}
p.11, li.11, div.11
	{margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:0cm;
	font-size:12.0pt;
	font-family:"Times New Roman";
	font-style:italic;}
p.Index, li.Index, div.Index
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p.a2, li.a2, div.a2
	{margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:0cm;
	font-size:12.0pt;
	font-family:"Times New Roman";
	font-style:italic;}
p.a3, li.a3, div.a3
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p.a4, li.a4, div.a4
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p.a5, li.a5, div.a5
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:10.0pt;
	font-family:"Courier New";}
p.a6, li.a6, div.a6
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:12.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
p.12, li.12, div.12
	{margin-top:7.6pt;
	margin-right:0cm;
	margin-bottom:8.0pt;
	margin-left:0cm;
	text-align:center;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p.a7, li.a7, div.a7
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p.13, li.13, div.13
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:9.0pt;
	font-family:宋体;}
p.14, li.14, div.14
	{margin-top:5.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:宋体;}
p.15, li.15, div.15
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:21.25pt;
	line-height:12.0pt;
	font-size:10.5pt;
	font-family:宋体;}
p.Framecontents, li.Framecontents, div.Framecontents
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p.TableContents, li.TableContents, div.TableContents
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p.TableHeading, li.TableHeading, div.TableHeading
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:12.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
span.a8
	{font-family:"Bitstream Vera Sans";}
span.a9
	{font-family:"Bitstream Vera Sans";}
.MsoChpDefault
	{font-size:10.0pt;}
 /* Page Definitions */
@page WordSection1
	{size:595.3pt 841.9pt;
	margin:36.0pt 36.0pt 36.0pt 36.0pt;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>

</head>

<body bgcolor=white lang=EN-US link=navy vlink=maroon>

<div class=WordSection1>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<p class=MsoNormal align=center style='text-align:center'><span lang=ZH-CN
style='font-size:16.0pt;font-family:楷体'>实验一：系统软件启动过程</span></p>

<h1 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:0cm'><span style='font-family:"Times New Roman"'>1.</span><span
lang=AR-SA style='font-family:楷体'>实验目的：</span></h1>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>操作系统是一个软件，也需要通过某种机制加载并运行它。在这里我们将通过另外一个更加简单的软件</span><span>-bootloader</span><span
lang=ZH-CN style='font-family:楷体'>来完成这些工作。为此，我们需要完成一个能够切换到</span><span>x86</span><span
lang=ZH-CN style='font-family:楷体'>的保护模式并显示字符的</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>，为启动操作系统</span><span>ucore</span><span
lang=ZH-CN style='font-family:楷体'>做准备。</span><span>lab1</span><span lang=ZH-CN
style='font-family:楷体'>提供了一个非常小的</span><span>bootloader</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span>ucore OS</span><span lang=ZH-CN
style='font-family:楷体'>，整个</span><span>bootloader</span><span lang=ZH-CN
style='font-family:楷体'>执行代码小于</span><span>512</span><span lang=ZH-CN
style='font-family:楷体'>个字节，这样才能放到硬盘的主引导扇区中。通过分析和实现这个</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>和</span><span>ucore OS</span><span
lang=ZH-CN style='font-family:楷体'>，读者可以了解到：</span></p>

<p class=MsoNormal style='margin-left:45.4pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:文泉驿正黑'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体'>基于分段机制的存储管理</span></p>

<p class=MsoNormal style='margin-left:45.4pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:文泉驿正黑'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体'>设备管理的基本概念</span></p>

<p class=MsoNormal style='margin-left:45.4pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:文泉驿正黑'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>PC</span><span
lang=ZH-CN style='font-family:楷体'>启动</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>的过程</span></p>

<p class=MsoNormal style='margin-left:45.4pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:文泉驿正黑'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>的文件组成</span></p>

<p class=MsoNormal style='margin-left:45.4pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:文泉驿正黑'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体'>编译运行</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>的过程</span></p>

<p class=MsoNormal style='margin-left:45.4pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:文泉驿正黑'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体'>调试</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>的方法</span></p>

<p class=MsoNormal style='margin-left:45.4pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:文泉驿正黑'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ucore
OS</span><span lang=ZH-CN style='font-family:楷体'>的启动过程</span></p>

<p class=MsoNormal style='margin-left:45.4pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:文泉驿正黑'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体'>在汇编级了解栈的结构和处理过程</span></p>

<p class=MsoNormal style='margin-left:45.4pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:文泉驿正黑'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体'>中断处理机制</span></p>

<p class=MsoNormal style='margin-left:45.4pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:文泉驿正黑'>●<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体'>通过串口</span><span>/</span><span lang=ZH-CN
style='font-family:楷体'>并口</span><span>/CGA</span><span lang=ZH-CN
style='font-family:楷体'>输出字符的方法</span></p>

<p class=MsoBodyText><span>&nbsp;</span></p>

<h1 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:0cm'><span style='font-size:17.0pt;font-family:"Times New Roman"'>2.</span><span
lang=AR-SA style='font-size:17.0pt;font-family:楷体'>实验内容：</span></h1>

<p class=MsoNormal style='text-indent:24.0pt'><span>lab1</span><span
lang=ZH-CN style='font-family:楷体'>中包含一个</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>和一个</span><span>OS</span><span lang=ZH-CN
style='font-family:楷体'>。这个</span><span>bootloader</span><span lang=ZH-CN
style='font-family:楷体'>可以切换到</span><span>X86</span><span lang=ZH-CN
style='font-family:楷体'>保护模式，能够读磁盘并加载</span><span>ELF</span><span lang=ZH-CN
style='font-family:楷体'>执行文件格式，并显示字符。而这</span><span>lab1</span><span lang=ZH-CN
style='font-family:楷体'>中的</span><span>OS</span><span lang=ZH-CN
style='font-family:楷体'>只是一个可以处理时钟中断和显示字符的幼儿园级别</span><span>OS</span><span
lang=ZH-CN style='font-family:楷体'>。</span></p>

<p class=MsoNormal style='text-autospace:none'><b><span style='font-size:14.0pt'>2.1
</span></b><b><span lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>练习</span></b></p>

<h3 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>练习</span><span
style='font-size:12.0pt;font-family:"Times New Roman";color:red'>1</span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>：理解通过</span><span
style='font-size:12.0pt;font-family:"Times New Roman";color:red'>make</span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>生成执行文件的过程。（要求在报告中写出对下述问题的回答）</span></h3>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-family:楷体'>在此练习中，大家需要通过静态分析代码来了解：</span></p>

<p class=MsoBodyText style='margin-left:57.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>操作系统镜像文件</span><span>ucore.img</span><span
lang=ZH-CN style='font-family:楷体'>是如何一步一步生成的？</span><span>(</span><span
lang=ZH-CN style='font-family:楷体'>需要比较详细地解释</span><span>Makefile</span><span
lang=ZH-CN style='font-family:楷体'>中每一条相关命令和命令参数的含义，以及说明命令导致的结果</span><span>)</span></p>

<p class=MsoBodyText style='margin-left:57.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>补充材料：</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>如何调试</span><span
style='font-size:10.5pt'>Makefile</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:23.25pt'><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>当执行</span><span
style='font-size:10.5pt'>make</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>时，一般只会显示输出，不会显示</span><span style='font-size:10.5pt'>make</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>到底执行了哪些命令。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:23.25pt'><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>如想了解</span><span
style='font-size:10.5pt'>make</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>执行了哪些命令，可以执行：</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:23.25pt'><span style='font-size:10.5pt'>$ make &quot;V=&quot;</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:23.25pt'><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>要获取更多有关</span><span
style='font-size:10.5pt'>make</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>的信息，可上网查询，并请执行</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:23.25pt'><span style='font-size:10.5pt'>$ man make</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<h3 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>练习</span><span
style='font-size:12.0pt;font-family:"Times New Roman";color:red'>2</span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>：使用</span><span
style='font-size:12.0pt;font-family:"Times New Roman";color:red'>qemu</span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>执行并调试</span><span
style='font-size:12.0pt;font-family:"Times New Roman";color:red'>lab1</span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>中的软件。（要求在报告中简要写出练习过程）</span></h3>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>为了熟悉使用</span><span>qemu</span><span
lang=ZH-CN style='font-family:楷体'>和</span><span>gdb</span><span lang=ZH-CN
style='font-family:楷体'>进行的调试工作，我们进行如下的小练习：</span></p>

<p class=MsoBodyText style='margin-left:57.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>从</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>加电后执行的第一条指令开始，单步跟踪</span><span>BIOS</span><span
lang=ZH-CN style='font-family:楷体'>的执行。</span><span lang=ZH-CN> </span></p>

<p class=MsoBodyText style='margin-left:57.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>在初始化位置</span><span>0x7c00</span><span
lang=ZH-CN style='font-family:楷体'>设置实地址断点</span><span>,</span><span lang=ZH-CN
style='font-family:楷体'>测试断点正常。</span></p>

<p class=MsoBodyText style='margin-left:57.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>从</span><span>0x7c00</span><span
lang=ZH-CN style='font-family:楷体'>开始跟踪代码运行</span><span>,</span><span
lang=ZH-CN style='font-family:楷体'>将单步跟踪反汇编得到的代码与</span><span>bootasm.S</span><span
lang=ZH-CN style='font-family:楷体'>和</span><span> bootblock.asm</span><span
lang=ZH-CN style='font-family:楷体'>进行比较。</span></p>

<p class=MsoBodyText style='margin-left:57.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>自己找一个</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>或内核中的代码位置，设置断点并进行测试。</span><span lang=ZH-CN> </span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><b><span
style='color:red'>&nbsp;</span></b></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>提示：<span style='color:red'>参考附录“启动后第一条执行的指令”</span></span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>补充材料：</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>我们主要通过硬件模拟器</span><span
style='font-size:10.5pt'>qemu</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>来进行各种实验。在实验的过程中我们可能会遇上各种各样的问题，调试是必要的。</span><span
style='font-size:10.5pt'>qemu</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>支持使用</span><span style='font-size:10.5pt'>gdb</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>进行的强大而方便的调试。所以用好</span><span
style='font-size:10.5pt'>qemu</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>和</span><span style='font-size:10.5pt'>gdb</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>是完成各种实验的基本要素。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>默认的</span><span
style='font-size:10.5pt'>gdb</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>需要进行一些额外的配置才进行</span><span style='font-size:10.5pt'>qemu</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>的调试任务。</span><span
style='font-size:10.5pt'>qemu</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>和</span><span style='font-size:10.5pt'>gdb</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>之间使用网络端口</span><span
style='font-size:10.5pt'>1234</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>进行通讯。在打开</span><span style='font-size:10.5pt'>qemu</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>进行模拟之后，执行</span><span
style='font-size:10.5pt'>gdb</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>并输入</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span style='font-size:10.5pt'>target remote localhost:1234</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>即可连接</span><span
style='font-size:10.5pt'>qemu</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>，此时</span><span style='font-size:10.5pt'>qemu</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>会进入停止状态，听从</span><span
style='font-size:10.5pt'>gdb</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>的命令。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>另外，我们可能需要</span><span
style='font-size:10.5pt'>qemu</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>在一开始便进入等待模式，则我们不再使用</span><span style='font-size:10.5pt'>make
qemu</span><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>开始系统的运行，而使用</span><span
style='font-size:10.5pt'>make debug</span><span lang=ZH-CN style='font-size:
10.5pt;font-family:楷体'>来完成这项工作。这样</span><span style='font-size:10.5pt'>qemu</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>便不会在</span><span
style='font-size:10.5pt'>gdb</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>尚未连接的时候擅自运行了。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
style='font-size:10.5pt'>gdb</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>的地址断点</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
style='font-size:10.5pt'>       </span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>在</span><span style='font-size:10.5pt'>gdb</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>命令行中，使用</span><span
style='font-size:10.5pt'>b *[</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>地址</span><span style='font-size:10.5pt'>]</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>便可以在指定内存地址设置断点，当</span><span
style='font-size:10.5pt'>qemu</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>中的</span><span style='font-size:10.5pt'>cpu</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>执行到指定地址时，便会将控制权交给</span><span
style='font-size:10.5pt'>gdb</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>关于代码的反汇编</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
style='font-size:10.5pt'>       </span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>有可能</span><span style='font-size:10.5pt'>gdb</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>无法正确获取当前</span><span
style='font-size:10.5pt'>qemu</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>执行的汇编指令，通过如下配置可以在每次</span><span style='font-size:10.5pt'>gdb</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>命令行前强制反汇编当前的指令，在</span><span
style='font-size:10.5pt'>gdb</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>命令行或配置文件中添加：</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
style='font-size:10.5pt'>define hook-stop</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
style='font-size:10.5pt'>x/i $pc</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
style='font-size:10.5pt'>end</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>即可</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
style='font-size:10.5pt'>gdb</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>的单步命令</span></p>

<p class=MsoBodyText style='margin-left:21.0pt;text-align:justify;text-justify:
inter-ideograph'><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>在</span><span
style='font-size:10.5pt'>gdb</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>中，有</span><span style='font-size:10.5pt'>next, nexti, step,
stepi</span><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>等指令来单步调试程序，他们功能各不相同，区别在于单步的</span><span
style='font-size:10.5pt'>“</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>跨度</span><span style='font-size:10.5pt'>”</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>上。</span></p>

<p class=MsoBodyText style='margin-left:21.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:21.0pt'><span style='font-size:10.5pt'>next </span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>单步到程序源代码的下一行，不进入函数。</span></p>

<p class=MsoBodyText style='margin-left:21.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:21.0pt'><span style='font-size:10.5pt'>nexti </span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>单步一条机器指令，不进入函数。</span></p>

<p class=MsoBodyText style='margin-left:21.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:21.0pt'><span style='font-size:10.5pt'>step </span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>单步到下一个不同的源代码行（包括进入函数）。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
style='font-size:10.5pt'>stepi </span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>单步一条机器指令。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<h3 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>练习</span><span
style='font-size:12.0pt;font-family:"Times New Roman";color:red'>3</span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>：分析</span><span
style='font-size:12.0pt;font-family:"Times New Roman";color:red'>bootloader</span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>进入保护模式的过程。（要求在报告中写出分析）</span></h3>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span>BIOS</span><span
lang=ZH-CN style='font-family:楷体'>将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>。请分析</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>是如何完成从实模式进入保护模式的。</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>提示：需要阅读</span><span
style='font-size:10.5pt'>3.2.1</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>小节“保护模式和分段机制”和</span><span style='font-size:10.5pt'>lab1/boot/bootasm.S</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>源码，了解如何从实模式切换到保护模式。</span><span
lang=ZH-CN> </span></p>

<h3 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>练习</span><span
style='font-size:12.0pt;font-family:"Times New Roman";color:red'>4</span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>：分析</span><span
style='font-size:12.0pt;font-family:"Times New Roman";color:red'>bootloader</span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>加载</span><span
style='font-size:12.0pt;font-family:"Times New Roman";color:red'>ELF</span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>格式的</span><span
style='font-size:12.0pt;font-family:"Times New Roman";color:red'>OS</span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>的过程。（要求在报告中写出分析）</span></h3>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-family:楷体'>通过阅读</span><span>bootmain.c</span><span
lang=ZH-CN style='font-family:楷体'>，了解</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>如何加载</span><span>ELF</span><span lang=ZH-CN
style='font-family:楷体'>文件。通过分析源代码和通过</span><span>qemu</span><span lang=ZH-CN
style='font-family:楷体'>来运行并调试</span><span>bootloader&amp;OS</span><span
lang=ZH-CN style='font-family:楷体'>，</span></p>

<p class=MsoBodyText style='margin-left:36.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>bootloader</span><span lang=ZH-CN style='font-family:楷体'>如何读取硬盘扇区的？</span></p>

<p class=MsoBodyText style='margin-left:36.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>bootloader</span><span lang=ZH-CN style='font-family:楷体'>是如何加载</span><span>ELF</span><span
lang=ZH-CN style='font-family:楷体'>格式的</span><span>OS</span><span lang=ZH-CN
style='font-family:楷体'>？</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>提示：可阅读</span><span
style='font-size:10.5pt'>3.2.3</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>“硬盘访问概述”，</span><span style='font-size:10.5pt'>3.2.4</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>“</span><span
style='font-size:10.5pt'>ELF</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>执行文件格式概述”。</span></p>

<h3 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>练习</span><span
style='font-size:12.0pt;font-family:"Times New Roman";color:red'>5</span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>：实现函数调用堆栈跟踪函数</span><span
lang=AR-SA style='font-size:12.0pt;font-family:"Times New Roman";color:red'> </span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>（需要编程）</span></h3>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>我们需要在</span><span>lab1</span><span
lang=ZH-CN style='font-family:楷体'>中完成</span><span>kdebug.c</span><span
lang=ZH-CN style='font-family:楷体'>中函数</span><span>print_stackframe</span><span
lang=ZH-CN style='font-family:楷体'>的实现，可以通过函数</span><span>print_stackframe</span><span
lang=ZH-CN style='font-family:楷体'>来跟踪函数调用堆栈中记录的返回地址。在如果能够正确实现此函数，可在</span><span>lab1</span><span
lang=ZH-CN style='font-family:楷体'>中执行</span><span> “make qemu”</span><span
lang=ZH-CN style='font-family:楷体'>后，在</span><span>qemu</span><span lang=ZH-CN
style='font-family:楷体'>模拟器中得到类似如下的输出：</span></p>

<div align=center>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:83.4pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=375 valign=top style='width:374.8pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>……</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>ebp:0x00007b28 eip:0x00100992 args:0x00010094
  0x00010094 0x00007b58 0x00100096 </span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>    kern/debug/kdebug.c:305: print_stackframe+22</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>ebp:0x00007b38 eip:0x00100c79 args:0x00000000
  0x00000000 0x00000000 0x00007ba8 </span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>    kern/debug/kmonitor.c:125: mon_backtrace+10</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>ebp:0x00007b58 eip:0x00100096 args:0x00000000
  0x00007b80 0xffff0000 0x00007b84 </span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>    kern/init/init.c:48: grade_backtrace2+33</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>ebp:0x00007b78 eip:0x001000bf args:0x00000000
  0xffff0000 0x00007ba4 0x00000029 </span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>    kern/init/init.c:53: grade_backtrace1+38</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>ebp:0x00007b98 eip:0x001000dd args:0x00000000
  0x00100000 0xffff0000 0x0000001d </span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>    kern/init/init.c:58: grade_backtrace0+23</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>ebp:0x00007bb8 eip:0x00100102 args:0x0010353c
  0x00103520 0x00001308 0x00000000 </span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>    kern/init/init.c:63: grade_backtrace+34</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>ebp:0x00007be8 eip:0x00100059 args:0x00000000
  0x00000000 0x00000000 0x00007c53 </span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>    kern/init/init.c:28: kern_init+88</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
  style='font-size:9.0pt'>ebp:0x00007bf8 eip:0x00007d73 args:0xc031fcfa
  0xc08ed88e 0x64e4d08e 0xfa7502a8 </span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
  text-indent:18.0pt'><span style='font-size:9.0pt'>&lt;unknow&gt;: --
  0x00007d72 –</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>……</span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-family:楷体'>请完成实验，看看输出是否与上述显示大致一致，并解释最后一行各个数值的含义。</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>提示：可阅读</span><span
style='font-size:10.5pt'>3.3.1</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>小节“函数堆栈”，了解编译器如何建立函数调用关系的。在完成</span><span style='font-size:
10.5pt'>lab1</span><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>编译后，查看</span><span
style='font-size:10.5pt'>lab1/obj/bootblock.asm</span><span lang=ZH-CN
style='font-size:10.5pt;font-family:楷体'>，了解</span><span style='font-size:10.5pt'>bootloader</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>源码与机器码的语句和地址等的对应关系；查看</span><span
style='font-size:10.5pt'>lab1/obj/kernel.asm</span><span lang=ZH-CN
style='font-size:10.5pt;font-family:楷体'>，了解</span><span style='font-size:10.5pt'>ucore
OS</span><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>源码与机器码的语句和地址等的对应关系。</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-family:楷体'>要求完成函数</span><span>kern/debug/kdebug.c::print_stackframe</span><span
lang=ZH-CN style='font-family:楷体'>的实现，提交改进后源代码包（可以编译执行），并在实验报告中简要说明实现过程，并写出对上述问题的回答。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>补充材料：</span></p>

<p class=MsoBodyText style='margin-left:14.05pt;text-align:justify;text-justify:
inter-ideograph'><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>由于显示完整的栈结构需要解析内核文件中的调试符号，较为复杂和繁琐。代码中有一些辅助函数可以使用。例如可以通过调用</span><span
style='font-size:10.5pt'>print_debuginfo</span><span lang=ZH-CN
style='font-size:10.5pt;font-family:楷体'>函数完成查找对应函数名并打印至屏幕的功能。具体可以参见</span><span
style='font-size:10.5pt'>kdebug.c</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>代码中的注释。</span></p>

<h3 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>练习</span><span
style='font-size:12.0pt;font-family:"Times New Roman";color:red'>6</span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>：完善中断初始化和处理</span><span
lang=AR-SA style='font-size:12.0pt;font-family:"Times New Roman";color:red'> </span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>（需要编程）</span></h3>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-family:楷体'>请完成编码工作和回答如下问题：</span></p>

<p class=MsoNormal style='margin-top:5.0pt;margin-right:0cm;margin-bottom:5.95pt;
margin-left:54.0pt;text-align:justify;text-justify:inter-ideograph;text-indent:
-18.0pt'><span>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>中断向量表中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</span></p>

<p class=MsoNormal style='margin-top:5.0pt;margin-right:0cm;margin-bottom:5.95pt;
margin-left:54.0pt;text-align:justify;text-justify:inter-ideograph;text-indent:
-18.0pt'><span>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>请编程完善</span><span>kern/trap/trap.c</span><span
lang=ZH-CN style='font-family:楷体'>中对中断向量表进行初始化的函数</span><span>idt_init</span><span
lang=ZH-CN style='font-family:楷体'>。在</span><span>idt_init</span><span
lang=ZH-CN style='font-family:楷体'>函数中，依次对所有中断入口进行初始化。使用</span><span>mmu.h</span><span
lang=ZH-CN style='font-family:楷体'>中的</span><span>SETGATE</span><span
lang=ZH-CN style='font-family:楷体'>宏，填充</span><span>idt</span><span lang=ZH-CN
style='font-family:楷体'>数组内容。注意除了系统调用中断</span><span>(T_SYSCALL)</span><span
lang=ZH-CN style='font-family:楷体'>以外，其它中断均使用中断门描述符，权限为内核态权限；而系统调用中断使用异常，权限为陷阱门描述符。每个中断的入口由</span><span>tools/vectors.c</span><span
lang=ZH-CN style='font-family:楷体'>生成，使用</span><span>trap.c</span><span
lang=ZH-CN style='font-family:楷体'>中声明的</span><span>vectors</span><span
lang=ZH-CN style='font-family:楷体'>数组即可。</span></p>

<p class=MsoNormal style='margin-top:5.0pt;margin-right:0cm;margin-bottom:5.95pt;
margin-left:54.0pt;text-align:justify;text-justify:inter-ideograph;text-indent:
-18.0pt'><span>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>请编程完善</span><span>trap.c</span><span
lang=ZH-CN style='font-family:楷体'>中的中断处理函数</span><span>trap</span><span
lang=ZH-CN style='font-family:楷体'>，在对时钟中断进行处理的部分填写</span><span>trap</span><span
lang=ZH-CN style='font-family:楷体'>函数中处理时钟中断的部分，使操作系统每遇到</span><span>100</span><span
lang=ZH-CN style='font-family:楷体'>次时钟中断后，调用</span><span>print_ticks</span><span
lang=ZH-CN style='font-family:楷体'>子程序，向屏幕上打印一行文字</span><span>”100 ticks”</span><span
lang=ZH-CN style='font-family:楷体'>。</span></p>

<p class=MsoNormal style='margin-top:5.0pt;margin-right:0cm;margin-bottom:5.95pt;
margin-left:0cm;text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>要求完成问题</span><span>2</span><span
lang=ZH-CN style='font-family:楷体'>和问题</span><span>3 </span><span lang=ZH-CN
style='font-family:楷体'>提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程，并写出对问题</span><span>1</span><span
lang=ZH-CN style='font-family:楷体'>的回答。完成这问题</span><span>2</span><span
lang=ZH-CN style='font-family:楷体'>和</span><span>3</span><span lang=ZH-CN
style='font-family:楷体'>要求的部分代码后，运行整个系统，可以看到大约每</span><span>1</span><span
lang=ZH-CN style='font-family:楷体'>秒会输出一次</span><span>”100 ticks”</span><span
lang=ZH-CN style='font-family:楷体'>，而按下的键也会在屏幕上显示。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>提示：可阅读</span><span
style='font-size:10.5pt'>3.3.2</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>小节“中断与异常”。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<h3 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>扩展练习</span><span
style='font-size:12.0pt;font-family:"Times New Roman";color:red'> Challenge</span><span
lang=AR-SA style='font-size:12.0pt;font-family:楷体;color:red'>（需要编程）</span></h3>

<p class=MsoBodyText style='margin-left:14.2pt;text-indent:0cm'><span
style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>扩展</span><span>proj4,</span><span
lang=ZH-CN style='font-family:楷体'>增加</span><span>syscall</span><span
lang=ZH-CN style='font-family:楷体'>功能，即增加一用户态函数（可执行一特定系统调用：获得时钟计数值），当内核初始完毕后，可从内核态返回到用户态的函数，而用户态的函数又通过系统调用得到内核态的服务（通过网络查询所需信息，可找老师咨询。如果完成，且有兴趣做代替考试的实验，可找老师商量）。需写出详细的设计和分析报告。完成出色的可获得适当加分。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<div style='border:solid #AEBDCC 1.0pt;padding:5.0pt 5.0pt 5.0pt 5.0pt;
background:white'>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><b><span
lang=ZH-CN style='font-family:楷体'>提示：</span></b></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
lang=ZH-CN style='font-family:楷体;color:black'>规范一下</span><span
style='color:black'> challenge </span><span lang=ZH-CN style='font-family:楷体;
color:black'>的流程。</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
style='color:black'>&nbsp;</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
style='color:black'>kern_init </span><span lang=ZH-CN style='font-family:楷体;
color:black'>调用</span><span style='color:black'> switch_test</span><span
lang=ZH-CN style='font-family:楷体;color:black'>，该函数如下：</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
style='color:black'>&nbsp;</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
style='color:black'>static void</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
style='color:black'>switch_test(void) {</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
style='color:black'>    print_cur_status();          // print </span><span
lang=ZH-CN style='font-family:楷体;color:black'>当前</span><span style='color:black'>
cs/ss/ds </span><span lang=ZH-CN style='font-family:楷体;color:black'>等寄存器状态</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
style='color:black'>    cprintf(&quot;+++ switch to  user  mode +++\n&quot;);</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
style='color:black'>    switch_to_user();            // switch to user mode</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
style='color:black'>    print_cur_status();</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
style='color:black'>    cprintf(&quot;+++ switch to kernel mode +++\n&quot;);</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
style='color:black'>    switch_to_kernel();         // switch to kernel mode</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
style='color:black'>    print_cur_status();</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
style='color:black'>}</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
style='color:black'>&nbsp;</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
background:white;border:none;padding:0cm'><span style='color:black'>switch_to_*
</span><span lang=ZH-CN style='font-family:楷体;color:black'>函数建议通过</span><span
lang=ZH-CN style='color:black'> </span><span lang=ZH-CN style='font-family:
楷体;color:black'>中断处理的方式实现。主要要完成的代码是在</span><span style='color:black'> trap </span><span
lang=ZH-CN style='font-family:楷体;color:black'>里面处理</span><span
style='color:black'> T_SWITCH_TO* </span><span lang=ZH-CN style='font-family:
楷体;color:black'>中断，并设置好返回的状态。</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
style='color:black'>&nbsp;</span></p>

<p class=MsoNormal style='background:white;border:none;padding:0cm'><span
lang=ZH-CN style='font-family:楷体;color:black'>在</span><span style='color:black'>
lab1 </span><span lang=ZH-CN style='font-family:楷体;color:black'>里面完成代码以后，执行</span><span
lang=ZH-CN style='color:black'> </span><span style='color:red'>make grade </span><span
lang=ZH-CN style='font-family:楷体;color:black'>应该能够评测结果是否正确。</span></p>

</div>

<p class=MsoNormal style='text-autospace:none'><b><span style='font-size:14.0pt'>2.2
</span></b><b><span lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>项目组成</span></b></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>lab1</span><span
lang=ZH-CN style='font-family:楷体'>的整体目录结构如下所示：</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=493 valign=top style='width:492.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>.</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>├──
  boot</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  ├── asm.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  ├── bootasm.S</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  └── bootmain.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>├──
  kern</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  ├── debug</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── assert.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── kdebug.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── kdebug.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── kmonitor.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── kmonitor.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── panic.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> └── stab.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  ├── driver</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── clock.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── clock.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── console.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── console.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── intr.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── intr.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── kbdreg.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── picirq.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> └── picirq.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  ├── init</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> └── init.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  ├── libs</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── readline.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> └── stdio.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  ├── mm</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── memlayout.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── mmu.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> ├── pmm.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  │</span><span>&nbsp;&nbsp;</span><span> └── pmm.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  └── trap</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>    
  ├── trap.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>    
  ├── trapentry.S</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>    
  ├── trap.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>    
  └── vectors.S</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>├──
  libs</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  ├── defs.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  ├── elf.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  ├── error.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  ├── printfmt.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  ├── stdarg.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  ├── stdio.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  ├── string.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  ├── string.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>│</span><span>&nbsp;&nbsp;</span><span>
  └── x86.h</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>├──
  Makefile</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>└──
  tools</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>   
  ├── function.mk</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>   
  ├── gdbinit</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>   
  ├── grade.sh</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>   
  ├── kernel.ld</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>   
  ├── sign.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>   
  └── vector.c</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>10
  directories, 48 files</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>
  </td>
 </tr>
</table>

<p class=MsoBodyText><span>&nbsp;</span></p>

<p class=MsoBodyText><span lang=ZH-CN style='font-family:楷体'>其中一些比较重要的文件说明如下：</span></p>

<p class=MsoBodyText><span>    bootloader</span><span lang=ZH-CN
style='font-family:楷体'>部分</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>boot/bootasm.S</span><span>
</span><span lang=ZH-CN style='font-family:楷体'>：定义并实现了</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>最先执行的函数</span><span>start</span><span
lang=ZH-CN style='font-family:楷体'>，此函数进行了一定的初始化，完成了从实模式到保护模式的转换，并调用</span><span>bootmain.c</span><span
lang=ZH-CN style='font-family:楷体'>中的</span><span>bootmain</span><span
lang=ZH-CN style='font-family:楷体'>函数。</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>boot/bootmain.c</span><span
lang=ZH-CN style='font-family:楷体'>：定义并实现了</span><span>bootmain</span><span
lang=ZH-CN style='font-family:楷体'>函数实现了通过屏幕、串口和并口显示字符串。</span><span>bootmain</span><span
lang=ZH-CN style='font-family:楷体'>函数加载</span><span>ucore</span><span
lang=ZH-CN style='font-family:楷体'>操作系统到内存，然后跳转到</span><span>ucore</span><span
lang=ZH-CN style='font-family:楷体'>的入口处执行。</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>boot/asm.h</span><span
lang=ZH-CN style='font-family:楷体'>：是</span><span>bootasm.S</span><span
lang=ZH-CN style='font-family:楷体'>汇编文件所需要的头文件，主要是一些与</span><span>X86</span><span
lang=ZH-CN style='font-family:楷体'>保护模式的段访问方式相关的宏定义。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>ucore</span><span
lang=ZH-CN style='font-family:楷体'>操作系统部分：</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>系统初始化部分：</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>kern/init/init.c</span><span
lang=ZH-CN style='font-family:楷体'>：</span><span>ucore</span><span lang=ZH-CN
style='font-family:楷体'>操作系统的初始化启动代码</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>内存管理部分：</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>kern/mm/memlayout.h</span><span
lang=ZH-CN style='font-family:楷体'>：</span><span>ucore</span><span lang=ZH-CN
style='font-family:楷体'>操作系统有关段管理（段描述符编号、段号等）的一些宏定义</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>kern/mm/mmu.h</span><span
lang=ZH-CN style='font-family:楷体'>：</span><span>ucore</span><span lang=ZH-CN
style='font-family:楷体'>操作系统有关</span><span>X86 MMU</span><span lang=ZH-CN
style='font-family:楷体'>等硬件相关的定义，包括</span><span>EFLAGS</span><span lang=ZH-CN
style='font-family:楷体'>寄存器中各位的含义，应用</span><span>/</span><span lang=ZH-CN
style='font-family:楷体'>系统段类型，中断门描述符定义，段描述符定义，任务状态段定义，</span><span>NULL</span><span
lang=ZH-CN style='font-family:楷体'>段声明的宏</span><span>SEG_NULL, </span><span
lang=ZH-CN style='font-family:楷体'>特定段声明的宏</span><span>SEG</span><span
lang=ZH-CN style='font-family:楷体'>，设置中断门描述符的宏</span><span>SETGATE</span><span
lang=ZH-CN style='font-family:楷体'>（在练习</span><span>6</span><span lang=ZH-CN
style='font-family:楷体'>中会用到）</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>kern/mm/pmm.[ch]</span><span
lang=ZH-CN style='font-family:楷体'>：设定了</span><span>ucore</span><span
lang=ZH-CN style='font-family:楷体'>操作系统在段机制中要用到的全局变量：任务状态段</span><span>ts</span><span
lang=ZH-CN style='font-family:楷体'>，全局描述符表</span><span> gdt[]</span><span
lang=ZH-CN style='font-family:楷体'>，加载全局描述符表寄存器的函数</span><span>lgdt</span><span
lang=ZH-CN style='font-family:楷体'>，临时的内核栈</span><span>stack0</span><span
lang=ZH-CN style='font-family:楷体'>；以及对全局描述符表和任务状态段的初始化函数</span><span>gdt_init</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>   
</span><span lang=ZH-CN style='font-family:楷体'>外设驱动部分</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>kern/driver/intr.[ch]</span><span
lang=ZH-CN style='font-family:楷体'>：实现了通过设置</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>的</span><span>eflags</span><span lang=ZH-CN
style='font-family:楷体'>来屏蔽和使能中断的函数；</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>kern/driver/picirq.[ch]</span><span
lang=ZH-CN style='font-family:楷体'>：实现了对中断控制器</span><span>8259A</span><span
lang=ZH-CN style='font-family:楷体'>的初始化和使能操作；</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>kern/driver/clock.[ch]</span><span
lang=ZH-CN style='font-family:楷体'>：实现了对时钟控制器</span><span>8253</span><span
lang=ZH-CN style='font-family:楷体'>的初始化操作；</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>kern/driver/console.[ch]</span><span
lang=ZH-CN style='font-family:楷体'>：实现了对串口和键盘的中断方式的处理操作；</span></p>

<p class=MsoBodyText style='margin-top:0cm;margin-right:0cm;margin-bottom:6.0pt;
margin-left:21.0pt;text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-family:楷体'>中断处理部分：</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>kern/trap/vectors.S</span><span
lang=ZH-CN style='font-family:楷体'>：包括</span><span>256</span><span lang=ZH-CN
style='font-family:楷体'>个中断服务例程的入口地址和第一步初步处理实现。注意，此文件是由</span><span>tools/vector.c</span><span
lang=ZH-CN style='font-family:楷体'>在编译</span><span>ucore</span><span lang=ZH-CN
style='font-family:楷体'>期间动态生成的；</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>kern/trap/trapentry.S</span><span
lang=ZH-CN style='font-family:楷体'>：紧接着第一步初步处理后，进一步完成第二步初步处理；并且有恢复中断上下文的处理，即中断处理完毕后的返回准备工作；</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>kern/trap/trap.[ch]</span><span
lang=ZH-CN style='font-family:楷体'>：紧接着第二步初步处理后，继续完成具体的各种中断处理操作；</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>内核调试部分：</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>kern/debug/kdebug.[ch]</span><span
lang=ZH-CN style='font-family:楷体'>：提供源码和二进制对应关系的查询功能，用于显示调用栈关系。其中补全</span><span>print_stackframe</span><span
lang=ZH-CN style='font-family:楷体'>函数是需要完成的练习。其他实现部分不必深究。</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>kern/debug/kmonitor.[ch]</span><span
lang=ZH-CN style='font-family:楷体'>：实现提供动态分析命令的</span><span>kernel monitor</span><span
lang=ZH-CN style='font-family:楷体'>，便于在</span><span>ucore</span><span
lang=ZH-CN style='font-family:楷体'>出现</span><span>bug</span><span lang=ZH-CN
style='font-family:楷体'>或问题后，能够进入</span><span>kernel monitor</span><span
lang=ZH-CN style='font-family:楷体'>中，查看当前调用关系。实现部分不必深究。</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>kern/debug/panic.c
| assert.h</span><span lang=ZH-CN style='font-family:楷体'>：提供了</span><span>panic</span><span
lang=ZH-CN style='font-family:楷体'>函数和</span><span>assert</span><span
lang=ZH-CN style='font-family:楷体'>宏，便于在发现错误后，调用</span><span>kernel monitor</span><span
lang=ZH-CN style='font-family:楷体'>。大家可在编程实验中充分利用</span><span>assert</span><span
lang=ZH-CN style='font-family:楷体'>宏和</span><span>panic</span><span lang=ZH-CN
style='font-family:楷体'>函数，提高查找错误的效率。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-family:楷体'>公共库部分</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>libs/defs.h</span><span
lang=ZH-CN style='font-family:楷体'>：包含一些无符号整型的缩写定义。</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>Libs/x86.h</span><span
lang=ZH-CN style='font-family:楷体'>：一些用</span><span>GNU C</span><span
lang=ZH-CN style='font-family:楷体'>嵌入式汇编实现的</span><span>C</span><span
lang=ZH-CN style='font-family:楷体'>函数（由于使用了</span><span>inline</span><span
lang=ZH-CN style='font-family:楷体'>关键字，所以可以理解为宏）。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-family:楷体'>工具部分</span></p>

<p class=MsoBodyText style='margin-left:54.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-18.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>Makefile</span><span
lang=ZH-CN style='font-family:楷体'>和</span><span>function.mk</span><span
lang=ZH-CN style='font-family:楷体'>：指导</span><span>make</span><span lang=ZH-CN
style='font-family:楷体'>完成整个软件项目的编译，清除等工作。</span></p>

<p class=MsoBodyText style='margin-left:57.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>sign.c</span><span
lang=ZH-CN style='font-family:楷体'>：一个</span><span>C</span><span lang=ZH-CN
style='font-family:楷体'>语言小程序，是辅助工具，用于生成一个符合规范的硬盘主引导扇区。</span></p>

<p class=MsoBodyText style='margin-left:57.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>tools/vector.c</span><span
lang=ZH-CN style='font-family:楷体'>：生成</span><span>vectors.S</span><span
lang=ZH-CN style='font-family:楷体'>，此文件包含了中断向量处理的统一实现。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><b><span
lang=ZH-CN style='font-family:楷体'>编译方法</span></b></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>首先下载</span><span>lab1.tar.bz2</span><span
lang=ZH-CN style='font-family:楷体'>，然后解压</span><span>lab1.tar.bz2</span><span
lang=ZH-CN style='font-family:楷体'>。在</span><span>lab1</span><span lang=ZH-CN
style='font-family:楷体'>目录下执行</span><span>make</span><span lang=ZH-CN
style='font-family:楷体'>，可以生成</span><span>ucore.img</span><span lang=ZH-CN
style='font-family:楷体'>（生成于</span><span>bin</span><span lang=ZH-CN
style='font-family:楷体'>目录下）。</span><span>ucore.img</span><span lang=ZH-CN
style='font-family:楷体'>是一个包含了</span><span>bootloader</span><span lang=ZH-CN
style='font-family:楷体'>或</span><span>OS</span><span lang=ZH-CN
style='font-family:楷体'>的硬盘镜像，通过执行如下命令可在硬件虚拟环境</span><span> qemu</span><span
lang=ZH-CN style='font-family:楷体'>中运行</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>或</span><span>OS</span><span lang=ZH-CN
style='font-family:楷体'>：</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:6.0pt'><span>$ make qemu</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>   
</span></p>

<h1 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
style='font-size:17.0pt;font-family:"Times New Roman"'>3  </span><span
lang=AR-SA style='font-size:17.0pt;font-family:楷体'>从机器启动到操作系统运行的过程</span></h1>

<p class=MsoNormal style='text-autospace:none'><b><span style='font-size:14.0pt'>3.1 
BIOS</span></b><b><span lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>启动过程</span></b></p>

<p class=14 style='margin-bottom:14.45pt;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>当计算机加电后，一般不直接执行操作系统，而是执行系统初始化软件完成基本</span><span
style='font-family:"Times New Roman"'>IO</span><span lang=ZH-CN
style='font-family:楷体'>初始化和引导加载功能。简单地说，系统初始化软件就是在操作系统内核运行之前运行的一段小软件。通过这段小软件，我们可以初始化硬件设备、建立系统的内存空间映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核准备好正确的环境。最终引导加载程序把操作系统内核映像加载到</span><span
style='font-family:"Times New Roman"'>RAM</span><span lang=ZH-CN
style='font-family:楷体'>中，并将系统控制权传递给它。</span><span lang=ZH-CN style='font-family:
"Times New Roman"'> </span></p>

<p class=14 style='margin-bottom:14.45pt;text-align:justify;text-justify:inter-ideograph;
text-indent:30.0pt'><span lang=ZH-CN style='font-family:楷体'>对于绝大多数计算机系统而言，操作系统和应用软件是存放在磁盘（硬盘</span><span
style='font-family:"Times New Roman"'>/</span><span lang=ZH-CN
style='font-family:楷体'>软盘）、光盘、</span><span style='font-family:"Times New Roman"'>EPROM</span><span
lang=ZH-CN style='font-family:楷体'>、</span><span style='font-family:"Times New Roman"'>ROM</span><span
lang=ZH-CN style='font-family:楷体'>、</span><span style='font-family:"Times New Roman"'>Flash</span><span
lang=ZH-CN style='font-family:楷体'>等可在掉电后继续保存数据的存储介质上。计算机启动后，</span><span
style='font-family:"Times New Roman"'>CPU</span><span lang=ZH-CN
style='font-family:楷体'>一开始会到一个特定的地址开始执行指令，这个特定的地址存放了系统初始化软件，负责完成计算机基本的</span><span
style='font-family:"Times New Roman"'>IO</span><span lang=ZH-CN
style='font-family:楷体'>初始化，这是系统加电后运行的第一段软件代码。对于</span><span style='font-family:
"Times New Roman"'>Intel 80386</span><span lang=ZH-CN style='font-family:楷体'>的体系结构而言，</span><span
style='font-family:"Times New Roman"'>PC</span><span lang=ZH-CN
style='font-family:楷体'>机中的系统初始化软件由</span><span style='font-family:"Times New Roman"'>BIOS
(Basic Input Output System</span><span lang=ZH-CN style='font-family:楷体'>，即基本输入</span><span
style='font-family:"Times New Roman"'>/</span><span lang=ZH-CN
style='font-family:楷体'>输出系统，其本质是一个固化在主板</span><span style='font-family:"Times New Roman"'>Flash/CMOS</span><span
lang=ZH-CN style='font-family:楷体'>上的软件</span><span style='font-family:"Times New Roman"'>)</span><span
lang=ZH-CN style='font-family:楷体'>和位于软盘</span><span style='font-family:"Times New Roman"'>/</span><span
lang=ZH-CN style='font-family:楷体'>硬盘引导扇区中的</span><span style='font-family:"Times New Roman"'>OS
Boot Loader</span><span lang=ZH-CN style='font-family:楷体'>（在</span><span
style='font-family:"Times New Roman"'>ucore</span><span lang=ZH-CN
style='font-family:楷体'>中的</span><span style='font-family:"Times New Roman"'>bootasm.S</span><span
lang=ZH-CN style='font-family:楷体'>和</span><span style='font-family:"Times New Roman"'>bootmain.c</span><span
lang=ZH-CN style='font-family:楷体'>）一起组成。</span><span style='font-family:"Times New Roman"'>BIOS</span><span
lang=ZH-CN style='font-family:楷体'>实际上是被固化在计算机</span><span style='font-family:
"Times New Roman"'>ROM</span><span lang=ZH-CN style='font-family:楷体'>（只读存储器）芯片上的一个特殊的软件，为上层软件提供最底层的、最直接的硬件控制与支持。更形象地说，</span><span
style='font-family:"Times New Roman"'>BIOS</span><span lang=ZH-CN
style='font-family:楷体'>就是</span><span style='font-family:"Times New Roman"'>PC</span><span
lang=ZH-CN style='font-family:楷体'>计算机硬件与上层软件程序之间的一个</span><span
style='font-family:"Times New Roman"'>&quot;</span><span lang=ZH-CN
style='font-family:楷体'>桥梁</span><span style='font-family:"Times New Roman"'>&quot;</span><span
lang=ZH-CN style='font-family:楷体'>，负责访问和控制硬件。</span><span lang=ZH-CN
style='font-family:"Times New Roman"'> </span></p>

<p class=14 style='margin-bottom:14.45pt;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>以</span><span
style='font-family:"Times New Roman"'>Intel 80386</span><span lang=ZH-CN
style='font-family:楷体'>为例，计算机加电后，</span><span style='font-family:"Times New Roman"'>CPU</span><span
lang=ZH-CN style='font-family:楷体'>从物理地址</span><span style='font-family:"Times New Roman"'>0xFFFFFFF0</span><span
lang=ZH-CN style='font-family:楷体'>（由初始化的</span><span style='font-family:"Times New Roman"'>CS</span><span
lang=ZH-CN style='font-family:楷体'>：</span><span style='font-family:"Times New Roman"'>EIP</span><span
lang=ZH-CN style='font-family:楷体'>确定，此时</span><span style='font-family:"Times New Roman"'>CS</span><span
lang=ZH-CN style='font-family:楷体'>和</span><span style='font-family:"Times New Roman"'>IP</span><span
lang=ZH-CN style='font-family:楷体'>的值分别是</span><span style='font-family:"Times New Roman"'>0xF000</span><span
lang=ZH-CN style='font-family:楷体'>和</span><span style='font-family:"Times New Roman"'>0xFFF0)</span><span
lang=ZH-CN style='font-family:楷体'>）开始执行。在</span><span style='font-family:"Times New Roman"'>0xFFFFFFF0</span><span
lang=ZH-CN style='font-family:楷体'>这里只是存放了一条跳转指令，通过跳转指令跳到</span><span
style='font-family:"Times New Roman"'>BIOS</span><span lang=ZH-CN
style='font-family:楷体'>例行程序起始点。</span><span style='font-family:"Times New Roman"'>BIOS</span><span
lang=ZH-CN style='font-family:楷体'>做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等），并且读取该设备的第一扇区</span><span
style='font-family:"Times New Roman"'>(</span><span lang=ZH-CN
style='font-family:楷体'>即主引导扇区或启动扇区</span><span style='font-family:"Times New Roman"'>)</span><span
lang=ZH-CN style='font-family:楷体'>到内存一个特定的地址</span><span style='font-family:
"Times New Roman"'>0x7c00</span><span lang=ZH-CN style='font-family:楷体'>处，然后</span><span
style='font-family:"Times New Roman"'>CPU</span><span lang=ZH-CN
style='font-family:楷体'>控制权会转移到那个地址继续执行。至此</span><span style='font-family:"Times New Roman"'>BIOS</span><span
lang=ZH-CN style='font-family:楷体'>的初始化工作做完了，进一步的工作交给了</span><span
style='font-family:"Times New Roman"'>ucore</span><span lang=ZH-CN
style='font-family:楷体'>的</span><span style='font-family:"Times New Roman"'>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>。</span><span lang=ZH-CN style='font-family:
"Times New Roman"'> </span></p>

<p class=MsoNormal style='text-autospace:none'><b><span style='font-size:14.0pt'>3.2 
bootloader</span></b><b><span lang=ZH-CN style='font-size:14.0pt;font-family:
楷体'>启动过程</span></b></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.1pt'><span>BIOS</span><span lang=ZH-CN style='font-family:楷体'>将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>。</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>完成的工作包括：</span></p>

<p class=MsoBodyText style='margin-left:63.0pt;text-indent:-21.0pt'><span
style='font-family:文泉驿正黑'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>切换到保护模式，启用分段机制</span></p>

<p class=MsoBodyText style='margin-left:63.0pt;text-indent:-21.0pt'><span
style='font-family:文泉驿正黑'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>读磁盘中</span><span>ELF</span><span
lang=ZH-CN style='font-family:楷体'>执行文件格式的</span><span>ucore</span><span
lang=ZH-CN style='font-family:楷体'>操作系统到内存</span></p>

<p class=MsoBodyText style='margin-left:63.0pt;text-indent:-21.0pt'><span
style='font-family:文泉驿正黑'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>显示字符串信息</span></p>

<p class=MsoBodyText style='margin-left:63.0pt;text-indent:-21.0pt'><span
style='font-family:文泉驿正黑'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>把控制权交给</span><span>ucore</span><span
lang=ZH-CN style='font-family:楷体'>操作系统</span></p>

<p class=MsoBodyText><span>    </span><span lang=ZH-CN style='font-family:楷体'>对应其工作的实现文件在</span><span>lab1</span><span
lang=ZH-CN style='font-family:楷体'>中的</span><span>boot</span><span lang=ZH-CN
style='font-family:楷体'>目录下的三个文件</span><span>asm.h</span><span lang=ZH-CN
style='font-family:楷体'>、</span><span>bootasm.S</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span>bootmain.c</span><span lang=ZH-CN
style='font-family:楷体'>。下面从原理上介绍完成上述工作的计算机系统硬件和软件背景知识。</span></p>

<h3 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
style='font-family:"Times New Roman"'>3.2.1 </span><span lang=AR-SA
style='font-family:楷体'>保护模式和分段机制</span></h3>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>为何要了解</span><span>Intel
80386</span><span lang=ZH-CN style='font-family:楷体'>的保护模式和分段机制？首先，我们知道</span><span>Intel
80386</span><span lang=ZH-CN style='font-family:楷体'>只有在进入保护模式后，才能充分发挥其强大的功能，提供更好的保护机制和更大的寻址空间，否则仅仅是一个快速的</span><span>8086</span><span
lang=ZH-CN style='font-family:楷体'>而已。没有一定的保护机制，任何一个应用软件都可以任意访问所有的计算机资源，这样也就无从谈起操作系统设计了。且</span><span>Intel
80386</span><span lang=ZH-CN style='font-family:楷体'>的分段机制一直存在，无法屏蔽或避免。其次，在我们的</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>设计中，涉及到了从实模式到保护模式的处理，我们的操作系统功能（比如分页机制）是建立在</span><span>Intel
80386</span><span lang=ZH-CN style='font-family:楷体'>的保护模式上来设计的。如果我们不了解保护模式和分段机制，则我们面向</span><span>Intel
80386</span><span lang=ZH-CN style='font-family:楷体'>体系结构的操作系统设计实际上是建立在一个空中楼阁之上。</span></p>

<p class=MsoBodyText><img width=485 height=74 src="lab1/image001.png"
align=left hspace=5 style='margin-left:-5px;margin-right:5px'
alt="文本框: 【注意】虽然大家学习过X86汇编，对X86硬件架构有一定了解，但对X86保护模式和X86系统编程可能了解不够。为了能够清楚了解各个实验中汇编代码的含义，我们建议大家阅读如下参考资料：&#13;l	可先回顾一下lab0-manual中的“了解处理器硬件”一节的内容。&#13;l	《Intel 80386 Reference Programmers Manual-i386》：第四、六、九、十章。在后续实验中，还可以进一步阅读第五、七、八等章节。&#13;&#13; &#13;"></p>

<p class=MsoBodyText style='text-indent:24.0pt'><span>&nbsp;</span></p>

<p class=MsoBodyText style='text-indent:24.0pt'><span>&nbsp;</span></p>

<p class=MsoBodyText style='text-indent:24.0pt'><span>&nbsp;</span></p>

<p class=MsoBodyText style='text-indent:24.0pt'><span>&nbsp;</span></p>

<p class=MsoBodyText style='text-indent:24.0pt'><span>&nbsp;</span></p>

<h5 style='margin-left:0cm;text-indent:0cm'><span style='font-family:"Times New Roman"'>(1)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
lang=AR-SA style='font-family:楷体'>实模式</span></h5>

<p class=MsoBodyText style='text-indent:24.0pt'><span lang=ZH-CN
style='font-family:楷体'>在</span><span>bootloader</span><span lang=ZH-CN
style='font-family:楷体'>接手</span><span>BIOS</span><span lang=ZH-CN
style='font-family:楷体'>的工作后，当前的</span><span>PC</span><span lang=ZH-CN
style='font-family:楷体'>系统处于实模式（</span><span>16</span><span lang=ZH-CN
style='font-family:楷体'>位模式）运行状态，在这种状态下软件可访问的物理内存空间不能超过</span><span>1MB</span><span
lang=ZH-CN style='font-family:楷体'>，且无法发挥</span><span>Intel 80386</span><span
lang=ZH-CN style='font-family:楷体'>以上级别的</span><span>32</span><span lang=ZH-CN
style='font-family:楷体'>位</span><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>的</span><span>4GB</span><span lang=ZH-CN
style='font-family:楷体'>内存管理能力。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>实模式将整个物理内存看成分段的区域，程序代码和数据位于不同区域，操作系统和用户程序并没有区别对待，而且每一个指针都是指向实际的物理地址。这样，用户程序的一个指针如果指向了操作系统区域或其他用户程序区域，并修改了内容，那么其后果就很可能是灾难性的。通过修改</span><span>A20</span><span
lang=ZH-CN style='font-family:楷体'>地址线可以完成从实模式到保护模式的转换。有关</span><span>A20</span><span
lang=ZH-CN style='font-family:楷体'>的进一步信息可参考附录“关于</span><span>A20 Gate</span><span
lang=ZH-CN style='font-family:楷体'>”。</span></p>

<h5 style='margin-left:0cm;text-indent:0cm'><span style='font-family:"Times New Roman"'>(2)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
lang=AR-SA style='font-family:楷体'>保护模式</span></h5>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>只有在保护模式下，</span><span>80386</span><span
lang=ZH-CN style='font-family:楷体'>的全部</span><span>32</span><span lang=ZH-CN
style='font-family:楷体'>根地址线有效，可寻址高达</span><span>4G</span><span lang=ZH-CN
style='font-family:楷体'>字节的线性地址空间和物理地址空间，可访问</span><span>64TB</span><span
lang=ZH-CN style='font-family:楷体'>（有</span><span>2^14</span><span lang=ZH-CN
style='font-family:楷体'>个段，每个段最大空间为</span><span>2^32</span><span lang=ZH-CN
style='font-family:楷体'>字节）的逻辑地址空间，可采用分段存储管理机制和分页存储管理机制。这不仅为存储共享和保护提供了硬件支持，而且为实现虚拟存储提供了硬件支持。通过提供</span><span>4</span><span
lang=ZH-CN style='font-family:楷体'>个特权级和完善的特权检查机制，既能实现资源共享又能保证代码数据的安全及任务的隔离。</span></p>

<h5 style='margin-left:0cm;text-indent:0cm'><span style='font-family:"Times New Roman"'>(3)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
lang=AR-SA style='font-family:楷体'>分段存储管理机制</span></h5>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>只有在保护模式下才能使用分段存储管理机制。分段机制将内存划分成以起始地址和长度限制这两个二维参数表示的内存块，这些内存块就称之为段（</span><span>Segment</span><span
lang=ZH-CN style='font-family:楷体'>）。编译器把源程序编译成执行程序时用到的代码段、数据段、堆和栈等概念在这里可以与段联系起来，二者在含义上是一致的。</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>分段机涉及</span><span>4</span><span
lang=ZH-CN style='font-family:楷体'>个关键内容：逻辑地址、段描述符（描述段的属性）、段描述符表（包含多个段描述符的</span><span>“</span><span
lang=ZH-CN style='font-family:楷体'>数组</span><span>”</span><span lang=ZH-CN
style='font-family:楷体'>）、段选择子（段寄存器，用于定位段描述符表中表项的索引）。转换逻辑地址（</span><span>Logical
Address,</span><span lang=ZH-CN style='font-family:楷体'>应用程序员看到的地址）到物理地址（</span><span>Physical
Address, </span><span lang=ZH-CN style='font-family:楷体'>实际的物理内存地址）分以下两步：</span></p>

<p class=MsoNormal style='margin-left:35.2pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>分段地址转换：</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>把逻辑地址（由段选择子</span><span>selector</span><span
lang=ZH-CN style='font-family:楷体'>和段偏移</span><span>offset</span><span
lang=ZH-CN style='font-family:楷体'>组成）中的段选择子的内容作为段描述符表的索引，找到表中对应的段描述符，然后把段描述符中保存的段基址加上段偏移值，形成线性地址（</span><span>Linear
Address</span><span lang=ZH-CN style='font-family:楷体'>）。如果不启动分页存储管理机制，则线性地址等于物理地址。</span></p>

<p class=MsoNormal style='margin-left:35.2pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>分页地址转换，这一步中把线性地址转换为物理地址。（注意：这一步是可选的，由操作系统决定是否需要。在后续试验中会涉及。</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:12.0pt'><span>&nbsp;</span><span lang=ZH-CN style='font-family:
楷体'>上述转换过程对于应用程序员来说是不可见的。<b><i>线性地址空间</i></b>由一维的线性地址构成，线性地址空间和物理地址空间对等。线性地址</span><span>32</span><span
lang=ZH-CN style='font-family:楷体'>位长，线性地址空间容量为</span><span>4G</span><span
lang=ZH-CN style='font-family:楷体'>字节。分段地址转换的基本过程如下图所示。</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:12.0pt'><span><img
width=392 height=185 id="图片 4" src="lab1/image002.png"
alt="说明: 91298425979212"></span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:12.0pt'><span
lang=ZH-CN style='font-family:楷体'>图</span><span>1 </span><span lang=ZH-CN
style='font-family:楷体'>分段地址转换基本过程</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:12.0pt'><span>&nbsp;</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:12.0pt'><span lang=ZH-CN style='font-family:楷体'>分段存储管理机制需要在启动保护模式的前提下建立。从上图可以看出，为了使得分段存储管理机制正常运行，需要建立好段描述符和段描述符表（参看</span><span>bootasm.S</span><span
lang=ZH-CN style='font-family:楷体'>，</span><span>mmu.h</span><span lang=ZH-CN
style='font-family:楷体'>，</span><span>pmm.c</span><span lang=ZH-CN
style='font-family:楷体'>）。</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph'><b><span
lang=ZH-CN style='font-family:楷体'>段描述符</span></b></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:12.0pt'><span lang=ZH-CN style='font-family:楷体'>在分段存储管理机制的保护模式下，每个段由如下三个参数进行定义：段基地址</span><span>(Base
Address)</span><span lang=ZH-CN style='font-family:楷体'>、段界限</span><span>(Limit)</span><span
lang=ZH-CN style='font-family:楷体'>和段属性</span><span>(Attributes)</span><span
lang=ZH-CN style='font-family:楷体'>。在</span><span>ucore</span><span lang=ZH-CN
style='font-family:楷体'>中的</span><span>kern/mm/mmu.h</span><span lang=ZH-CN
style='font-family:楷体'>中的</span><span>struct segdesc </span><span lang=ZH-CN
style='font-family:楷体'>数据结构中有具体的定义。</span><span lang=ZH-CN> </span></p>

<p class=MsoNormal style='margin-left:45.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>段基地址：规定线性地址空间中段的起始地址。在</span><span>80386</span><span
lang=ZH-CN style='font-family:楷体'>保护模式下，段基地址长</span><span>32</span><span
lang=ZH-CN style='font-family:楷体'>位。因为基地址长度与寻址地址的长度相同，所以任何一个段都可以从</span><span>32</span><span
lang=ZH-CN style='font-family:楷体'>位线性地址空间中的任何一个字节开始，而不象实方式下规定的边界必须被</span><span>16</span><span
lang=ZH-CN style='font-family:楷体'>整除。</span><span lang=ZH-CN> </span></p>

<p class=MsoNormal style='margin-left:45.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>段界限：规定段的大小。在</span><span>80386</span><span lang=ZH-CN
style='font-family:楷体'>保护模式下，段界限用</span><span>20</span><span lang=ZH-CN
style='font-family:楷体'>位表示，而且段界限可以是以字节为单位或以</span><span>4K</span><span
lang=ZH-CN style='font-family:楷体'>字节为单位。</span><span lang=ZH-CN> </span></p>

<p class=MsoNormal style='margin-left:45.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>段属性：确定段的各种性质。</span></p>

<p class=MsoNormal style='margin-left:66.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:Wingdings'>u<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>段属性中的粒度位（</span><span>Granularity</span><span
lang=ZH-CN style='font-family:楷体'>），用符号</span><span>G</span><span lang=ZH-CN
style='font-family:楷体'>标记。</span><span>G=0</span><span lang=ZH-CN
style='font-family:楷体'>表示段界限以字节位位单位，</span><span>20</span><span lang=ZH-CN
style='font-family:楷体'>位的界限可表示的范围是</span><span>1</span><span lang=ZH-CN
style='font-family:楷体'>字节至</span><span>1M</span><span lang=ZH-CN
style='font-family:楷体'>字节，增量为</span><span>1</span><span lang=ZH-CN
style='font-family:楷体'>字节；</span><span>G=1</span><span lang=ZH-CN
style='font-family:楷体'>表示段界限以</span><span>4K</span><span lang=ZH-CN
style='font-family:楷体'>字节为单位，于是</span><span>20</span><span lang=ZH-CN
style='font-family:楷体'>位的界限可表示的范围是</span><span>4K</span><span lang=ZH-CN
style='font-family:楷体'>字节至</span><span>4G</span><span lang=ZH-CN
style='font-family:楷体'>字节，增量为</span><span>4K</span><span lang=ZH-CN
style='font-family:楷体'>字节。</span></p>

<p class=MsoNormal style='margin-left:66.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:Wingdings'>u<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>      </span><span
lang=ZH-CN style='font-family:楷体'>类型（</span><span>TYPE</span><span lang=ZH-CN
style='font-family:楷体'>）：用于区别不同类型的描述符。可表示所描述的段是代码段还是数据段，所描述的段是否可读</span><span>/</span><span
lang=ZH-CN style='font-family:楷体'>写</span><span>/</span><span lang=ZH-CN
style='font-family:楷体'>执行，段的扩展方向等。</span></p>

<p class=MsoNormal style='margin-left:66.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:Wingdings'>u<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>描述符特权级（</span><span>Descriptor Privilege Level</span><span
lang=ZH-CN style='font-family:楷体'>）（</span><span>DPL</span><span lang=ZH-CN
style='font-family:楷体'>）：用来实现保护机制。</span></p>

<p class=MsoNormal style='margin-left:66.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:Wingdings'>u<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>段存在位（</span><span>Segment-Present bit</span><span
lang=ZH-CN style='font-family:楷体'>）：如果这一位为</span><span>0</span><span
lang=ZH-CN style='font-family:楷体'>，则此描述符为非法的，不能被用来实现地址转换。如果一个非法描述符被加载进一个段寄存器，处理器会立即产生异常。图</span><span>5-4</span><span
lang=ZH-CN style='font-family:楷体'>显示了当存在位为</span><span>0</span><span
lang=ZH-CN style='font-family:楷体'>时，描述符的格式。操作系统可以任意的使用被标识为可用（</span><span>AVAILABLE</span><span
lang=ZH-CN style='font-family:楷体'>）的位。</span></p>

<p class=MsoNormal style='margin-left:66.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:Wingdings'>u<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>已访问位（</span><span>Accessed bit</span><span lang=ZH-CN
style='font-family:楷体'>）：当处理器访问该段（当一个指向该段描述符的选择子被加载进一个段寄存器）时，将自动设置访问位。操作系统可清除该位。</span></p>

<p class=MsoNormal style='margin-left:84.0pt;text-align:justify;text-justify:
inter-ideograph'><span>&nbsp;</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph'><span>  
</span><span lang=ZH-CN style='font-family:楷体'>上述参数通过段描述符来表示，段描述符的结构如下图所示：</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:12.0pt'><span><img
width=452 height=298 id="图片 7" src="lab1/image003.png"
alt="说明: 101298425979212"></span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:12.0pt'><span
lang=ZH-CN style='font-family:楷体'>图</span><span>2 </span><span lang=ZH-CN
style='font-family:楷体'>段描述符结构</span></p>

<p class=MsoNormal style='text-indent:12.0pt'><span>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=ZH-CN style='font-family:楷体'>全局描述符表</span></b></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:12.0pt'><span lang=ZH-CN style='font-family:楷体'>全局描述符表的是一个保存多个段描述符的</span><span>“</span><span
lang=ZH-CN style='font-family:楷体'>数组</span><span>”</span><span lang=ZH-CN
style='font-family:楷体'>，其起始地址保存在全局描述符表寄存器</span><span>GDTR</span><span
lang=ZH-CN style='font-family:楷体'>中。</span><span>GDTR</span><span lang=ZH-CN
style='font-family:楷体'>长</span><span>48</span><span lang=ZH-CN
style='font-family:楷体'>位，其中高</span><span>32</span><span lang=ZH-CN
style='font-family:楷体'>位为基地址，低</span><span>16</span><span lang=ZH-CN
style='font-family:楷体'>位为段界限。由于</span><span>GDT </span><span lang=ZH-CN
style='font-family:楷体'>不能有</span><span>GDT</span><span lang=ZH-CN
style='font-family:楷体'>本身之内的描述符进行描述定义，所以处理器采用</span><span>GDTR</span><span
lang=ZH-CN style='font-family:楷体'>为</span><span>GDT</span><span lang=ZH-CN
style='font-family:楷体'>这一特殊的系统段。注意，全部描述符表中第一个段描述符设定为空段描述符。</span><span>GDTR</span><span
lang=ZH-CN style='font-family:楷体'>中的段界限以字节为单位。对于含有</span><span>N</span><span
lang=ZH-CN style='font-family:楷体'>个描述符的描述符表的段界限通常可设为</span><span>8*N-1</span><span
lang=ZH-CN style='font-family:楷体'>。在</span><span>ucore</span><span lang=ZH-CN
style='font-family:楷体'>中的</span><span>boot/bootasm.S</span><span lang=ZH-CN
style='font-family:楷体'>中的</span><span>gdt</span><span lang=ZH-CN
style='font-family:楷体'>地址处和</span><span>kern/mm/pmm.c</span><span lang=ZH-CN
style='font-family:楷体'>中的全局变量数组</span><span>gdt[]</span><span lang=ZH-CN
style='font-family:楷体'>分别有基于汇编语言和</span><span>C</span><span lang=ZH-CN
style='font-family:楷体'>语言的全局描述符表的具体实现。</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
layout-grid-mode:char'><span style='font-size:10.5pt'>&nbsp;</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
layout-grid-mode:char'><b><span lang=ZH-CN style='font-family:楷体'>选择子</span></b></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
layout-grid-mode:char'><b><span lang=ZH-CN style='font-family:楷体'>线性地址</span></b><span
lang=ZH-CN style='font-family:楷体'>部分的<b>选择子</b>是用来选择哪个描述符表和在该表中索引一个描述符的。选择子可以做为指针变量的一部分，从而对应用程序员是可见的，但是一般是由连接加载器来设置的。选择子的格式如下图所示：</span></p>

<p class=MsoNormal align=center style='text-align:center;layout-grid-mode:char'><span
style='font-size:10.5pt'><img width=456 height=113 id="图片 10"
src="lab1/image004.png" alt="说明: 111298425979212"></span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:12.0pt'><span
lang=ZH-CN style='font-family:楷体'>图</span><span>3 </span><span lang=ZH-CN
style='font-family:楷体'>段选择子结构</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:12.0pt'><span>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:21.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt;layout-grid-mode:char'><span
style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><b><span lang=ZH-CN style='font-family:楷体'>索引（</span></b><b><span>Index</span></b><b><span
lang=ZH-CN style='font-family:楷体'>）</span></b><span lang=ZH-CN
style='font-family:楷体'>：在描述符表中从</span><span>8192</span><span lang=ZH-CN
style='font-family:楷体'>个描述符中选择一个描述符。处理器自动将这个索引值乘以</span><span>8</span><span
lang=ZH-CN style='font-family:楷体'>（描述符的长度），再加上描述符表的基址来索引描述符表，从而选出一个合适的描述符。</span></p>

<p class=MsoNormal style='margin-left:21.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt;layout-grid-mode:char'><span
style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><b><span lang=ZH-CN style='font-family:楷体'>表指示位（</span></b><b><span>Table
Indicator</span></b><b><span lang=ZH-CN style='font-family:楷体'>，</span></b><b><span>TI</span></b><b><span
lang=ZH-CN style='font-family:楷体'>）</span></b><span lang=ZH-CN
style='font-family:楷体'>：选择应该访问哪一个描述符表。</span><span>0</span><span lang=ZH-CN
style='font-family:楷体'>代表应该访问全局描述符表（</span><span>GDT</span><span lang=ZH-CN
style='font-family:楷体'>），</span><span>1</span><span lang=ZH-CN
style='font-family:楷体'>代表应该访问局部描述符表（</span><span>LDT</span><span lang=ZH-CN
style='font-family:楷体'>）。</span></p>

<p class=MsoNormal style='margin-left:21.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt;layout-grid-mode:char'><span
style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><b><span lang=ZH-CN style='font-family:楷体'>请求特权级（</span></b><b><span>Requested
Privilege Level</span></b><b><span lang=ZH-CN style='font-family:楷体'>，</span></b><b><span>RPL</span></b><b><span
lang=ZH-CN style='font-family:楷体'>）</span></b><span lang=ZH-CN
style='font-family:楷体'>：保护机制，在后续试验中会进一步讲解。</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
layout-grid-mode:char'><span>&nbsp;</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
layout-grid-mode:char'><span>       </span><span lang=ZH-CN style='font-family:
楷体'>全局描述符表的第一项是不能被</span><span>CPU</span><span lang=ZH-CN style='font-family:
楷体'>使用，所以当一个段选择子的索引（</span><span>Index</span><span lang=ZH-CN style='font-family:
楷体'>）部分和表指示位（</span><span>Table Indicator</span><span lang=ZH-CN
style='font-family:楷体'>）都为</span><span>0</span><span lang=ZH-CN
style='font-family:楷体'>的时（即段选择子指向全局描述符表的第一项时），可以当做一个空的选择子（见</span><span>mmu.h</span><span
lang=ZH-CN style='font-family:楷体'>中的</span><span>SEG_NULL</span><span
lang=ZH-CN style='font-family:楷体'>）。当一个段寄存器被加载一个空选择子时，处理器并不会产生一个异常。但是，当用一个空选择子去访问内存时，则会产生异常。</span></p>

<h5 style='margin-left:0cm;text-indent:0cm'><span style='font-family:"Times New Roman"'>(4)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
lang=AR-SA style='font-family:楷体'>保护模式下的特权级</span></h5>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>在保护模式下，特权级总共有</span><span>4</span><span
lang=ZH-CN style='font-family:楷体'>个，编号从</span><span>0</span><span lang=ZH-CN
style='font-family:楷体'>（最高特权）到</span><span>3</span><span lang=ZH-CN
style='font-family:楷体'>（最低特权）。有</span><span>3</span><span lang=ZH-CN
style='font-family:楷体'>种主要的资源受到保护：内存，</span><span>I/O</span><span lang=ZH-CN
style='font-family:楷体'>端口以及执行特殊机器指令的能力。在任一时刻，</span><span>x86 CPU</span><span
lang=ZH-CN style='font-family:楷体'>都是在一个特定的特权级下运行的，从而决定了代码可以做什么，不可以做什么。这些特权级经常被称为为保护环（</span><span>protection
ring</span><span lang=ZH-CN style='font-family:楷体'>），最内的环（</span><span>ring 0</span><span
lang=ZH-CN style='font-family:楷体'>）对应于最高特权</span><span>0</span><span
lang=ZH-CN style='font-family:楷体'>，最外面的环（</span><span>ring 3</span><span
lang=ZH-CN style='font-family:楷体'>）一般给应用程序使用，对应最低特权</span><span>3</span><span
lang=ZH-CN style='font-family:楷体'>。在</span><span>ucore</span><span lang=ZH-CN
style='font-family:楷体'>中，</span><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>只用到其中的</span><span>2</span><span lang=ZH-CN
style='font-family:楷体'>个特权级：</span><span>0</span><span lang=ZH-CN
style='font-family:楷体'>（内核态）和</span><span>3</span><span lang=ZH-CN
style='font-family:楷体'>（用户态）。</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>有大约</span><span>15</span><span
lang=ZH-CN style='font-family:楷体'>条机器指令被</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>限制只能在内核态执行，这些机器指令如果被用户模式的程序所使用，就会颠覆保护模式的保护机制并引起混乱，所以它们被保留给操作系统内核使用。如果企图在</span><span>ring
0</span><span lang=ZH-CN style='font-family:楷体'>以外运行这些指令，就会导致一个一般保护异常（</span><span>general-protection
exception</span><span lang=ZH-CN style='font-family:楷体'>）。对内存和</span><span>I/O</span><span
lang=ZH-CN style='font-family:楷体'>端口的访问也受类似的特权级限制。</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>数据段选择子的整个内容可由程序直接加载到各个段寄存器（如</span><span>SS</span><span
lang=ZH-CN style='font-family:楷体'>或</span><span>DS</span><span lang=ZH-CN
style='font-family:楷体'>等）当中。这些内容里包含了请求特权级（</span><span>Requested Privilege
Level</span><span lang=ZH-CN style='font-family:楷体'>，简称</span><span>RPL</span><span
lang=ZH-CN style='font-family:楷体'>）字段。然而，代码段寄存器（</span><span>CS</span><span
lang=ZH-CN style='font-family:楷体'>）的内容不能由装载指令（如</span><span>MOV</span><span
lang=ZH-CN style='font-family:楷体'>）直接设置，而只能被那些会改变程序执行顺序的指令（如</span><span>JMP</span><span
lang=ZH-CN style='font-family:楷体'>、</span><span>INT</span><span lang=ZH-CN
style='font-family:楷体'>、</span><span>CALL</span><span lang=ZH-CN
style='font-family:楷体'>）间接地设置。而且</span><span>CS</span><span lang=ZH-CN
style='font-family:楷体'>拥有一个由</span><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>维护的<b>当前特权级</b>字段（</span><span>Current Privilege Level</span><span
lang=ZH-CN style='font-family:楷体'>，简称</span><span>CPL</span><span lang=ZH-CN
style='font-family:楷体'>）。二者结构如下图所示：</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>&nbsp;</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:24.0pt'><span><img
width=277 height=134 id="图片 13" src="lab1/image005.png"
alt="说明: 71298425979212"></span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:24.0pt'><span
lang=ZH-CN style='font-family:楷体'>图</span><span>4 DS</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span>CS</span><span lang=ZH-CN
style='font-family:楷体'>的结构图</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>代码段寄存器中的</span><span>CPL</span><span
lang=ZH-CN style='font-family:楷体'>字段（</span><span>2</span><span lang=ZH-CN
style='font-family:楷体'>位）的值<b>总是等于</b></span><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>的当前特权级，所以只要看一眼</span><span>CS</span><span lang=ZH-CN
style='font-family:楷体'>中的</span><span>CPL</span><span lang=ZH-CN
style='font-family:楷体'>，你就可以知道此刻的特权级了。</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>会在两个关键点上保护内存：当一个段选择符被加载时，以及，当通过线性地址访问一个内存页时。因此，保护也反映在</span><a
href="http://blog.csdn.net/drshenlei/archive/2009/06/11/4261909.aspx"><span
lang=ZH-CN style='font-family:楷体'>内存地址转换</span></a><span lang=ZH-CN
style='font-family:楷体'>的过程之中，既包括分段又包括分页。当一个数据段选择符被加载时，就会发生下述的检测过程：</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:24.0pt'><span><img
border=0 width=456 height=230 id="图片 16" src="lab1/image006.png"
alt="说明: 81298425979212"></span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:24.0pt'><span
lang=ZH-CN style='font-family:楷体'>图</span><span>5 </span><span lang=ZH-CN
style='font-family:楷体'>内存访问特权级检查过程</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>&nbsp;</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>因为越高的数值代表越低的特权，上图中的</span><span>MAX()</span><span
lang=ZH-CN style='font-family:楷体'>用于选择</span><span>CPL</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span>RPL</span><span lang=ZH-CN
style='font-family:楷体'>中特权最低的一个，并与描述符特权级（</span><span>Descriptor Privilege
Level</span><span lang=ZH-CN style='font-family:楷体'>，简称</span><span>DPL</span><span
lang=ZH-CN style='font-family:楷体'>）比较。如果</span><span>DPL</span><span
lang=ZH-CN style='font-family:楷体'>的值大于等于它，那么这个访问可正常进行了。</span><span>RPL</span><span
lang=ZH-CN style='font-family:楷体'>背后的设计思想是：允许内核代码加载特权较低的段。比如，你可以使用</span><span>RPL=3</span><span
lang=ZH-CN style='font-family:楷体'>的段描述符来确保给定的操作所使用的段可以在用户模式中访问。但堆栈段寄存器是个例外，它要求</span><span>CPL</span><span
lang=ZH-CN style='font-family:楷体'>，</span><span>RPL</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span>DPL</span><span lang=ZH-CN
style='font-family:楷体'>这</span><span>3</span><span lang=ZH-CN style='font-family:
楷体'>个值必须完全一致，才可以被加载。下面再总结一下</span><span>CPL</span><span lang=ZH-CN
style='font-family:楷体'>、</span><span>RPL</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span>DPL</span><span lang=ZH-CN
style='font-family:楷体'>：</span></p>

<p class=MsoNormal style='margin-left:45.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-size:9.0pt;font-family:
Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>CPL</span><span
lang=ZH-CN style='font-family:楷体'>：当前特权级（</span><span>Current Privilege Level) </span><span
lang=ZH-CN style='font-family:楷体'>保存在</span><span>CS</span><span lang=ZH-CN
style='font-family:楷体'>段寄存器（选择子）的最低两位，</span><span>CPL</span><span lang=ZH-CN
style='font-family:楷体'>就是当前活动代码段的特权级，并且它定义了当前所执行程序的特权级别）</span></p>

<p class=MsoNormal style='margin-left:45.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-size:9.0pt;font-family:
Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>DPL</span><span
lang=ZH-CN style='font-family:楷体'>：描述符特权（</span><span>Descriptor Privilege
Level</span><span lang=ZH-CN style='font-family:楷体'>）</span><span lang=ZH-CN> </span><span
lang=ZH-CN style='font-family:楷体'>存储在段描述符中的权限位，用于描述对应段所属的特权等级，也就是段本身真正的特权级。</span></p>

<p class=MsoNormal style='margin-left:45.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-size:9.0pt;font-family:
Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>RPL</span><span
lang=ZH-CN style='font-family:楷体'>：请求特权级</span><span>RPL(Request Privilege
Level) RPL</span><span lang=ZH-CN style='font-family:楷体'>保存在选择子的最低两位。</span><span>RPL</span><span
lang=ZH-CN style='font-family:楷体'>说明的是进程对段访问的请求权限，意思是当前进程想要的请求权限。</span><span>RPL</span><span
lang=ZH-CN style='font-family:楷体'>的值由程序员自己来自由的设置，并不一定</span><span>RPL&gt;=CPL</span><span
lang=ZH-CN style='font-family:楷体'>，但是当</span><span>RPL&lt;CPL</span><span
lang=ZH-CN style='font-family:楷体'>时，实际起作用的就是</span><span>CPL</span><span
lang=ZH-CN style='font-family:楷体'>了，因为访问时的特权检查是判断：</span><b><span
style='color:#002060'>max(RPL,CPL)&lt;=DPL</span></b><span lang=ZH-CN
style='font-family:楷体'>是否成立，所以</span><span>RPL</span><span lang=ZH-CN
style='font-family:楷体'>可以看成是每次访问时的附加限制，</span><span>RPL=0</span><span
lang=ZH-CN style='font-family:楷体'>时附加限制最小，</span><span>RPL=3</span><span
lang=ZH-CN style='font-family:楷体'>时附加限制最大。</span></p>

<h3 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
style='font-family:"Times New Roman"'>3.2.2</span><span lang=AR-SA
style='font-family:楷体'>地址空间</span></h3>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>分段机制涉及</span><span>4</span><span
lang=ZH-CN style='font-family:楷体'>个关键内容：逻辑地址（</span><span>Logical Address,</span><span
lang=ZH-CN style='font-family:楷体'>应用程序员看到的地址，在操作系统原理上称为虚拟地址，以后提到虚拟地址就是指逻辑地址）、物理地址（</span><span>Physical
Address, </span><span lang=ZH-CN style='font-family:楷体'>实际的物理内存地址）、段描述符表（包含多个段描述符的</span><span>“</span><span
lang=ZH-CN style='font-family:楷体'>数组</span><span>”</span><span lang=ZH-CN
style='font-family:楷体'>）、段描述符（描述段的属性，及段描述符表这个</span><span>“</span><span
lang=ZH-CN style='font-family:楷体'>数组</span><span>”</span><span lang=ZH-CN
style='font-family:楷体'>中的</span><span>“</span><span lang=ZH-CN
style='font-family:楷体'>数组元素</span><span>”</span><span lang=ZH-CN
style='font-family:楷体'>）、段选择子（即段寄存器中的值，用于定位段描述符表中段描述符表项的索引）</span></p>

<h5 style='margin-left:0cm;text-indent:0cm'><span style='font-family:"Times New Roman"'>(1)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
lang=AR-SA style='font-family:楷体'>逻辑地址空间</span></h5>

<p class=MsoBodyText style='text-indent:23.25pt'><span lang=ZH-CN
style='font-family:楷体'>从应用程序的角度看，逻辑地址空间就是应用程序员编程所用到的地址空间，比如下面的程序片段：</span></p>

<p class=MsoBodyText style='text-indent:23.25pt'><span>int val=100;</span></p>

<p class=MsoBodyText style='text-indent:23.25pt'><span>int * point=&amp;val;</span></p>

<p class=MsoBodyText style='text-indent:23.25pt'><span lang=ZH-CN
style='font-family:楷体'>其中指针变量</span><span>point</span><span lang=ZH-CN
style='font-family:楷体'>中存储的即是一个逻辑地址。在基于</span><span>80386</span><span
lang=ZH-CN style='font-family:楷体'>的计算机系统中，逻辑地址有一个</span><span>16</span><span
lang=ZH-CN style='font-family:楷体'>位的段寄存器（也称段选择子，段选择子）和一个</span><span>32</span><span
lang=ZH-CN style='font-family:楷体'>位的偏移量构成。</span></p>

<h5 style='margin-left:0cm;text-indent:0cm'><span style='font-family:"Times New Roman"'>(2)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
lang=AR-SA style='font-family:楷体'>物理地址空间</span></h5>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>从操作系统的角度看，</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>、内存硬件（通常说的</span><span>“</span><span
lang=ZH-CN style='font-family:楷体'>内存条</span><span>”</span><span lang=ZH-CN
style='font-family:楷体'>）和各种外设是它主要管理的硬件资源而内存硬件和外设分布在物理地址空间中。物理地址空间就是一个</span><span>“</span><span
lang=ZH-CN style='font-family:楷体'>大数组</span><span>”</span><span lang=ZH-CN
style='font-family:楷体'>，</span><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>通过索引（物理地址）来访问这个</span><span>“</span><span lang=ZH-CN
style='font-family:楷体'>大数组</span><span>”</span><span lang=ZH-CN
style='font-family:楷体'>中的内容。物理地址是指</span><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>提交到内存总线上用于访问计算机内存和外设的最终地址。</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>物理地址空间的大小取决于</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>实现的物理地址位数，在基于</span><span>80386</span><span
lang=ZH-CN style='font-family:楷体'>的计算机系统中，</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>的物理地址空间为</span><span>4GB</span><span
lang=ZH-CN style='font-family:楷体'>，如果计算机系统实际上有</span><span>1GB</span><span
lang=ZH-CN style='font-family:楷体'>物理内存（即我们通常说的内存条），而其他硬件设备的</span><span>IO</span><span
lang=ZH-CN style='font-family:楷体'>寄存器映射到起始物理地址为</span><span>3GB</span><span
lang=ZH-CN style='font-family:楷体'>的</span><span>256MB</span><span lang=ZH-CN
style='font-family:楷体'>大小的地址空间，则该计算机系统的物理地址空间如下所示：</span></p>

<div align=center>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:5.4pt;border-collapse:collapse'>
 <tr style='height:336.9pt'>
  <td width=248 valign=top style='width:247.95pt;border:solid black 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt;height:336.9pt'>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph;layout-grid-mode:char'><span style='font-size:9.0pt'>+------------------+ 
  &lt;- 0xFFFFFFFF (4GB)</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|     </span><span lang=ZH-CN
  style='font-size:9.0pt;font-family:楷体'>无效空间</span><span style='font-size:
  9.0pt'>     |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|                  |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>+------------------+  &lt;-
  addr:3G+256M</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|     256MB        |</span></p>
  <p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
  text-indent:9.0pt'><span style='font-size:9.0pt'>| IO</span><span lang=ZH-CN
  style='font-size:9.0pt;font-family:楷体'>外设地址空间</span><span style='font-size:
  9.0pt'>   |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|                  |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>+------------------+  &lt;-
  0xC0000000(3GB)</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|                  |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>/\/\/\/\/\/\/\/\/\/\</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>&nbsp;</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>/\/\/\/\/\/\/\/\/\/\</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|     </span><span lang=ZH-CN
  style='font-size:9.0pt;font-family:楷体'>无效空间</span><span style='font-size:
  9.0pt'>     |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>+------------------+  &lt;-
  0x40000000(1GB)</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|                  |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|  </span><span lang=ZH-CN
  style='font-size:9.0pt;font-family:楷体'>实际有效内存</span><span style='font-size:
  9.0pt'>    |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|                  |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>+------------------+  &lt;-
  0x00100000 (1MB)</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|     BIOS ROM     |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>+------------------+  &lt;-
  0x000F0000 (960KB)</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|  16-bit devices, |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|  expansion ROMs  |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>+------------------+  &lt;-
  0x000C0000 (768KB)</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|   VGA Display    |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>+------------------+  &lt;-
  0x000A0000 (640KB)</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|                  |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|    Low Memory    |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>|                  |</span></p>
  <p class=MsoNormal style='margin-left:9.15pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:9.0pt'>+------------------+  &lt;-
  0x00000000</span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal align=center style='text-align:center'><span lang=ZH-CN
style='font-family:楷体'>图</span><span>6 X86</span><span lang=ZH-CN
style='font-family:楷体'>计算机系统的物理地址空间</span></p>

<h5 style='margin-left:0cm;text-indent:0cm'><span style='font-family:"Times New Roman"'>(3)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
lang=AR-SA style='font-family:楷体'>线性地址空间</span></h5>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>一台计算机只有一个物理地址空间，但在操作系统的管理下，每个程序都认为自己独占整个计算机的物理地址空间。为了让多个程序能够有效地相互隔离和使用物理地址空间，引入线性地址空间（也称虚拟地址空间）的概念。线性地址空间的大小取决于</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>实现的线性地址位数，在基于</span><span>80386</span><span
lang=ZH-CN style='font-family:楷体'>的计算机系统中，</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>的线性地址空间为</span><span>4GB</span><span
lang=ZH-CN style='font-family:楷体'>。线性地址空间会被映射到某一部分或整个物理地址空间，并通过索引（线性地址）来访问其中的内容。线性地址又称虚拟地址，是进行逻辑地址转换后形成的地址索引，用于寻址线性地址空间。但</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>未启动分页机制时，线性地址等于物理地址；当</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>启动分页机制时，线性地址还需经过分页地址转换形成物理地址后，</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>才能访问内存硬件和外设。三种地址的关系如下所示：</span></p>

<p class=MsoBodyText style='margin-left:21.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-size:10.5pt;font-family:
文泉驿正黑'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>启动分段机制，未启动分页机制：逻辑地址</span></b><b><span
style='font-size:10.5pt'>--&gt; (</span></b><b><span lang=ZH-CN
style='font-size:10.5pt;font-family:楷体'>分段地址转换</span></b><b><span
style='font-size:10.5pt'>) --&gt;</span></b><b><span lang=ZH-CN
style='font-size:10.5pt;font-family:楷体'>线性地址</span></b><b><span
style='font-size:10.5pt'>==</span></b><b><span lang=ZH-CN style='font-size:
10.5pt;font-family:楷体'>物理地址</span></b></p>

<p class=MsoBodyText style='margin-left:21.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-size:10.5pt;font-family:
文泉驿正黑'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><b><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>启动分段和分页机制：逻辑地址</span></b><b><span
style='font-size:10.5pt'>--&gt; (</span></b><b><span lang=ZH-CN
style='font-size:10.5pt;font-family:楷体'>分段地址转换</span></b><b><span
style='font-size:10.5pt'>) --&gt;</span></b><b><span lang=ZH-CN
style='font-size:10.5pt;font-family:楷体'>线性地址</span></b><b><span
style='font-size:10.5pt'>--&gt;</span></b><b><span lang=ZH-CN style='font-size:
10.5pt;font-family:楷体'>分页地址转换</span></b><b><span style='font-size:10.5pt'>)
--&gt;</span></b><b><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>物理地址</span></b></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>在操作系统的管理下，采用灵活的内存管理机制，在只有一个物理地址空间的情况下，可以存在多个线性地址空间。一个典型的线性地址空间</span></p>

<h3 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
style='font-family:"Times New Roman"'>3.2.3 </span><span lang=AR-SA
style='font-family:楷体'>硬盘访问概述</span></h3>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph'><span>   
bootloader</span><span lang=ZH-CN style='font-family:楷体'>让</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>进入保护模式后，下一步的工作就是从硬盘上加载并运行</span><span>OS</span><span
lang=ZH-CN style='font-family:楷体'>。考虑到实现的简单性，</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>的访问硬盘都是</span><span>LBA</span><span
lang=ZH-CN style='font-family:楷体'>模式的</span><span>PIO</span><span lang=ZH-CN
style='font-family:楷体'>（</span><span>Program IO</span><span lang=ZH-CN
style='font-family:楷体'>）方式，即所有的</span><span>IO</span><span lang=ZH-CN
style='font-family:楷体'>操作是通过</span><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>访问硬盘的</span><span>IO</span><span lang=ZH-CN
style='font-family:楷体'>地址寄存器完成。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>一般主板有</span><span>2</span><span
lang=ZH-CN style='font-family:楷体'>个</span><span>IDE</span><span lang=ZH-CN
style='font-family:楷体'>通道，每个通道可以接</span><span>2</span><span lang=ZH-CN
style='font-family:楷体'>个</span><span>IDE</span><span lang=ZH-CN
style='font-family:楷体'>硬盘。访问第一个硬盘的扇区可设置</span><span>IO</span><span lang=ZH-CN
style='font-family:楷体'>地址寄存器</span><span>0x1f0-0x1f7</span><span lang=ZH-CN
style='font-family:楷体'>实现的，具体参数见下表。一般第一个</span><span>IDE</span><span
lang=ZH-CN style='font-family:楷体'>通道通过访问</span><span>IO</span><span lang=ZH-CN
style='font-family:楷体'>地址</span><span>0x1f0-0x1f7</span><span lang=ZH-CN
style='font-family:楷体'>来实现，第二个</span><span>IDE</span><span lang=ZH-CN
style='font-family:楷体'>通道通过访问</span><span>0x170-0x17f</span><span lang=ZH-CN
style='font-family:楷体'>实现。每个通道的主从盘的选择通过第</span><span>6</span><span lang=ZH-CN
style='font-family:楷体'>个</span><span>IO</span><span lang=ZH-CN
style='font-family:楷体'>偏移地址寄存器来设置。</span></p>

<p class=MsoBodyText align=center style='text-align:center;text-indent:24.0pt'><span
lang=ZH-CN style='font-family:楷体'>表一</span><span lang=ZH-CN> </span><span
lang=ZH-CN style='font-family:楷体'>磁盘</span><span>IO</span><span lang=ZH-CN
style='font-family:楷体'>地址和对应功能</span></p>

<div align=center>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:5.85pt;border-collapse:collapse'>
 <tr>
  <td width=50 valign=top style='width:49.6pt;border:solid black 1.0pt;
  border-right:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center;layout-grid-mode:
  char'><b><span style='font-size:10.5pt'>IO</span></b><b><span lang=ZH-CN
  style='font-size:10.5pt;font-family:楷体'>地址</span></b></p>
  </td>
  <td width=414 valign=top style='width:413.6pt;border:solid black 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center;layout-grid-mode:
  char'><b><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>功能</span></b></p>
  </td>
 </tr>
 <tr>
  <td width=50 valign=top style='width:49.6pt;border-top:none;border-left:solid black 1.0pt;
  border-bottom:solid black 1.0pt;border-right:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center;layout-grid-mode:
  char'><span style='font-size:10.5pt'>0x1f0</span></p>
  </td>
  <td width=414 valign=top style='width:413.6pt;border:solid black 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='layout-grid-mode:char'><span lang=ZH-CN
  style='font-size:10.5pt;font-family:楷体'>读数据，当</span><span style='font-size:
  10.5pt'>0x1f7</span><span lang=ZH-CN style='font-size:10.5pt;font-family:
  楷体'>不为忙状态时，可以读。</span></p>
  </td>
 </tr>
 <tr>
  <td width=50 valign=top style='width:49.6pt;border-top:none;border-left:solid black 1.0pt;
  border-bottom:solid black 1.0pt;border-right:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center;layout-grid-mode:
  char'><span style='font-size:10.5pt'>0x1f2</span></p>
  </td>
  <td width=414 valign=top style='width:413.6pt;border:solid black 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='layout-grid-mode:char'><span lang=ZH-CN
  style='font-size:10.5pt;font-family:楷体'>要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是</span><span
  style='font-size:10.5pt'>1</span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>个扇区</span></p>
  </td>
 </tr>
 <tr>
  <td width=50 valign=top style='width:49.6pt;border-top:none;border-left:solid black 1.0pt;
  border-bottom:solid black 1.0pt;border-right:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center;layout-grid-mode:
  char'><span style='font-size:10.5pt'>0x1f3</span></p>
  </td>
  <td width=414 valign=top style='width:413.6pt;border:solid black 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='layout-grid-mode:char'><span lang=ZH-CN
  style='font-size:10.5pt;font-family:楷体'>如果是</span><span style='font-size:
  10.5pt'>LBA</span><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>模式，就是</span><span
  style='font-size:10.5pt'>LBA</span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>参数的</span><span style='font-size:10.5pt'>0-7</span><span
  lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>位</span></p>
  </td>
 </tr>
 <tr>
  <td width=50 valign=top style='width:49.6pt;border-top:none;border-left:solid black 1.0pt;
  border-bottom:solid black 1.0pt;border-right:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center;layout-grid-mode:
  char'><span style='font-size:10.5pt'>0x1f4</span></p>
  </td>
  <td width=414 valign=top style='width:413.6pt;border:solid black 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='layout-grid-mode:char'><span lang=ZH-CN
  style='font-size:10.5pt;font-family:楷体'>如果是</span><span style='font-size:
  10.5pt'>LBA</span><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>模式，就是</span><span
  style='font-size:10.5pt'>LBA</span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>参数的</span><span style='font-size:10.5pt'>8-15</span><span
  lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>位</span></p>
  </td>
 </tr>
 <tr>
  <td width=50 valign=top style='width:49.6pt;border-top:none;border-left:solid black 1.0pt;
  border-bottom:solid black 1.0pt;border-right:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center;layout-grid-mode:
  char'><span style='font-size:10.5pt'>0x1f5</span></p>
  </td>
  <td width=414 valign=top style='width:413.6pt;border:solid black 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='layout-grid-mode:char'><span lang=ZH-CN
  style='font-size:10.5pt;font-family:楷体'>如果是</span><span style='font-size:
  10.5pt'>LBA</span><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>模式，就是</span><span
  style='font-size:10.5pt'>LBA</span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>参数的</span><span style='font-size:10.5pt'>16-23</span><span
  lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>位</span></p>
  </td>
 </tr>
 <tr>
  <td width=50 valign=top style='width:49.6pt;border-top:none;border-left:solid black 1.0pt;
  border-bottom:solid black 1.0pt;border-right:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center;layout-grid-mode:
  char'><span style='font-size:10.5pt'>0x1f6</span></p>
  </td>
  <td width=414 valign=top style='width:413.6pt;border:solid black 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='layout-grid-mode:char'><span lang=ZH-CN
  style='font-size:10.5pt;font-family:楷体'>第</span><span style='font-size:10.5pt'>0~3</span><span
  lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>位：如果是</span><span
  style='font-size:10.5pt'>LBA</span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>模式就是</span><span style='font-size:10.5pt'>24-27</span><span
  lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>位</span><span
  style='font-size:10.5pt'>     </span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>第</span><span style='font-size:10.5pt'>4</span><span
  lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>位：为</span><span
  style='font-size:10.5pt'>0</span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>主盘；为</span><span style='font-size:10.5pt'>1</span><span
  lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>从盘</span></p>
  <p class=MsoNormal><span lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>第</span><span
  style='font-size:10.5pt'>6</span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>位：为</span><span style='font-size:10.5pt'>1=LBA</span><span
  lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>模式；</span><span
  style='font-size:10.5pt'>0 = CHS</span><span lang=ZH-CN style='font-size:
  10.5pt;font-family:楷体'>模式</span><span style='font-size:10.5pt'>        </span><span
  lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>第</span><span
  style='font-size:10.5pt'>7</span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>位和第</span><span style='font-size:10.5pt'>5</span><span
  lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>位必须为</span><span
  style='font-size:10.5pt'>1</span></p>
  </td>
 </tr>
 <tr>
  <td width=50 valign=top style='width:49.6pt;border-top:none;border-left:solid black 1.0pt;
  border-bottom:solid black 1.0pt;border-right:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center;layout-grid-mode:
  char'><span style='font-size:10.5pt'>0x1f7</span></p>
  </td>
  <td width=414 valign=top style='width:413.6pt;border:solid black 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='layout-grid-mode:char'><span lang=ZH-CN
  style='font-size:10.5pt;font-family:楷体'>状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从</span><span
  style='font-size:10.5pt'>0x1f0</span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>端口读数据</span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoBodyText style='text-indent:24.0pt'><span lang=ZH-CN
style='font-family:楷体'>当前</span><span lang=ZH-CN> </span><span lang=ZH-CN
style='font-family:楷体'>硬盘数据是储存到硬盘扇区中，一个扇区大小为</span><span>512</span><span
lang=ZH-CN style='font-family:楷体'>字节。读一个扇区的流程（可参看</span><span>boot/bootmain.c</span><span
lang=ZH-CN style='font-family:楷体'>中的</span><span>readsect</span><span
lang=ZH-CN style='font-family:楷体'>函数实现）大致如下：</span></p>

<p class=MsoBodyText style='margin-left:45.0pt;text-indent:-21.0pt'><span>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体'>等待磁盘准备好</span></p>

<p class=MsoBodyText style='margin-left:45.0pt;text-indent:-21.0pt'><span>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体'>发出读取扇区的命令</span></p>

<p class=MsoBodyText style='margin-left:45.0pt;text-indent:-21.0pt'><span>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体'>等待磁盘准备好</span></p>

<p class=MsoBodyText style='margin-left:45.0pt;text-indent:-21.0pt'><span>4.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体'>把磁盘扇区数据读到指定内存</span></p>

<h3 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
style='font-family:"Times New Roman"'>3.2.4 ELF</span><span lang=AR-SA
style='font-family:楷体'>文件格式概述</span></h3>

<p class=14 style='text-align:justify;text-justify:inter-ideograph;text-indent:
24.0pt'><span style='font-family:"Times New Roman"'>ELF(Executable and linking
format)</span><span lang=ZH-CN style='font-family:楷体'>文件格式是</span><span
style='font-family:"Times New Roman"'>Linux</span><span lang=ZH-CN
style='font-family:楷体'>系统下的一种常用目标文件</span><span style='font-family:"Times New Roman"'>(object
file)</span><span lang=ZH-CN style='font-family:楷体'>格式，有三种主要类型</span><span
style='font-family:"Times New Roman"'>: </span></p>

<p class=14 style='margin-left:45.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>用于执行的可执行文件</span><span style='font-family:"Times New Roman"'>(executable
file)</span><span lang=ZH-CN style='font-family:楷体'>，用于提供程序的进程映像，加载的内存执行。</span><span
lang=ZH-CN style='font-family:"Times New Roman"'> </span><span lang=ZH-CN
style='font-family:楷体'>这也是本实验的</span><span style='font-family:"Times New Roman"'>OS</span><span
lang=ZH-CN style='font-family:楷体'>文件类型。</span></p>

<p class=14 style='margin-left:45.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>用于连接的可重定位文件</span><span style='font-family:"Times New Roman"'>(relocatable
file)</span><span lang=ZH-CN style='font-family:楷体'>，可与其它目标文件一起创建可执行文件和共享目标文件。</span><span
lang=ZH-CN style='font-family:"Times New Roman"'> </span></p>

<p class=14 style='margin-left:45.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>共享目标文件</span><span style='font-family:"Times New Roman"'>(shared
object file),</span><span lang=ZH-CN style='font-family:楷体'>连接器可将它与其它可重定位文件和共享目标文件连接成其它的目标文件，动态连接器又可将它与可执行文件和其它共享目标文件结合起来创建一个进程映像。</span><span
lang=ZH-CN style='font-family:"Times New Roman"'> </span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>                                                                                                           </span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>这里只分析与本实验相关的</span><span>ELF</span><span
lang=ZH-CN style='font-family:楷体'>可执行文件类型。</span><span>ELF header</span><span
lang=ZH-CN style='font-family:楷体'>在文件开始处描述了整个文件的组织。</span><span>ELF</span><span
lang=ZH-CN style='font-family:楷体'>的文件头包含整个执行文件的控制结构，其定义在</span><span>elf.h</span><span
lang=ZH-CN style='font-family:楷体'>中：</span></p>

<p class=MsoBodyText><span>&nbsp;</span></p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:87.9pt;border-collapse:collapse'>
 <tr style='height:216.95pt'>
  <td width=275 valign=top style='width:274.85pt;border:solid black 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt;height:216.95pt'>
  <p class=MsoBodyText style='margin-left:22.3pt;layout-grid-mode:char'><span
  style='font-size:10.5pt'>struct elfhdr {</span></p>
  <p class=MsoBodyText style='margin-left:32.8pt;text-indent:-10.5pt'><span
  style='font-size:10.5pt'>  uint magic;  // must equal ELF_MAGIC</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  uchar elf[12];</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  ushort type;</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  ushort machine;</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  uint version;</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  uint entry;  // </span><span lang=ZH-CN style='font-size:10.5pt;font-family:
  楷体'>程序入口的虚拟地址</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  uint phoff;  // program header </span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>表的位置偏移</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  uint shoff;</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  uint flags;</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  ushort ehsize;</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  ushort phentsize;</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  ushort phnum; //program header</span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>表中的入口数目</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  ushort shentsize;</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  ushort shnum;</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  ushort shstrndx;</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'>};</span></p>
  </td>
 </tr>
</table>

<p class=MsoBodyText><span>&nbsp;</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>program header</span><span lang=ZH-CN
style='font-family:楷体'>描述与程序执行直接相关的目标文件结构信息，用来在文件中定位各个段的映像，同时包含其他一些用来为程序创建进程映像所必需的信息。可执行文件的程序头部是一个</span><span>program
header</span><span lang=ZH-CN style='font-family:楷体'>结构的数组，</span><span
lang=ZH-CN> </span><span lang=ZH-CN style='font-family:楷体'>每个结构描述了一个段或者系统准备程序执行所必需的其它信息。目标文件的</span><span>
“</span><span lang=ZH-CN style='font-family:楷体'>段</span><span>” </span><span
lang=ZH-CN style='font-family:楷体'>包含一个或者多个</span><span> “</span><span
lang=ZH-CN style='font-family:楷体'>节区</span><span>”</span><span lang=ZH-CN
style='font-family:楷体'>（</span><span>section</span><span lang=ZH-CN
style='font-family:楷体'>）</span><span lang=ZH-CN> </span><span lang=ZH-CN
style='font-family:楷体'>，也就是</span><span>“</span><span lang=ZH-CN
style='font-family:楷体'>段内容（</span><span>Segment Contents</span><span
lang=ZH-CN style='font-family:楷体'>）</span><span>” </span><span lang=ZH-CN
style='font-family:楷体'>。程序头部仅对于可执行文件和共享目标文件有意义。可执行目标文件在</span><span>ELF</span><span
lang=ZH-CN style='font-family:楷体'>头部的</span><span>e_phentsize</span><span
lang=ZH-CN style='font-family:楷体'>和</span><span>e_phnum</span><span lang=ZH-CN
style='font-family:楷体'>成员中给出其自身程序头部的大小。程序头部的数据结构如下表所示：</span></p>

<p class=MsoBodyText><span>&nbsp;</span></p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:76.75pt;border-collapse:collapse'>
 <tr style='height:128.0pt'>
  <td width=321 valign=top style='width:321.4pt;border:solid black 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt;height:128.0pt'>
  <p class=MsoBodyText style='margin-left:22.3pt;layout-grid-mode:char'><span
  style='font-size:10.5pt'>struct proghdr {</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  uint type;   // </span><span lang=ZH-CN style='font-size:10.5pt;font-family:
  楷体'>段类型</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  uint offset;  // </span><span lang=ZH-CN style='font-size:10.5pt;font-family:
  楷体'>段相对文件头的偏移值</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  uint va;     //</span><span> </span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>段的第一个字节将被放到内存中的虚拟地址</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  uint pa;   </span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  uint filesz; </span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  uint memsz;  // </span><span lang=ZH-CN style='font-size:10.5pt;font-family:
  楷体'>段在内存映像中占用的字节数</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  uint flags;</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'> 
  uint align;</span></p>
  <p class=MsoBodyText style='margin-left:22.3pt'><span style='font-size:10.5pt'>};</span></p>
  </td>
 </tr>
</table>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>   
</span><span lang=ZH-CN style='font-family:楷体'>根据</span><span>elfhdr</span><span
lang=ZH-CN style='font-family:楷体'>和</span><span>proghdr</span><span lang=ZH-CN
style='font-family:楷体'>的结构描述，</span><span>bootloader</span><span lang=ZH-CN
style='font-family:楷体'>就可以完成对</span><span>ELF</span><span lang=ZH-CN
style='font-family:楷体'>格式的</span><span>ucore</span><span lang=ZH-CN
style='font-family:楷体'>操作系统的加载过程（参见</span><span>boot/bootmain.c</span><span
lang=ZH-CN style='font-family:楷体'>中的</span><span>bootmain</span><span
lang=ZH-CN style='font-family:楷体'>函数）。</span></p>

<p class=MsoBodyText><b><span>&nbsp;</span></b></p>

<p class=MsoBodyText><b><span>[</span></b><b><span lang=ZH-CN style='font-family:
楷体'>补充材料</span></b><b><span>]</span></b></p>

<p class=MsoBodyText><b><span style='font-size:10.5pt'>Link addr&amp; Load addr</span></b></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span style='font-size:10.5pt'>Link</span><span
style='font-size:10.5pt'>&nbsp;</span><span style='font-size:10.5pt'>Address</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>是指编译器指定代码和数据所需要放置的内存地址，由链接器配置。</span><span
style='font-size:10.5pt'>Load</span><span style='font-size:10.5pt'>&nbsp;</span><span
style='font-size:10.5pt'>Address</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>是指程序被实际加载到内存的位置（由程序加载器</span><span style='font-size:10.5pt'>ld</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>配置）。一般由可执行文件结构信息和加载器可保证这两个地址相同。</span><span
style='font-size:10.5pt'>Link Addr</span><span lang=ZH-CN style='font-size:
10.5pt;font-family:楷体'>和</span><span style='font-size:10.5pt'>LoadAddr</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>不同会导致：</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-size:10.5pt;font-family:
Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>直接跳转位置错误</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-size:10.5pt;font-family:
Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>直接内存访问</span><span
style='font-size:10.5pt'>(</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>只读数据区或</span><span style='font-size:10.5pt'>bss</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>等直接地址访问</span><span
style='font-size:10.5pt'>)</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>错误</span></p>

<p class=MsoBodyText style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-size:10.5pt;font-family:
Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>堆和栈等的使用不受影响，但是可能会覆盖程序、数据区域</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>注意：也存在</span><span
style='font-size:10.5pt'>Link</span><span lang=ZH-CN style='font-size:10.5pt;
font-family:楷体'>地址和</span><span style='font-size:10.5pt'>Load</span><span
lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>地址不一样的情况（例如：动态链接库）。</span></p>

<p class=MsoBodyText><span>&nbsp;</span></p>

<p class=MsoNormal style='text-autospace:none'><b><span style='font-size:14.0pt'>3.3 
</span></b><b><span lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>操作系统启动过程</span></b></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.1pt'><span lang=ZH-CN style='font-family:楷体'>当</span><span>bootloader</span><span
lang=ZH-CN style='font-family:楷体'>通过读取硬盘扇区把</span><span>ucore</span><span
lang=ZH-CN style='font-family:楷体'>在系统加载到内存后，就转跳到</span><span>ucore</span><span
lang=ZH-CN style='font-family:楷体'>操作系统在内存中的入口位置（</span><span>kern/init.c</span><span
lang=ZH-CN style='font-family:楷体'>中的</span><span>kern_init</span><span
lang=ZH-CN style='font-family:楷体'>函数的起始地址），这样</span><span>ucore</span><span
lang=ZH-CN style='font-family:楷体'>就接管了整个控制权。当前的</span><span>ucore</span><span
lang=ZH-CN style='font-family:楷体'>功能很简单，只完成基本的内存管理和外设中断管理。</span><span>ucore</span><span
lang=ZH-CN style='font-family:楷体'>主要完成的工作包括：</span></p>

<p class=MsoBodyText style='margin-left:63.0pt;text-indent:-21.0pt'><span
style='font-family:文泉驿正黑'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>初始化终端；</span><span>   </span></p>

<p class=MsoBodyText style='margin-left:63.0pt;text-indent:-21.0pt'><span
style='font-family:文泉驿正黑'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>显示字符串；</span></p>

<p class=MsoBodyText style='margin-left:63.0pt;text-indent:-21.0pt'><span
style='font-family:文泉驿正黑'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>显示堆栈中的多层函数调用关系；</span></p>

<p class=MsoBodyText style='margin-left:63.0pt;text-indent:-21.0pt'><span
style='font-family:文泉驿正黑'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>切换到保护模式，启用分段机制；</span></p>

<p class=MsoBodyText style='margin-left:63.0pt;text-indent:-21.0pt'><span
style='font-family:文泉驿正黑'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>初始化中断控制器，设置中断描述符表，初始化时钟中断，使能整个系统的中断机制；</span></p>

<p class=MsoBodyText style='margin-left:63.0pt;text-indent:-21.0pt'><span
style='font-family:文泉驿正黑'>●<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>执行</span><span>while</span><span
lang=ZH-CN style='font-family:楷体'>（</span><span>1</span><span lang=ZH-CN
style='font-family:楷体'>）死循环。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>   
</span><span lang=ZH-CN style='font-family:楷体'>以后的实验中会大量涉及各个函数直接的调用关系，以及由于中断处理导致的异步现象，可能对大家实现操作系统和改正其中的错误有很大影响。而理解好函数调用关系的建立机制和中断处理机制，对后续实验会有很大帮助。下面就练习</span><span>5</span><span
lang=ZH-CN style='font-family:楷体'>涉及的函数栈调用关系和练习</span><span>6</span><span
lang=ZH-CN style='font-family:楷体'>中的中断机制的建立进行阐述。</span></p>

<h3 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
style='font-family:"Times New Roman"'>3.3.1 </span><span lang=AR-SA
style='font-family:楷体'>函数堆栈</span></h3>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>栈是一个很重要的编程概念（编译课和程序设计课都讲过相关内容），与编译器和编程语言有紧密的联系。理解调用栈最重要的两点是：栈的结构，</span><span>EBP</span><span
lang=ZH-CN style='font-family:楷体'>寄存器的作用。一个函数调用动作可分解为：零到多个</span><span>PUSH</span><span
lang=ZH-CN style='font-family:楷体'>指令（用于参数入栈），一个</span><span>CALL</span><span
lang=ZH-CN style='font-family:楷体'>指令。</span><span>CALL</span><span lang=ZH-CN
style='font-family:楷体'>指令内部其实还暗含了一个将返回地址（即</span><span>CALL</span><span
lang=ZH-CN style='font-family:楷体'>指令下一条指令的地址）压栈的动作（由硬件完成）。几乎所有本地编译器都会在每个函数体之前插入类似如下的汇编指令：</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:36.0pt'><span>pushl   %ebp </span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:36.0pt'><span>movl   %esp , %ebp </span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>这样在程序执行到一个函数的实际指令前，已经有以下数据顺序入栈：参数、返回地址、</span><span>ebp</span><span
lang=ZH-CN style='font-family:楷体'>寄存器。由此得到类似如下的栈结构（参数入栈顺序跟调用方式有关，这里以</span><span>C</span><span
lang=ZH-CN style='font-family:楷体'>语言默认的</span><span>CDECL</span><span
lang=ZH-CN style='font-family:楷体'>为例）：</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<div align=center>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:112.85pt;border-collapse:collapse'>
 <tr style='height:124.9pt'>
  <td width=180 valign=top style='width:180.0pt;border:solid black 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt;height:124.9pt'>
  <p class=MsoBodyText style='margin-left:3.7pt;text-align:justify;text-justify:
  inter-ideograph;layout-grid-mode:char'><span style='font-size:10.5pt'>+| (</span><span
  lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>栈底方向</span><span
  style='font-size:10.5pt'>  | </span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>高位地址</span></p>
  <p class=MsoBodyText style='margin-left:3.7pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:10.5pt'> <span style='color:#1F497D'>|</span>
  .................... |</span></p>
  <p class=MsoBodyText style='margin-left:3.7pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:10.5pt'> | .................... |</span></p>
  <p class=MsoBodyText style='margin-left:3.7pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:10.5pt'> | </span><span lang=ZH-CN
  style='font-size:10.5pt;font-family:楷体'>参数</span><span style='font-size:10.5pt'>3   
  |</span></p>
  <p class=MsoBodyText style='margin-left:3.7pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:10.5pt'> | </span><span lang=ZH-CN
  style='font-size:10.5pt;font-family:楷体'>参数</span><span style='font-size:10.5pt'>2   
  |</span></p>
  <p class=MsoBodyText style='margin-left:3.7pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:10.5pt'> | </span><span lang=ZH-CN
  style='font-size:10.5pt;font-family:楷体'>参数</span><span style='font-size:10.5pt'>1   
  |</span></p>
  <p class=MsoBodyText style='margin-left:3.7pt;text-align:justify;text-justify:
  inter-ideograph'><span style='font-size:10.5pt'> | </span><span lang=ZH-CN
  style='font-size:10.5pt;font-family:楷体'>返回地址</span><span style='font-size:
  10.5pt'>  |</span></p>
  <p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
  text-indent:5.25pt'><span style='font-size:10.5pt'>| </span><span lang=ZH-CN
  style='font-size:10.5pt;font-family:楷体'>上一层</span><span style='font-size:
  10.5pt'>[ebp] | &lt;-------- [ebp]</span></p>
  <p class=MsoBodyText style='margin-left:3.7pt;text-align:justify;text-justify:
  inter-ideograph;text-indent:5.25pt'><span style='font-size:10.5pt'>|</span><span
  lang=ZH-CN style='font-size:10.5pt;font-family:楷体'>局部变量</span><span
  style='font-size:10.5pt'>  |  </span><span lang=ZH-CN style='font-size:10.5pt;
  font-family:楷体'>低位地址</span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoBodyText align=center style='text-align:center'><span lang=ZH-CN
style='font-family:楷体'>图</span><span>7 </span><span lang=ZH-CN
style='font-family:楷体'>函数调用栈结构</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><span>&nbsp;</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>这两条汇编指令的含义是：首先将</span><span>ebp</span><span
lang=ZH-CN style='font-family:楷体'>寄存器入栈，然后将栈顶指针</span><span>esp</span><span
lang=ZH-CN style='font-family:楷体'>赋值给</span><span>ebp</span><span lang=ZH-CN
style='font-family:楷体'>。</span><span>“mov ebp esp”</span><span lang=ZH-CN
style='font-family:楷体'>这条指令表面上看是用</span><span>esp</span><span lang=ZH-CN
style='font-family:楷体'>覆盖</span><span>ebp</span><span lang=ZH-CN
style='font-family:楷体'>原来的值，其实不然。因为给</span><span>ebp</span><span lang=ZH-CN
style='font-family:楷体'>赋值之前，原</span><span>ebp</span><span lang=ZH-CN
style='font-family:楷体'>值已经被压栈（位于栈顶），而新的</span><span>ebp</span><span lang=ZH-CN
style='font-family:楷体'>又恰恰指向栈顶。此时</span><span>ebp</span><span lang=ZH-CN
style='font-family:楷体'>寄存器就已经处于一个非常重要的地位，该寄存器中存储着栈中的一个地址（原</span><span>ebp</span><span
lang=ZH-CN style='font-family:楷体'>入栈后的栈顶），从该地址为基准，向上（栈底方向）能获取返回地址、参数值，向下（栈顶方向）能获取函数局部变量值，而该地址处又存储着上一层函数调用时的</span><span>ebp</span><span
lang=ZH-CN style='font-family:楷体'>值。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>一般而言，</span><span>ss:[ebp+4]</span><span
lang=ZH-CN style='font-family:楷体'>处为返回地址，</span><span>ss:[ebp+8]</span><span
lang=ZH-CN style='font-family:楷体'>处为第一个参数值（最后一个入栈的参数值，此处假设其占用</span><span>4</span><span
lang=ZH-CN style='font-family:楷体'>字节内存），</span><span>ss:[ebp-4]</span><span
lang=ZH-CN style='font-family:楷体'>处为第一个局部变量，</span><span>ss:[ebp]</span><span
lang=ZH-CN style='font-family:楷体'>处为上一层</span><span>ebp</span><span lang=ZH-CN
style='font-family:楷体'>值。由于</span><span>ebp</span><span lang=ZH-CN
style='font-family:楷体'>中的地址处总是</span><span>“</span><span lang=ZH-CN
style='font-family:楷体'>上一层函数调用时的</span><span>ebp</span><span lang=ZH-CN
style='font-family:楷体'>值</span><span>”</span><span lang=ZH-CN style='font-family:
楷体'>，而在每一层函数调用中，都能通过当时的</span><span>ebp</span><span lang=ZH-CN
style='font-family:楷体'>值</span><span>“</span><span lang=ZH-CN style='font-family:
楷体'>向上（栈底方向）</span><span>”</span><span lang=ZH-CN style='font-family:楷体'>能获取返回地址、参数值，</span><span>“</span><span
lang=ZH-CN style='font-family:楷体'>向下（栈顶方向）</span><span>”</span><span
lang=ZH-CN style='font-family:楷体'>能获取函数局部变量值。如此形成递归，直至到达栈底。这就是函数调用栈。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>提示：练习</span><span>5</span><span
lang=ZH-CN style='font-family:楷体'>的正确实现取决于对这一小节的正确理解和掌握。</span></p>

<h3 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
style='font-family:"Times New Roman"'>3.3.2</span><span lang=AR-SA
style='font-family:楷体'>中断与异常</span></h3>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>操作系统需要对计算机系统中的各种外设进行管理，这就需要</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>和外设能够相互通信才行。一般外设的速度远慢于</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>的速度。如果让操作系统通过</span><span>CPU“</span><span
lang=ZH-CN style='font-family:楷体'>主动关心</span><span>”</span><span lang=ZH-CN
style='font-family:楷体'>外设的事件，即采用通常的轮询</span><span>(polling)</span><span
lang=ZH-CN style='font-family:楷体'>机制，则太浪费</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>资源了。所以需要操作系统和</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>能够一起提供某种机制，让外设在需要操作系统处理外设相关事件的时候，能够</span><span>“</span><span
lang=ZH-CN style='font-family:楷体'>主动通知</span><span>”</span><span lang=ZH-CN
style='font-family:楷体'>操作系统，即打断操作系统和应用的正常执行，让操作系统完成外设的相关处理，然后在恢复操作系统和应用的正常执行。在操作系统中，这种机制称为中断机制。中断机制给操作系统提供了处理意外情况的能力，同时它也是实现进程</span><span>/</span><span
lang=ZH-CN style='font-family:楷体'>线程抢占式调度的一个重要基石。但中断的引入导致了对操作系统的理解更加困难。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>在操作系统中，有三种特殊的中断事件。由</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>外部设备引起的外部事件如</span><span>I/O</span><span
lang=ZH-CN style='font-family:楷体'>中断、时钟中断、控制台中断等是异步产生的（即产生的时刻不确定），与</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>的执行无关，我们称之为异步中断</span><span>(asynchronous
interrupt)</span><span lang=ZH-CN style='font-family:楷体'>也称外部中断</span><span>,</span><span
lang=ZH-CN style='font-family:楷体'>简称中断</span><span>(interrupt)</span><span
lang=ZH-CN style='font-family:楷体'>。而把在</span><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>执行指令期间检测到不正常的或非法的条件</span><span>(</span><span
lang=ZH-CN style='font-family:楷体'>如除零错、地址访问越界</span><span>)</span><span
lang=ZH-CN style='font-family:楷体'>所引起的内部事件称作同步中断</span><span>(synchronous
interrupt)</span><span lang=ZH-CN style='font-family:楷体'>，也称内部中断，简称异常</span><span>(exception)</span><span
lang=ZH-CN style='font-family:楷体'>。把在程序中使用请求系统服务的系统调用而引发的事件，称作陷入中断</span><span>(trap
interrupt)</span><span lang=ZH-CN style='font-family:楷体'>，也称软中断</span><span>(soft
interrupt)</span><span lang=ZH-CN style='font-family:楷体'>，系统调用</span><span>(system
call)</span><span lang=ZH-CN style='font-family:楷体'>简称</span><span>trap</span><span
lang=ZH-CN style='font-family:楷体'>。在后续试验中会进一步讲解系统调用。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>本实验只描述保护模式下的处理过程。当</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>收到中断（通过</span><span>8259A</span><span
lang=ZH-CN style='font-family:楷体'>完成，有关</span><span>8259A</span><span
lang=ZH-CN style='font-family:楷体'>的信息请看附录</span><span>A</span><span lang=ZH-CN
style='font-family:楷体'>）或者异常的事件时，它会暂停执行当前的程序或任务，通过一定的机制跳转到负责处理这个信号的相关处理例程中，在完成对这个事件的处理后再跳回到刚才被打断的程序或任务中。中断向量和中断服务例程的对应关系主要是由</span><span>IDT</span><span
lang=ZH-CN style='font-family:楷体'>（中断描述符表）负责。操作系统在</span><span>IDT</span><span
lang=ZH-CN style='font-family:楷体'>中设置好各种中断向量对应的中断描述符，留待</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>在产生中断后查询对应中断服务例程的起始地址。而</span><span>IDT</span><span
lang=ZH-CN style='font-family:楷体'>本身的起始地址保存在</span><span>idtr</span><span
lang=ZH-CN style='font-family:楷体'>寄存器中。</span></p>

<h5 style='margin-left:0cm;text-indent:0cm'><span style='font-family:"Times New Roman"'>(1)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
lang=AR-SA style='font-family:楷体'>中断描述符表（</span><span style='font-family:"Times New Roman"'>Interrupt
Descriptor Table</span><span lang=AR-SA style='font-family:楷体'>）</span></h5>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>中断描述符表把每个中断或异常编号和一个指向中断服务例程的描述符联系起来。同</span><span>GDT</span><span
lang=ZH-CN style='font-family:楷体'>一样，</span><span>IDT</span><span lang=ZH-CN
style='font-family:楷体'>是一个</span><span>8</span><span lang=ZH-CN
style='font-family:楷体'>字节的描述符数组，但</span><span>IDT</span><span lang=ZH-CN
style='font-family:楷体'>的第一项可以包含一个描述符。</span><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>把中断（异常）号乘以</span><span>8</span><span lang=ZH-CN
style='font-family:楷体'>做为</span><span>IDT</span><span lang=ZH-CN
style='font-family:楷体'>的索引。</span><span>IDT</span><span lang=ZH-CN
style='font-family:楷体'>可以位于内存的任意位置，</span><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>通过</span><span>IDT</span><span lang=ZH-CN
style='font-family:楷体'>寄存器（</span><span>IDTR</span><span lang=ZH-CN
style='font-family:楷体'>）的内容来寻址</span><span>IDT</span><span lang=ZH-CN
style='font-family:楷体'>的起始地址。指令</span><span>LIDT</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span>SIDT</span><span lang=ZH-CN
style='font-family:楷体'>用来操作</span><span>IDTR</span><span lang=ZH-CN
style='font-family:楷体'>。两条指令都有一个显示的操作数：一个</span><span>6</span><span lang=ZH-CN
style='font-family:楷体'>字节表示的内存地址。指令的含义如下：</span></p>

<p class=MsoNormal style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt;layout-grid-mode:char'><span
style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><b><span>LIDT</span></b><b><span lang=ZH-CN style='font-family:
楷体'>（</span></b><b><span>Load IDT Register</span></b><b><span lang=ZH-CN
style='font-family:楷体'>）指令：</span></b><span lang=ZH-CN style='font-family:楷体'>使用一个包含线性地址基址和界限的内存操作数来加载</span><span>IDT</span><span
lang=ZH-CN style='font-family:楷体'>。操作系统创建</span><span>IDT</span><span
lang=ZH-CN style='font-family:楷体'>时需要执行它来设定</span><span>IDT</span><span
lang=ZH-CN style='font-family:楷体'>的起始地址。这条指令只能在特权级</span><span>0</span><span
lang=ZH-CN style='font-family:楷体'>执行。（可参见</span><span>libs/x86.h</span><span
lang=ZH-CN style='font-family:楷体'>中的</span><span>lidt</span><span lang=ZH-CN
style='font-family:楷体'>函数实现，其实就是一条汇编指令）</span></p>

<p class=MsoNormal style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt;layout-grid-mode:char'><span
style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><b><span>SIDT</span></b><b><span lang=ZH-CN style='font-family:
楷体'>（</span></b><b><span>Store IDT Register</span></b><b><span lang=ZH-CN
style='font-family:楷体'>）指令：</span></b><span lang=ZH-CN style='font-family:楷体'>拷贝</span><span>IDTR</span><span
lang=ZH-CN style='font-family:楷体'>的基址和界限部分到一个内存地址。这条指令可以在任意特权级执行。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>&nbsp;</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>IDT</span><span lang=ZH-CN style='font-family:楷体'>和</span><span>IDTR</span><span
lang=ZH-CN style='font-family:楷体'>寄存器的结构和关系如下图所示：</span></p>

<p class=MsoBodyText align=center style='text-align:center;text-indent:24.0pt'><span><img
border=0 width=341 height=191 id="图片 19" src="lab1/image007.png"
alt="说明: 121298425979212"></span></p>

<p class=MsoBodyText align=center style='text-align:center;text-indent:24.0pt'><span
lang=ZH-CN style='font-family:楷体'>图</span><span>8 IDT</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span>IDTR</span><span lang=ZH-CN
style='font-family:楷体'>寄存器的结构和关系图</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:21.0pt'><span lang=ZH-CN style='font-family:楷体'>在保护模式下，最多会存在</span><span>256</span><span
lang=ZH-CN style='font-family:楷体'>个</span><span>Interrupt/Exception Vectors</span><span
lang=ZH-CN style='font-family:楷体'>。范围</span><span>[0</span><span lang=ZH-CN
style='font-family:楷体'>，</span><span>31]</span><span lang=ZH-CN
style='font-family:楷体'>内的</span><span>32</span><span lang=ZH-CN
style='font-family:楷体'>个向量被异常</span><span>Exception</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span>NMI</span><span lang=ZH-CN
style='font-family:楷体'>使用，但当前并非所有这</span><span>32</span><span lang=ZH-CN
style='font-family:楷体'>个向量都已经被使用，有几个当前没有被使用的，请不要擅自使用它们，它们被保留，以备将来可能增加新的</span><span>Exception</span><span
lang=ZH-CN style='font-family:楷体'>。范围</span><span>[32</span><span lang=ZH-CN
style='font-family:楷体'>，</span><span>255]</span><span lang=ZH-CN
style='font-family:楷体'>内的向量被保留给用户定义的</span><span>Interrupts</span><span
lang=ZH-CN style='font-family:楷体'>。</span><span>Intel</span><span lang=ZH-CN
style='font-family:楷体'>没有定义，也没有保留这些</span><span>Interrupts</span><span
lang=ZH-CN style='font-family:楷体'>。用户可以将它们用作外部</span><span>I/O</span><span
lang=ZH-CN style='font-family:楷体'>设备中断（</span><span>8259A IRQ</span><span
lang=ZH-CN style='font-family:楷体'>），或者系统调用（</span><span>System Call </span><span
lang=ZH-CN style='font-family:楷体'>、</span><span>Software Interrupts</span><span
lang=ZH-CN style='font-family:楷体'>）等。</span><span>&nbsp;</span></p>

<h5 style='margin-left:0cm;text-indent:0cm'><span style='font-family:"Times New Roman"'>(2)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-family:"Times New Roman"'>IDT gate descriptors</span></h5>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:21.0pt'><span>Interrupts/Exceptions</span><span lang=ZH-CN
style='font-family:楷体'>应该使用</span><span>Interrupt Gate</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span>Trap Gate</span><span lang=ZH-CN
style='font-family:楷体'>，它们之间的唯一区别就是：当调用</span><span>Interrupt Gate</span><span
lang=ZH-CN style='font-family:楷体'>时，</span><span>Interrupt</span><span
lang=ZH-CN style='font-family:楷体'>会被</span><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>自动禁止；而调用</span><span>Trap Gate</span><span lang=ZH-CN
style='font-family:楷体'>时，</span><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>则不会去禁止或打开中断，而是保留它原来的样子。在</span><span>IDT</span><span
lang=ZH-CN style='font-family:楷体'>中，可以包含如下</span><span>3</span><span
lang=ZH-CN style='font-family:楷体'>种类型的</span><span>Descriptor</span><span
lang=ZH-CN style='font-family:楷体'>：</span></p>

<p class=MsoNormal style='margin-top:5.0pt;margin-right:0cm;margin-bottom:5.0pt;
margin-left:36.0pt;text-indent:-18.0pt'><span style='font-size:10.0pt;
font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>Task-gate descriptor </span><span lang=ZH-CN
style='font-family:楷体'>（这里没有使用）</span></p>

<p class=MsoNormal style='margin-top:5.0pt;margin-right:0cm;margin-bottom:5.0pt;
margin-left:36.0pt;text-indent:-18.0pt'><span style='font-size:10.0pt;
font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>Interrupt-gate descriptor </span><span lang=ZH-CN
style='font-family:楷体'>（中断方式用到）</span></p>

<p class=MsoNormal style='margin-top:5.0pt;margin-right:0cm;margin-bottom:5.0pt;
margin-left:36.0pt;text-indent:-18.0pt'><span style='font-size:10.0pt;
font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>Trap-gate descriptor</span><span lang=ZH-CN
style='font-family:楷体'>（系统调用用到）</span></p>

<p class=MsoNormal style='margin-top:5.0pt;margin-right:0cm;margin-bottom:5.0pt;
margin-left:36.0pt'><span lang=ZH-CN style='font-family:楷体'>下图图显示了</span><span>80386</span><span
lang=ZH-CN style='font-family:楷体'>的任务门描述符、中断门描述符、陷阱门描述符的格式：</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:21.0pt'><span><img
border=0 width=410 height=208 id="图片 22" src="lab1/image008.png"
alt="说明: 131298425979212"></span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:21.0pt'><span
lang=ZH-CN style='font-family:楷体'>图</span><span>9 X86</span><span lang=ZH-CN
style='font-family:楷体'>的各种门的格式</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:21.0pt'><span lang=ZH-CN style='font-family:楷体'>可参见</span><span>kern/mm/mmu.h</span><span
lang=ZH-CN style='font-family:楷体'>中的</span><span>struct gatedesc</span><span
lang=ZH-CN style='font-family:楷体'>数据结构对中断描述符的具体定义。</span></p>

<h5 style='margin-left:0cm;text-indent:0cm'><span style='font-family:"Times New Roman";
color:black'>(3)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
lang=AR-SA style='font-family:楷体;color:black'>中断处理中硬件</span><span lang=AR-SA
style='font-family:楷体'>负责<span style='color:black'>完成的工作</span></span></h5>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:21.0pt'><span lang=ZH-CN style='font-family:楷体;color:black'>中断服务例程包括具体负责处理中断（异常）的代码是操作系统的重要组成部分。需要注意区别的是，有两个过程由硬件完成：</span></p>

<p class=MsoNormal style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:Wingdings;
color:black'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体;color:black'>硬件中断处理过程</span><span
style='color:black'>1</span><span lang=ZH-CN style='font-family:楷体;color:black'>（起始）：从</span><span
style='color:black'>CPU</span><span lang=ZH-CN style='font-family:楷体;
color:black'>收到中断事件后，打断当前程序或任务的执行，根据某种机制跳转到中断服务例程去执行的过程。其具体流程如下：</span></p>

<p class=MsoNormal style='margin-left:63.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='color:black'>1)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:black'>CPU</span><span lang=ZH-CN style='font-family:楷体;
color:black'>在执行完当前程序的每一条指令后，都会去确认在执行刚才的指令过程中中断控制器（如：</span><span
style='color:black'>8259A</span><span lang=ZH-CN style='font-family:楷体;
color:black'>）是否发送中断请求过来，如果有那么</span><span style='color:black'>CPU</span><span
lang=ZH-CN style='font-family:楷体;color:black'>就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量；</span></p>

<p class=MsoNormal style='margin-left:63.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='color:black'>2)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:black'>&nbsp;</span><span style='color:black'>CPU</span><span
lang=ZH-CN style='font-family:楷体;color:black'>根据得到的中断向量（以此为索引）到</span><span
style='color:black'>IDT</span><span lang=ZH-CN style='font-family:楷体;
color:black'>中找到该向量对应的中断描述符，中断描述符里保存着中断服务例程的段选择子；</span></p>

<p class=MsoNormal style='margin-left:63.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='color:black'>3)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:black'>CPU</span><span lang=ZH-CN style='font-family:楷体;
color:black'>使用</span><span style='color:black'>IDT</span><span lang=ZH-CN
style='font-family:楷体;color:black'>查到的中断服务例程的段选择子从</span><span
style='color:black'>GDT</span><span lang=ZH-CN style='font-family:楷体;
color:black'>中取得相应的段描述符，段描述符里保存了中断服务例程的段基址和属性信息，此时</span><span
style='color:black'>CPU</span><span lang=ZH-CN style='font-family:楷体;
color:black'>就得到了中断服务例程的起始地址，并跳转到该地址；</span></p>

<p class=MsoNormal style='margin-left:63.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='color:black'>4)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:black'>CPU</span><span lang=ZH-CN style='font-family:楷体;
color:black'>会根据</span><span style='color:black'>CPL</span><span lang=ZH-CN
style='font-family:楷体;color:black'>和中断服务例程的段描述符的</span><span style='color:black'>DPL</span><span
lang=ZH-CN style='font-family:楷体;color:black'>信息确认是否发生了特权级的转换。比如当前程序正运行在用户态，而中断程序是运行在内核态的，则意味着发生了特权级的转换，这时</span><span
style='color:black'>CPU</span><span lang=ZH-CN style='font-family:楷体;
color:black'>会从当前程序的</span><span style='color:black'>TSS</span><span
lang=ZH-CN style='font-family:楷体;color:black'>信息（该信息在内存中的起始地址存在</span><span
style='color:black'>TR</span><span lang=ZH-CN style='font-family:楷体;color:black'>寄存器中）里取得该程序的内核栈地址，即包括内核态的</span><span
style='color:black'>ss</span><span lang=ZH-CN style='font-family:楷体;color:black'>和</span><span
style='color:black'>esp</span><span lang=ZH-CN style='font-family:楷体;
color:black'>的值，并立即将系统当前使用的栈切换成新的内核栈。这个栈就是即将运行的中断服务程序要使用的栈。紧接着就将当前程序使用的用户态的</span><span
style='color:black'>ss</span><span lang=ZH-CN style='font-family:楷体;color:black'>和</span><span
style='color:black'>esp</span><span lang=ZH-CN style='font-family:楷体;
color:black'>压到新的内核栈中保存起来；</span></p>

<p class=MsoNormal style='margin-left:63.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='color:black'>5)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:black'>CPU</span><span lang=ZH-CN style='font-family:楷体;
color:black'>需要开始保存当前被打断的程序的现场（即一些寄存器的值），以便于将来恢复被打断的程序继续执行。这需要利用内核栈来保存相关现场信息，即依次压入当前被打断程序使用的</span><span
style='color:black'>eflags</span><span lang=ZH-CN style='font-family:楷体;
color:black'>，</span><span style='color:black'>cs</span><span lang=ZH-CN
style='font-family:楷体;color:black'>，</span><span style='color:black'>eip</span><span
lang=ZH-CN style='font-family:楷体;color:black'>，</span><span style='color:black'>errorCode</span><span
lang=ZH-CN style='font-family:楷体;color:black'>（如果是有错误码的异常）信息；</span></p>

<p class=MsoNormal style='margin-left:63.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='color:black'>6)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='color:black'>&nbsp;&nbsp;</span><span style='color:black'>CPU</span><span
lang=ZH-CN style='font-family:楷体;color:black'>利用中断服务例程的段描述符将其第一条指令的地址加载到</span><span
style='color:black'>cs</span><span lang=ZH-CN style='font-family:楷体;color:black'>和</span><span
style='color:black'>eip</span><span lang=ZH-CN style='font-family:楷体;
color:black'>寄存器中，开始执行中断服务例程。这意味着先前的程序被暂停执行，中断服务程序正式开始工作。</span></p>

<p class=MsoNormal style='margin-left:42.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='font-family:Wingdings;
color:black'>l<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体;color:black'>硬件中断处理过程</span><span
style='color:black'>2</span><span lang=ZH-CN style='font-family:楷体;color:black'>（结束）：每个中断服务例程在有中断处理工作完成后需要通过</span><span
style='color:black'>iret</span><span lang=ZH-CN style='font-family:楷体;
color:black'>（或</span><span style='color:black'>iretd</span><span lang=ZH-CN
style='font-family:楷体;color:black'>）指令恢复被打断的程序的执行。</span><span
style='color:black'>CPU</span><span lang=ZH-CN style='font-family:楷体;
color:black'>执行</span><span style='color:black'>IRET</span><span lang=ZH-CN
style='font-family:楷体;color:black'>指令的具体过程如下：</span></p>

<p class=MsoNormal style='margin-left:63.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='color:black'>1)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体;color:black'>程序执行这条</span><span
style='color:black'>iret</span><span lang=ZH-CN style='font-family:楷体;
color:black'>指令时，首先会从内核栈里弹出先前保存的被打断的程序的现场信息，即</span><span style='color:black'>eflags</span><span
lang=ZH-CN style='font-family:楷体;color:black'>，</span><span style='color:black'>cs</span><span
lang=ZH-CN style='font-family:楷体;color:black'>，</span><span style='color:black'>eip</span><span
lang=ZH-CN style='font-family:楷体;color:black'>重新开始执行；</span></p>

<p class=MsoNormal style='margin-left:63.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='color:black'>2)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体;color:black'>如果存在特权级转换（从内核态转换到用户态），则还需要从内核栈中弹出用户态栈的</span><span
style='color:black'>ss</span><span lang=ZH-CN style='font-family:楷体;color:black'>和</span><span
style='color:black'>esp</span><span lang=ZH-CN style='font-family:楷体;
color:black'>，这样也意味着栈也被切换回原先使用的用户态的栈了；</span></p>

<p class=MsoNormal style='margin-left:63.0pt;text-align:justify;text-justify:
inter-ideograph;text-indent:-21.0pt'><span style='color:black'>3)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-family:楷体;color:black'>如果此次处理的是带有错误码（</span><span
style='color:black'>errorCode</span><span lang=ZH-CN style='font-family:楷体;
color:black'>）的异常，</span><span style='color:black'>CPU</span><span lang=ZH-CN
style='font-family:楷体;color:black'>在恢复先前程序的现场时，并不会弹出</span><span
style='color:black'>errorCode</span><span lang=ZH-CN style='font-family:楷体;
color:black'>。这一步需要通过软件完成，即要求相关的中断服务例程在调用</span><span style='color:black'>iret</span><span
lang=ZH-CN style='font-family:楷体;color:black'>返回之前添加出栈代码主动弹出</span><span
style='color:black'>errorCode</span><span lang=ZH-CN style='font-family:楷体;
color:black'>。</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:21.0pt'><span style='color:black'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-family:楷体;color:black'>下图显示了从中断向量到</span><span style='color:black'>GDT</span><span
lang=ZH-CN style='font-family:楷体;color:black'>中相应中断服务程序起始位置的定位方式</span><span
style='color:black'>:</span><span> </span></p>

<p class=MsoNormal align=center style='text-align:center'><span><img border=0
width=325 height=286 id="图片 25" src="lab1/image009.png"
alt="说明: 141298425979212"></span></p>

<p class=MsoNormal align=center style='text-align:center'><span lang=ZH-CN
style='font-family:楷体'>图</span><span>10 </span><span lang=ZH-CN
style='font-family:楷体'>中断向量与中断服务例程起始地址的关系</span></p>

<h5 style='margin-left:0cm;text-indent:0cm'><span style='font-family:"Times New Roman"'>(4)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
lang=AR-SA style='font-family:楷体'>中断产生后的堆栈栈变化</span></h5>

<p class=MsoNormal><span lang=ZH-CN style='font-family:楷体;color:black'>下图显示了给出相同特权级和不同特权级情况下中断产生后的堆栈栈变化示意图：</span></p>

<p class=MsoNormal><span style='color:black'>&nbsp;</span></p>

<p class=MsoNormal align=center style='text-align:center'><span><img border=0
width=332 height=255 id="图片 28" src="lab1/image010.png"
alt="说明: 151298425979212"></span></p>

<p class=MsoBodyText align=center style='text-align:center;text-indent:24.0pt'><span
lang=ZH-CN style='font-family:楷体'>图</span><span>11 </span><span lang=ZH-CN
style='font-family:楷体;color:black'>相同特权级和不同特权级情况下中断产生后的堆栈栈变化示意图</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph'><b><span>&nbsp;</span></b></p>

<h5 style='margin-left:0cm;text-indent:0cm'><span style='font-family:"Times New Roman";
font-weight:normal'>(5)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span><span lang=AR-SA style='font-family:楷体;font-weight:normal'>中断处理的特权级转换</span></h5>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体;color:black'>中断处理得特权级转换是通过<b>门描述符</b>（</span><span
style='color:black'>gate descriptor</span><span lang=ZH-CN style='font-family:
楷体;color:black'>）和<b>相关</b>指令来完成的。一个门描述符就是一个系统类型的段描述符，一共有</span><span
style='color:black'>4</span><span lang=ZH-CN style='font-family:楷体;color:black'>个子类型：调用门描述符（</span><span
style='color:black'>call-gate descriptor</span><span lang=ZH-CN
style='font-family:楷体;color:black'>），中断门描述符（</span><span style='color:black'>interrupt-gate
descriptor</span><span lang=ZH-CN style='font-family:楷体;color:black'>），陷阱门描述符（</span><span
style='color:black'>trap-gate descriptor</span><span lang=ZH-CN
style='font-family:楷体;color:black'>）和任务门描述符（</span><span style='color:black'>task-gate
descriptor</span><span lang=ZH-CN style='font-family:楷体;color:black'>）。与中断处理相关的是中断门描述符和陷阱门描述符。这些门描述符被存储在中断描述符表（</span><span
style='color:black'>Interrupt Descriptor Table</span><span lang=ZH-CN
style='font-family:楷体;color:black'>，简称</span><span style='color:black'>IDT</span><span
lang=ZH-CN style='font-family:楷体;color:black'>）当中。</span><span
style='color:black'>CPU</span><span lang=ZH-CN style='font-family:楷体;
color:black'>把中断向量作为</span><span style='color:black'>IDT</span><span
lang=ZH-CN style='font-family:楷体;color:black'>表项的索引，用来指出当中断发生时使用哪一个门描述符来处理中断。中断门描述符和陷阱门描述符几乎是一样的。中断发生时实施特权检查的过程如下图所示：</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:24.0pt'><span
style='color:black'><img border=0 width=381 height=275 id="图片 31"
src="lab1/image011.png" alt="说明: 161298425979212"></span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:24.0pt'><span
lang=ZH-CN style='font-family:楷体'>图</span><span>12 </span><span lang=ZH-CN
style='font-family:楷体;color:black'>中断发生时实施特权检查的过程</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>&nbsp;</span></p>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>门中的</span><span>DPL</span><span
lang=ZH-CN style='font-family:楷体'>和段选择符一起控制着访问，同时，段选择符结合偏移量（</span><span>Offset</span><span
lang=ZH-CN style='font-family:楷体'>）指出了中断处理例程的入口点。内核一般在门描述符中填入内核代码段的段选择子。产生中断后，</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>一定不会将运行控制从高特权环转向低特权环，特权级必须要么保持不变（当操作系统内核自己被中断的时候），或被提升（当用户态程序被中断的时候）。无论哪一种情况，作为结果的</span><span>CPL</span><span
lang=ZH-CN style='font-family:楷体'>必须等于目的代码段的</span><span>DPL</span><span
lang=ZH-CN style='font-family:楷体'>。如果</span><span>CPL</span><span lang=ZH-CN
style='font-family:楷体'>发生了改变，一个堆栈切换操作（通过</span><span style='color:black'>TSS</span><span
lang=ZH-CN style='font-family:楷体;color:black'>完成</span><span lang=ZH-CN
style='font-family:楷体'>）就会发生。如果中断是被用户态程序中的指令所触发的（比如软件执行</span><span>INT n</span><span
lang=ZH-CN style='font-family:楷体'>生产的中断），还会增加一个额外的检查：门的</span><span>DPL</span><span
lang=ZH-CN style='font-family:楷体'>必须具有与</span><span>CPL</span><span lang=ZH-CN
style='font-family:楷体'>相同或更低的特权。这就防止了用户代码随意触发中断。如果这些检查失败，会产生一个一般保护异常（</span><span>general-protection
exception</span><span lang=ZH-CN style='font-family:楷体'>）。</span></p>

<h3 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
style='font-family:"Times New Roman"'>3.3.3 lab1</span><span lang=AR-SA
style='font-family:楷体'>中对中断的处理实现</span></h3>

<h4 style='margin-left:0cm;text-indent:0cm'><span style='font-size:11.0pt;
font-family:"Times New Roman";font-style:normal'>(1)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span><span lang=AR-SA style='font-size:11.0pt;font-family:楷体;
font-style:normal'>外设基本初始化设置</span></h4>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>Lab1</span><span lang=ZH-CN style='font-family:楷体'>实现了中断初始化和对键盘、串口、时钟外设进行中断处理。串口的初始化函数</span><span>serial_init</span><span
lang=ZH-CN style='font-family:楷体'>（位于</span><span>/kern/driver/console.c</span><span
lang=ZH-CN style='font-family:楷体'>）中涉及中断初始化工作的很简单：</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:5.4pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=482 valign=top style='width:481.6pt;border:solid black 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:13.5pt'><span style='font-size:9.0pt'>......</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt'>//
  </span><span lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>使能串口</span><span
  style='font-size:9.0pt'>1</span><span lang=ZH-CN style='font-size:9.0pt;
  font-family:楷体'>接收字符后产生中断</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt'>           outb(COM1
  + COM_IER, COM_IER_RDI);</span></p>
  <p class=MsoNormal style='text-indent:13.5pt'><span style='font-size:9.0pt'>......</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>// </span><span lang=ZH-CN
  style='font-size:9.0pt;font-family:楷体'>通过中断控制器使能串口</span><span
  style='font-size:9.0pt'>1</span><span lang=ZH-CN style='font-size:9.0pt;
  font-family:楷体'>中断</span></p>
  <p class=MsoNormal style='text-indent:13.5pt'><span style='font-size:9.0pt'>pic_enable(IRQ_COM1);</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>键盘的初始化函数</span><span>kbd_init</span><span
lang=ZH-CN style='font-family:楷体'>（位于</span><span>kern/driver/console.c</span><span
lang=ZH-CN style='font-family:楷体'>中）完成了对键盘的中断初始化工作，具体操作更加简单：</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:5.4pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=482 valign=top style='width:481.6pt;border:solid black 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:13.5pt'><span style='font-size:9.0pt'>......</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>// </span><span lang=ZH-CN
  style='font-size:9.0pt;font-family:楷体'>通过中断控制器使能键盘输入中断</span></p>
  <p class=MsoNormal style='text-indent:13.5pt'><span style='font-size:9.0pt'>pic_enable(IRQ_KBD);</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>时钟是一种有着特殊作用的外设，其作用并不仅仅是计时。在后续章节中将讲到，正是由于有了规律的时钟中断，才使得无论当前</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>运行在哪里，操作系统都可以在预先确定的时间点上获得</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>控制权。这样当一个应用程序运行了一定时间后，操作系统会通过时钟中断获得</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>控制权，并可把</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>资源让给更需要</span><span>CPU</span><span
lang=ZH-CN style='font-family:楷体'>的其他应用程序。时钟的初始化函数</span><span>clock_init</span><span
lang=ZH-CN style='font-family:楷体'>（位于</span><span>kern/driver/clock.c</span><span
lang=ZH-CN style='font-family:楷体'>中）完成了对时钟控制器</span><span>8253</span><span
lang=ZH-CN style='font-family:楷体'>的初始化：</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:5.4pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=482 valign=top style='width:481.6pt;border:solid black 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-indent:15.0pt'><span style='font-size:10.0pt'>  ......</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:10.0pt'>//</span><span
  lang=ZH-CN style='font-size:10.0pt;font-family:楷体'>设置时钟每秒中断</span><span
  style='font-size:10.0pt'>100</span><span lang=ZH-CN style='font-size:10.0pt;
  font-family:楷体'>次</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:10.0pt'>       outb(IO_TIMER1,
  TIMER_DIV(100) % 256);</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:10.0pt'>       outb(IO_TIMER1,
  TIMER_DIV(100) / 256);</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>// </span><span lang=ZH-CN
  style='font-size:10.0pt;font-family:楷体'>通过中断控制器使能时钟中断</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>       pic_enable(IRQ_TIMER);</span></p>
  </td>
 </tr>
</table>

<h4 style='margin-left:0cm;text-indent:0cm'><span style='font-size:11.0pt;
font-family:"Times New Roman";font-style:normal'>(2)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span><span lang=AR-SA style='font-size:11.0pt;font-family:楷体;
font-style:normal'>中断初始化设置</span></h4>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>操作系统如果要正确处理各种不同的中断事件，就需要安排应该由哪个中断服务例程负责处理特定的中断事件。系统将所有的中断事件统一进行了编号（</span><span>0</span><span
lang=ZH-CN style='font-family:楷体'>～</span><span>255</span><span lang=ZH-CN
style='font-family:楷体'>），这个编号称为中断向量。以</span><span>ucore</span><span lang=ZH-CN
style='font-family:楷体'>为例，操作系统内核启动以后，会通过</span><span> idt_init </span><span
lang=ZH-CN style='font-family:楷体'>函数初始化</span><span> idt </span><span
lang=ZH-CN style='font-family:楷体'>表</span><span> (</span><span lang=ZH-CN
style='font-family:楷体'>参见</span><span>trap.c)</span><span lang=ZH-CN
style='font-family:楷体'>，而其中</span><span> vectors </span><span lang=ZH-CN
style='font-family:楷体'>中存储了中断处理程序的入口地址。</span><span>vectors </span><span
lang=ZH-CN style='font-family:楷体'>定义在</span><span> vector.S </span><span
lang=ZH-CN style='font-family:楷体'>文件中，通过一个工具程序</span><span> vector.c </span><span
lang=ZH-CN style='font-family:楷体'>生成。其中仅有</span><span> System call </span><span
lang=ZH-CN style='font-family:楷体'>中断的权限为用户权限</span><span> (DPL_USER)</span><span
lang=ZH-CN style='font-family:楷体'>，即仅能够使用</span><span> int 0x30 </span><span
lang=ZH-CN style='font-family:楷体'>指令。此外还有对</span><span> tickslock </span><span
lang=ZH-CN style='font-family:楷体'>的初始化，该锁用于处理时钟中断。</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>vector.S </span><span lang=ZH-CN style='font-family:
楷体'>文件通过</span><span> vectors.c </span><span lang=ZH-CN style='font-family:
楷体'>自动生成，其中定义了每个中断的入口程序和入口地址</span><span> (</span><span lang=ZH-CN
style='font-family:楷体'>保存在</span><span> vectors </span><span lang=ZH-CN
style='font-family:楷体'>数组中</span><span>)</span><span lang=ZH-CN
style='font-family:楷体'>。其中，中断可以分成两类：一类是压入错误编码的</span><span> (error code)</span><span
lang=ZH-CN style='font-family:楷体'>，另一类不压入错误编码。对于第二类，</span><span> vector.S </span><span
lang=ZH-CN style='font-family:楷体'>自动压入一个</span><span> 0</span><span lang=ZH-CN
style='font-family:楷体'>。此外，还会压入相应中断的中断号。在压入两个必要的参数之后，中断处理函数跳转到统一的入口</span><span>
alltraps </span><span lang=ZH-CN style='font-family:楷体'>处。</span></p>

<h4 style='margin-left:0cm;text-indent:0cm'><span style='font-size:11.0pt;
font-family:"Times New Roman";font-style:normal'>(3)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span><span lang=AR-SA style='font-size:11.0pt;font-family:楷体;
font-style:normal'>中断的处理过程</span></h4>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>trap</span><span lang=ZH-CN style='font-family:楷体'>函数（定义在</span><span>trap.c</span><span
lang=ZH-CN style='font-family:楷体'>中）是对中断进行处理的过程，所有的中断在经过中断入口函数</span><span>__alltraps</span><span
lang=ZH-CN style='font-family:楷体'>预处理后</span><span> (</span><span lang=ZH-CN
style='font-family:楷体'>定义在</span><span> trapasm.S</span><span lang=ZH-CN
style='font-family:楷体'>中</span><span>) </span><span lang=ZH-CN
style='font-family:楷体'>，都会跳转到这里。在处理过程中，根据不同的中断类型，进行相应的处理。在相应的处理过程结束以后，</span><span>trap</span><span
lang=ZH-CN style='font-family:楷体'>将会返回，被中断的程序会继续运行。整个中断处理流程大致如下：</span></p>

<p class=MsoBodyText style='text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>&nbsp;</span></p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0 width=460
 style='margin-left:28.9pt;border-collapse:collapse'>
 <tr>
  <td width=451 valign=top style='width:451.4pt;padding:3.0pt 3.0pt 3.0pt 3.0pt'>
  <table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
   style='margin-left:8.05pt;border-collapse:collapse;border:none'>
   <tr>
    <td width=217 valign=top style='width:217.4pt;border:solid windowtext 1.0pt;
    padding:3.0pt 3.0pt 3.0pt 3.0pt'>
    <p class=MsoNormal align=center style='margin-top:5.0pt;text-align:center;
    layout-grid-mode:char'><span style='font-size:10.0pt'>trapasm.S</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>1)</span><span
    lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>产生中断后，</span><span
    style='font-size:9.0pt'>CPU </span><span lang=ZH-CN style='font-size:9.0pt;
    font-family:楷体'>跳转到相应的中断处理入口</span><span style='font-size:9.0pt'> (vectors)</span><span
    lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>，并在桟中压入相应的</span><span
    style='font-size:9.0pt'> error_code</span><span lang=ZH-CN
    style='font-size:9.0pt;font-family:楷体'>（是否存在与异常号相关）</span><span lang=ZH-CN
    style='font-size:9.0pt'> </span><span lang=ZH-CN style='font-size:9.0pt;
    font-family:楷体'>以及</span><span style='font-size:9.0pt'> trap_no</span><span
    lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>，然后跳转到</span><span
    style='font-size:9.0pt'> alltraps </span><span lang=ZH-CN style='font-size:
    9.0pt;font-family:楷体'>函数入口：</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span lang=ZH-CN
    style='font-size:9.0pt;font-family:楷体'>注意：此处的跳转是</span><span
    style='font-size:9.0pt'> jmp </span><span lang=ZH-CN style='font-size:9.0pt;
    font-family:楷体'>过程</span></p>
    <table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
     style='border-collapse:collapse'>
     <tr>
      <td width=130 valign=top style='width:129.65pt;border:double black 1.0pt;
      border-right:none;padding:3.0pt 3.0pt 3.0pt 3.0pt'>
      <p class=MsoNormal align=right style='margin-top:5.0pt;text-align:right;
      layout-grid-mode:char'><span style='font-size:9.0pt'>(high)</span></p>
      </td>
      <td width=82 valign=top style='width:82.45pt;border:double black 1.0pt;
      padding:3.0pt 3.0pt 3.0pt 3.0pt'>
      <p class=MsoNormal style='margin-top:5.0pt;layout-grid-mode:char'><span
      style='font-size:9.0pt'>...</span></p>
      </td>
     </tr>
     <tr>
      <td width=130 valign=top style='width:129.65pt;border-top:none;
      border-left:double black 1.0pt;border-bottom:double black 1.0pt;
      border-right:none;padding:3.0pt 3.0pt 3.0pt 3.0pt'>
      <p class=MsoNormal align=right style='margin-top:5.0pt;text-align:right;
      layout-grid-mode:char'><span lang=ZH-CN style='font-size:9.0pt;
      font-family:楷体'>产生中断时的</span><span style='font-size:9.0pt'> eip → </span></p>
      </td>
      <td width=82 valign=top style='width:82.45pt;border:double black 1.0pt;
      border-top:none;padding:3.0pt 3.0pt 3.0pt 3.0pt'>
      <p class=MsoNormal style='margin-top:5.0pt;layout-grid-mode:char'><span
      style='font-size:9.0pt'>eip</span></p>
      </td>
     </tr>
     <tr>
      <td width=130 valign=top style='width:129.65pt;border-top:none;
      border-left:double black 1.0pt;border-bottom:double black 1.0pt;
      border-right:none;padding:3.0pt 3.0pt 3.0pt 3.0pt'>
      <p class=MsoNormal align=right style='margin-top:5.0pt;text-align:right;
      layout-grid-mode:char'><span style='font-size:9.0pt'>&nbsp;</span></p>
      </td>
      <td width=82 valign=top style='width:82.45pt;border:double black 1.0pt;
      border-top:none;padding:3.0pt 3.0pt 3.0pt 3.0pt'>
      <p class=MsoNormal style='margin-top:5.0pt;layout-grid-mode:char'><span
      style='font-size:9.0pt'>error_code</span></p>
      </td>
     </tr>
     <tr>
      <td width=130 valign=top style='width:129.65pt;border-top:none;
      border-left:double black 1.0pt;border-bottom:double black 1.0pt;
      border-right:none;padding:3.0pt 3.0pt 3.0pt 3.0pt'>
      <p class=MsoNormal align=right style='margin-top:5.0pt;text-align:right;
      layout-grid-mode:char'><span style='font-size:9.0pt'>esp → </span></p>
      </td>
      <td width=82 valign=top style='width:82.45pt;border:double black 1.0pt;
      border-top:none;padding:3.0pt 3.0pt 3.0pt 3.0pt'>
      <p class=MsoNormal style='margin-top:5.0pt;layout-grid-mode:char'><span
      style='font-size:9.0pt'>trap_no</span></p>
      </td>
     </tr>
     <tr>
      <td width=130 valign=top style='width:129.65pt;border-top:none;
      border-left:double black 1.0pt;border-bottom:double black 1.0pt;
      border-right:none;padding:3.0pt 3.0pt 3.0pt 3.0pt'>
      <p class=MsoNormal align=right style='margin-top:5.0pt;text-align:right;
      layout-grid-mode:char'><span style='font-size:9.0pt'>(low)</span></p>
      </td>
      <td width=82 valign=top style='width:82.45pt;border:double black 1.0pt;
      border-top:none;padding:3.0pt 3.0pt 3.0pt 3.0pt'>
      <p class=MsoNormal style='margin-top:5.0pt;layout-grid-mode:char'><span
      style='font-size:9.0pt'>...</span></p>
      </td>
     </tr>
    </table>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span lang=ZH-CN
    style='font-size:9.0pt;font-family:楷体'>在栈中保存当前被打断程序的</span><span
    style='font-size:9.0pt'> trapframe </span><span lang=ZH-CN
    style='font-size:9.0pt;font-family:楷体'>结构</span><span style='font-size:
    9.0pt'>(</span><span lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>参见过程</span><span
    style='font-size:9.0pt'>trapasm.S)</span><span lang=ZH-CN style='font-size:
    9.0pt;font-family:楷体'>。设置</span><span style='font-size:9.0pt'> kernel (</span><span
    lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>内核</span><span
    style='font-size:9.0pt'>) </span><span lang=ZH-CN style='font-size:9.0pt;
    font-family:楷体'>的数据段寄存器，最后压入</span><span style='font-size:9.0pt'> esp</span><span
    lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>，作为</span><span
    style='font-size:9.0pt'> trap </span><span lang=ZH-CN style='font-size:
    9.0pt;font-family:楷体'>函数参数</span><span style='font-size:9.0pt'>(struct
    trapframe * tf) </span><span lang=ZH-CN style='font-size:9.0pt;font-family:
    楷体'>并跳转到中断处理函数</span><span style='font-size:9.0pt'> trap </span><span
    lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>处：</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span lang=ZH-CN
    style='font-size:9.0pt;font-family:楷体'>注意：此时的跳转是</span><span
    style='font-size:9.0pt'> call </span><span lang=ZH-CN style='font-size:
    9.0pt;font-family:楷体'>调用，会压入返回地址</span><span style='font-size:9.0pt'> eip</span><span
    lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>，注意区分此处</span><span
    style='font-size:9.0pt'>eip</span><span lang=ZH-CN style='font-size:9.0pt;
    font-family:楷体'>与</span><span style='font-size:9.0pt'>trapframe</span><span
    lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>中</span><span
    style='font-size:9.0pt'>eip</span><span lang=ZH-CN style='font-size:9.0pt;
    font-family:楷体'>：</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>trapframe</span><span
    lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>的结构为：</span></p>
    <table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
     style='margin-left:4.3pt;border-collapse:collapse'>
     <tr>
      <td width=102 valign=top style='width:102.45pt;border:double black 1.0pt;
      border-right:none;padding:3.0pt 3.0pt 3.0pt 3.0pt'>
      <p class=MsoBodyText style='text-indent:6.1pt;layout-grid-mode:char'><span
      style='font-size:9.0pt'>Struct trapframe</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>{</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>uint edi;</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>uint esi;</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>uint ebp;</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>…</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>ushort es;</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>ushort padding1;</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>ushort ds;</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>ushort padding2;</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>uint trapno;</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>uint err;</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>uint eip;</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>...</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>}</span></p>
      </td>
      <td width=110 valign=top style='width:109.65pt;border:double black 1.0pt;
      padding:3.0pt 3.0pt 3.0pt 3.0pt'>
      <p class=MsoBodyText style='text-indent:6.1pt;layout-grid-mode:char'><span
      lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>观察</span><span
      style='font-size:9.0pt'> trapframe </span><span lang=ZH-CN
      style='font-size:9.0pt;font-family:楷体'>结构与中断产生过程的压桟顺序。</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span lang=ZH-CN
      style='font-size:9.0pt;font-family:楷体'>需要明确</span><span style='font-size:
      9.0pt'> pushal </span><span lang=ZH-CN style='font-size:9.0pt;font-family:
      楷体'>指令都保存了哪些寄存器，按照什么顺序？</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>&nbsp;</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>&nbsp;</span></p>
      <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:
      9.0pt'>&nbsp;</span></p>
      <p class=MsoBodyText><span style='font-size:9.0pt'>← trap_no</span></p>
      <p class=MsoBodyText><span style='font-size:9.0pt'>← trap_error<br>
      ← </span><span lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>产生中断处的</span><span
      style='font-size:9.0pt'> eip</span></p>
      </td>
     </tr>
    </table>
    <p class=MsoNormal style='margin-top:5.0pt'><span lang=ZH-CN
    style='font-size:9.0pt;font-family:楷体'>进入</span><span style='font-size:
    9.0pt'> trap </span><span lang=ZH-CN style='font-size:9.0pt;font-family:
    楷体'>函数，对中断进行相应的处理：</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>3)</span><span
    lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>结束</span><span
    style='font-size:9.0pt'> trap </span><span lang=ZH-CN style='font-size:
    9.0pt;font-family:楷体'>函数的执行后，通过</span><span style='font-size:9.0pt'> ret </span><span
    lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>指令返回到</span><span
    style='font-size:9.0pt'> alltraps </span><span lang=ZH-CN style='font-size:
    9.0pt;font-family:楷体'>执行过程。</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span lang=ZH-CN
    style='font-size:9.0pt;font-family:楷体'>从栈中恢复所有寄存器的值。</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span lang=ZH-CN
    style='font-size:9.0pt;font-family:楷体'>调整</span><span style='font-size:
    9.0pt'> esp </span><span lang=ZH-CN style='font-size:9.0pt;font-family:
    楷体'>的值：跳过栈中的</span><span style='font-size:9.0pt'> trap_no </span><span
    lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>与</span><span
    style='font-size:9.0pt'> error_code</span><span lang=ZH-CN
    style='font-size:9.0pt;font-family:楷体'>，使</span><span style='font-size:
    9.0pt'>esp</span><span lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>指向中断返回</span><span
    style='font-size:9.0pt'> eip</span><span lang=ZH-CN style='font-size:9.0pt;
    font-family:楷体'>，通过</span><span style='font-size:9.0pt'> iret </span><span
    lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>调用恢复</span><span
    style='font-size:9.0pt'> cs</span><span lang=ZH-CN style='font-size:9.0pt;
    font-family:楷体'>、</span><span style='font-size:9.0pt'>eflag</span><span
    lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>以及</span><span
    style='font-size:9.0pt'> eip</span><span lang=ZH-CN style='font-size:9.0pt;
    font-family:楷体'>，继续执行。</span></p>
    </td>
    <td width=230 valign=top style='width:229.85pt;border:solid windowtext 1.0pt;
    border-left:none;padding:3.0pt 3.0pt 3.0pt 3.0pt'>
    <p class=MsoNormal align=center style='margin-top:5.0pt;text-align:center;
    layout-grid-mode:char'><span>trap.c</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>&nbsp;</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span style='font-size:9.0pt'>2)</span><span
    lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>详细的中断分类以及处理流程如下：</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span lang=ZH-CN
    style='font-size:9.0pt;font-family:楷体'>根据中断号对不同的中断进行处理。其中，若中断号是</span><span
    style='font-size:9.0pt'>IRQ_OFFSET + IRQ_TIMER </span><span lang=ZH-CN
    style='font-size:9.0pt;font-family:楷体'>为时钟中断，则把</span><span
    style='font-size:9.0pt'>ticks </span><span lang=ZH-CN style='font-size:
    9.0pt;font-family:楷体'>将增加一。</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span lang=ZH-CN
    style='font-size:9.0pt;font-family:楷体'>若中断号是</span><span style='font-size:
    9.0pt'>IRQ_OFFSET + IRQ_COM1 </span><span lang=ZH-CN style='font-size:9.0pt;
    font-family:楷体'>为串口中断，则显示收到的字符。</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span lang=ZH-CN
    style='font-size:9.0pt;font-family:楷体'>若中断号是</span><span style='font-size:
    9.0pt'>IRQ_OFFSET + IRQ_KBD </span><span lang=ZH-CN style='font-size:9.0pt;
    font-family:楷体'>为键盘中断，则显示收到的字符。</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span lang=ZH-CN
    style='font-size:9.0pt;font-family:楷体'>若为其他中断且产生在内核状态，则挂起系统；</span></p>
    <p class=MsoBodyText style='text-indent:6.1pt'><span>&nbsp;</span></p>
    </td>
   </tr>
  </table>
  <p class=MsoNormal style='margin-top:5.0pt;text-align:justify;text-justify:
  inter-ideograph'></p>
  </td>
  <td width=9 valign=top style='width:8.95pt;padding:3.0pt 3.0pt 3.0pt 3.0pt'>
  <p class=MsoNormal style='margin-top:5.0pt;layout-grid-mode:char'><span>&nbsp;</span></p>
  </td>
 </tr>
</table>

<p class=MsoBodyText align=center style='margin-top:12.0pt;margin-right:0cm;
margin-bottom:6.0pt;margin-left:0cm;text-align:center;text-indent:24.0pt'><span
lang=ZH-CN style='font-family:楷体'>图</span><span>13 ucore</span><span
lang=ZH-CN style='font-family:楷体'>中断处理流程</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>至此，对整个</span><span>lab1</span><span
lang=ZH-CN style='font-family:楷体'>中的主要部分的背景知识和实现进行了阐述。请大家能够根据前面的练习要求完成所有的练习。</span></p>

<h1 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
style='font-size:17.0pt;font-family:"Times New Roman"'>4 </span><span
lang=AR-SA style='font-size:17.0pt;font-family:楷体'>实验报告要求</span></h1>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>从网站上下载</span><span>lab1.tar.bz2</span><span
lang=ZH-CN style='font-family:楷体'>后，解压得到代码目录</span><span>lab1</span><span
lang=ZH-CN style='font-family:楷体'>，完成实验。在实践中完成实验的各个练习。在报告中回答所有练习中提出的问题。实验报告文档命名为</span><span>lab1-</span><span
lang=ZH-CN style='font-family:楷体'>学生</span><span>ID.odt or lab1-</span><span
lang=ZH-CN style='font-family:楷体'>学生</span><span>ID.txt</span><span lang=ZH-CN
style='font-family:楷体'>。推荐用</span><span>txt</span><span lang=ZH-CN
style='font-family:楷体'>格式，即基本文本格式。对于</span><span>lab1</span><span lang=ZH-CN
style='font-family:楷体'>中编程任务，完成编写之后，在</span><span>lab1</span><span lang=ZH-CN
style='font-family:楷体'>目录下执行</span><span>make handin</span><span lang=ZH-CN
style='font-family:楷体'>任务，即会自动生成</span><span>lab1-handin.tar.gz</span><span
lang=ZH-CN style='font-family:楷体'>文件。建立一个目录，名字为</span><span>lab1_result</span><span
lang=ZH-CN style='font-family:楷体'>，将实验报告文档和之前生成的</span><span>handin</span><span
lang=ZH-CN style='font-family:楷体'>文件放在该目录下。然后用</span><span>tar</span><span
lang=ZH-CN style='font-family:楷体'>软件压缩打包此目录，并命名为</span><span>lab1-</span><span
lang=ZH-CN style='font-family:楷体'>学生</span><span>ID.tar.bz2</span><span
lang=ZH-CN style='font-family:楷体'>（在</span><span>lab1_result</span><span
lang=ZH-CN style='font-family:楷体'>的上层目录下执行</span><span>“tar jcf lab1-</span><span
lang=ZH-CN style='font-family:楷体'>学生</span><span>ID.tar.bz2 lab1_result “</span><span
lang=ZH-CN style='font-family:楷体'>即可）。最后请一定提前或按时提交到网络学堂上。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-align:justify;text-justify:
inter-ideograph;text-indent:23.9pt;line-height:17.9pt;text-autospace:none'><span
lang=ZH-CN style='font-family:楷体'>注意有</span><b><i><span lang=ZH-CN
style='font-family:楷体'>“</span></i></b><b><i><span>LAB1</span></i></b><b><i><span
lang=ZH-CN style='font-family:楷体'>”</span></i></b><span lang=ZH-CN
style='font-family:楷体'>的注释，代码中所有需要完成的地方</span><span lang=ZH-CN
style='font-family:楷体'>（</span><span>challenge</span><span lang=ZH-CN
style='font-family:楷体'>除外）</span><span lang=ZH-CN style='font-family:楷体'>都有</span><b><i><span
lang=ZH-CN style='font-family:楷体'>“</span></i></b><b><i><span>LAB1</span></i></b><b><i><span
lang=ZH-CN style='font-family:楷体'>”和“</span></i></b><b><i><span>YOUR CODE</span></i></b><b><i><span
lang=ZH-CN style='font-family:楷体'>”</span></i></b><span lang=ZH-CN
style='font-family:楷体'>的注释，请在提交时特别注意保持注释，并将</span><b><i><span lang=ZH-CN
style='font-family:楷体'>“</span></i></b><b><i><span>YOUR CODE</span></i></b><b><i><span
lang=ZH-CN style='font-family:楷体'>”</span></i></b><span lang=ZH-CN
style='font-family:楷体'>替换为自己的学号，并且将所有标有对应注释的部分填上正确的代码。</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>&nbsp;</span></p>

<h1 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
lang=AR-SA style='font-size:17.0pt;font-family:楷体'>附录“<a name="OLE_LINK4"><a
name="OLE_LINK3">关于</a></a></span><span style='font-size:17.0pt;font-family:
"Times New Roman"'>A20 Gate</span><span lang=AR-SA style='font-size:17.0pt;
font-family:楷体'>”</span></h1>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>【参考“关于</span><span>A20
Gate</span><span lang=ZH-CN style='font-family:楷体'>”</span><span lang=ZH-CN> </span><a
href="http://hengch.blog.163.com/blog/static/107800672009013104623747/">http://hengch.blog.163.com/blog/static/107800672009013104623747/</a>
<span lang=ZH-CN style='font-family:楷体'>】</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:35.45pt;text-indent:-11.45pt'><span lang=ZH-CN
style='font-family:楷体'>【参考“百度文库</span><span lang=ZH-CN> </span><span
lang=ZH-CN style='font-family:楷体'>激活</span><span>A20</span><span lang=ZH-CN
style='font-family:楷体'>地址线详解”</span><span lang=ZH-CN> </span><a
href="http://wenku.baidu.com/view/d6efe68fcc22bcd126ff0c00.html"><span
style='color:windowtext;text-decoration:none'>http://wenku.baidu.com/view/d6efe68fcc22bcd126ff0c00.html</span></a><span
lang=ZH-CN style='font-family:楷体'>】</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>Intel</span><span lang=ZH-CN style='font-family:楷体'>早期的</span><span>8086
CPU</span><span lang=ZH-CN style='font-family:楷体'>提供了</span><span>20</span><span
lang=ZH-CN style='font-family:楷体'>根地址线</span><span>,</span><span lang=ZH-CN
style='font-family:楷体'>可寻址空间范围即</span><span>0~2^20(00000H~FFFFFH)</span><span
lang=ZH-CN style='font-family:楷体'>的</span><span> 1MB</span><span lang=ZH-CN
style='font-family:楷体'>内存空间。但</span><span>8086</span><span lang=ZH-CN
style='font-family:楷体'>的数据处理位宽位</span><span>16</span><span lang=ZH-CN
style='font-family:楷体'>位，无法直接寻址</span><span>1MB</span><span lang=ZH-CN
style='font-family:楷体'>内存空间，所以</span><span>8086</span><span lang=ZH-CN
style='font-family:楷体'>提供了段地址加偏移地址的地址转换机制。</span><span>PC</span><span
lang=ZH-CN style='font-family:楷体'>机的寻址结构是</span><span>segment:offset</span><span
lang=ZH-CN style='font-family:楷体'>，</span><span>segment</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span>offset</span><span lang=ZH-CN
style='font-family:楷体'>都是</span><span>16</span><span lang=ZH-CN
style='font-family:楷体'>位的寄存器，最大值是</span><span>0ffffh</span><span lang=ZH-CN
style='font-family:楷体'>，换算成物理地址的计算方法是把</span><span>segment</span><span
lang=ZH-CN style='font-family:楷体'>左移</span><span>4</span><span lang=ZH-CN
style='font-family:楷体'>位，再加上</span><span>offset</span><span lang=ZH-CN
style='font-family:楷体'>，所以</span><span>segment:offset</span><span lang=ZH-CN
style='font-family:楷体'>所能表达的寻址空间最大应为</span><span>0ffff0h + 0ffffh = 10ffefh</span><span
lang=ZH-CN style='font-family:楷体'>（前面的</span><span>0ffffh</span><span
lang=ZH-CN style='font-family:楷体'>是</span><span>segment=0ffffh</span><span
lang=ZH-CN style='font-family:楷体'>并向左移动</span><span>4</span><span lang=ZH-CN
style='font-family:楷体'>位的结果，后面的</span><span>0ffffh</span><span lang=ZH-CN
style='font-family:楷体'>是可能的最大</span><span>offset</span><span lang=ZH-CN
style='font-family:楷体'>），这个计算出的</span><span>10ffefh</span><span lang=ZH-CN
style='font-family:楷体'>是多大呢？大约是</span><span>1088KB</span><span lang=ZH-CN
style='font-family:楷体'>，就是说，</span><span>segment:offset</span><span lang=ZH-CN
style='font-family:楷体'>的地址表示能力，超过了</span><span>20</span><span lang=ZH-CN
style='font-family:楷体'>位地址线的物理寻址能力。所以当寻址到超过</span><span>1MB</span><span
lang=ZH-CN style='font-family:楷体'>的内存时，会发生</span><span>“</span><span
lang=ZH-CN style='font-family:楷体'>回卷</span><span>”</span><span lang=ZH-CN
style='font-family:楷体'>（不会发生异常）。但下一代的基于</span><span>Intel 80286 CPU</span><span
lang=ZH-CN style='font-family:楷体'>的</span><span>PC AT</span><span lang=ZH-CN
style='font-family:楷体'>计算机系统提供了</span><span>24</span><span lang=ZH-CN
style='font-family:楷体'>根地址线，这样</span><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>的寻址范围变为</span><span> 2^24=16M,</span><span lang=ZH-CN
style='font-family:楷体'>同时也提供了保护模式，可以访问到</span><span>1MB</span><span lang=ZH-CN
style='font-family:楷体'>以上的内存了，此时如果遇到</span><span>“</span><span lang=ZH-CN
style='font-family:楷体'>寻址超过</span><span>1MB”</span><span lang=ZH-CN
style='font-family:楷体'>的情况，系统不会再</span><span>“</span><span lang=ZH-CN
style='font-family:楷体'>回卷</span><span>”</span><span lang=ZH-CN
style='font-family:楷体'>了，这就造成了向下不兼容。为了保持完全的向下兼容性，</span><span>IBM</span><span
lang=ZH-CN style='font-family:楷体'>决定在</span><span>PC AT</span><span lang=ZH-CN
style='font-family:楷体'>计算机系统上加个硬件逻辑，来模仿以上的回绕特征，于是出现了</span><span>A20 Gate</span><span
lang=ZH-CN style='font-family:楷体'>。他们的方法就是把</span><span>A20</span><span
lang=ZH-CN style='font-family:楷体'>地址线控制和键盘控制器的一个输出进行</span><span>AND</span><span
lang=ZH-CN style='font-family:楷体'>操作，这样来控制</span><span>A20</span><span
lang=ZH-CN style='font-family:楷体'>地址线的打开（使能）和关闭（屏蔽</span><span>\</span><span
lang=ZH-CN style='font-family:楷体'>禁止）。一开始时</span><span>A20</span><span
lang=ZH-CN style='font-family:楷体'>地址线控制是被屏蔽的（总为</span><span>0</span><span
lang=ZH-CN style='font-family:楷体'>），直到系统软件通过一定的</span><span>IO</span><span
lang=ZH-CN style='font-family:楷体'>操作去打开它（参看</span><span>bootasm.S</span><span
lang=ZH-CN style='font-family:楷体'>）。很显然，在实模式下要访问高端内存区，这个开关必须打开，在保护模式下，由于使用</span><span>32</span><span
lang=ZH-CN style='font-family:楷体'>位地址线，如果</span><span>A20</span><span
lang=ZH-CN style='font-family:楷体'>恒等于</span><span>0</span><span lang=ZH-CN
style='font-family:楷体'>，那么系统只能访问奇数兆的内存，即只能访问</span><span>0--1M</span><span
lang=ZH-CN style='font-family:楷体'>、</span><span>2-3M</span><span lang=ZH-CN
style='font-family:楷体'>、</span><span>4-5M......</span><span lang=ZH-CN
style='font-family:楷体'>，这显然是不行的，所以在保护模式下，这个开关也必须打开。</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>当</span><span>A20 </span><span
lang=ZH-CN style='font-family:楷体'>地址线控制禁止时，则程序就像在</span><span>8086</span><span
lang=ZH-CN style='font-family:楷体'>中运行，</span><span>1MB</span><span lang=ZH-CN
style='font-family:楷体'>以上的地是不可访问的。在保护模式下</span><span>A20</span><span
lang=ZH-CN style='font-family:楷体'>地址线控制是要打开的。为了使能所有地址位的寻址能力</span><span>,</span><span
lang=ZH-CN style='font-family:楷体'>必须向键盘控制器</span><span>8042</span><span
lang=ZH-CN style='font-family:楷体'>发送一个命令。键盘控制器</span><span>8042</span><span
lang=ZH-CN style='font-family:楷体'>将会将它的的某个输出引脚的输出置高电平，作为</span><span> A20 </span><span
lang=ZH-CN style='font-family:楷体'>地址线控制的输入。一旦设置成功之后，内存将不会再被绕回</span><span>(memory
wrapping)</span><span lang=ZH-CN style='font-family:楷体'>，这样我们就可以寻址整个</span><span>
286 </span><span lang=ZH-CN style='font-family:楷体'>的</span><span> 16M </span><span
lang=ZH-CN style='font-family:楷体'>内存，或者是寻址</span><span> 80386</span><span
lang=ZH-CN style='font-family:楷体'>级别机器的所有</span><span> 4G </span><span
lang=ZH-CN style='font-family:楷体'>内存了。</span><span lang=ZH-CN> </span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><a name="OLE_LINK2"><a name="OLE_LINK1"><span lang=ZH-CN
style='font-family:楷体'>键盘控制器</span></a></a><span>8042</span><span lang=ZH-CN
style='font-family:楷体'>的逻辑结构图</span><span lang=ZH-CN style='font-family:楷体'>如下所示。从软件的角度来看，如何控制</span><span>8042</span><span
lang=ZH-CN style='font-family:楷体'>呢？早期的</span><span>PC</span><span lang=ZH-CN
style='font-family:楷体'>机，控制键盘有一个单独的单片机</span><span>8042</span><span lang=ZH-CN
style='font-family:楷体'>，现如今这个芯片已经给集成到了其它大片子中，但其功能和使用方法还是一样，当</span><span>PC</span><span
lang=ZH-CN style='font-family:楷体'>机刚刚出现</span><span>A20 Gate</span><span
lang=ZH-CN style='font-family:楷体'>的时候，估计为节省硬件设计成本，工程师使用这个</span><span>8042</span><span
lang=ZH-CN style='font-family:楷体'>键盘控制器来控制</span><span>A20 Gate</span><span
lang=ZH-CN style='font-family:楷体'>，但</span><span>A20 Gate</span><span
lang=ZH-CN style='font-family:楷体'>与键盘管理没有一点关系。下面先从软件的角度简单介绍一下</span><span>8042</span><span
lang=ZH-CN style='font-family:楷体'>这个芯片。</span></p>

<p class=MsoBodyText align=center style='margin-top:12.0pt;margin-right:0cm;
margin-bottom:6.0pt;margin-left:0cm;text-align:center;text-indent:24.0pt'><a
href="http://img.bimg.126.net/photo/SIYB9WEnd5YHwmhLMRmr0g==/2277695511543435674.jpg"><span
style='color:windowtext;text-decoration:none'><img border=0 width=350
height=263 id="_x0000_i1025" src="lab1/image012.png"></span></a></p>

<p class=MsoBodyText align=center style='margin-top:12.0pt;margin-right:0cm;
margin-bottom:6.0pt;margin-left:0cm;text-align:center;text-indent:24.0pt'><span
lang=ZH-CN style='font-family:楷体'>图</span><span lang=ZH-CN> </span><span
lang=ZH-CN style='font-family:楷体'>键盘控制器</span><span>8042</span><span
lang=ZH-CN style='font-family:楷体'>的逻辑结构图</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>8042</span><span lang=ZH-CN style='font-family:楷体'>键盘控制器的</span><span>IO</span><span
lang=ZH-CN style='font-family:楷体'>端口是</span><span>0x60</span><span lang=ZH-CN
style='font-family:楷体'>～</span><span>0x6f</span><span lang=ZH-CN
style='font-family:楷体'>，实际上</span><span>IBM PC/AT</span><span lang=ZH-CN
style='font-family:楷体'>使用的只有</span><span>0x60</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span>0x64</span><span lang=ZH-CN
style='font-family:楷体'>两个端口（</span><span>0x61</span><span lang=ZH-CN
style='font-family:楷体'>、</span><span>0x62</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span>0x63</span><span lang=ZH-CN
style='font-family:楷体'>用于与</span><span>XT</span><span lang=ZH-CN
style='font-family:楷体'>兼容目的）。</span><span>8042</span><span lang=ZH-CN
style='font-family:楷体'>通过这些端口给键盘控制器或键盘发送命令或读取状态。输出端口</span><span>P2</span><span
lang=ZH-CN style='font-family:楷体'>用于特定目的。位</span><span>0</span><span
lang=ZH-CN style='font-family:楷体'>（</span><span>P20</span><span lang=ZH-CN
style='font-family:楷体'>引脚）用于实现</span><span>CPU</span><span lang=ZH-CN
style='font-family:楷体'>复位操作，位</span><span>1</span><span lang=ZH-CN
style='font-family:楷体'>（</span><span>P21</span><span lang=ZH-CN
style='font-family:楷体'>引脚）用户控制</span><span>A20</span><span lang=ZH-CN
style='font-family:楷体'>信号线的开启与否。系统向输入缓冲（端口</span><span>0x64</span><span
lang=ZH-CN style='font-family:楷体'>）写入一个字节，即发送一个键盘控制器命令。可以带一个参数。参数是通过</span><span>0x60</span><span
lang=ZH-CN style='font-family:楷体'>端口发送的。</span><span lang=ZH-CN> </span><span
lang=ZH-CN style='font-family:楷体'>命令的返回值也从端口</span><span> 0x60</span><span
lang=ZH-CN style='font-family:楷体'>去读。</span><span>8042</span><span lang=ZH-CN
style='font-family:楷体'>有</span><span>4</span><span lang=ZH-CN style='font-family:
楷体'>个寄存器：</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:45.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>1</span><span
lang=ZH-CN style='font-family:楷体'>个</span><span>8-bit</span><span lang=ZH-CN
style='font-family:楷体'>长的</span><span>Input buffer</span><span lang=ZH-CN
style='font-family:楷体'>；</span><span>Write-Only</span><span lang=ZH-CN
style='font-family:楷体'>；</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:45.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>1</span><span
lang=ZH-CN style='font-family:楷体'>个</span><span>8-bit</span><span lang=ZH-CN
style='font-family:楷体'>长的</span><span>Output buffer</span><span lang=ZH-CN
style='font-family:楷体'>；</span><span> Read-Only</span><span lang=ZH-CN
style='font-family:楷体'>；</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:45.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>1</span><span
lang=ZH-CN style='font-family:楷体'>个</span><span>8-bit</span><span lang=ZH-CN
style='font-family:楷体'>长的</span><span>Status Register</span><span lang=ZH-CN
style='font-family:楷体'>；</span><span>Read-Only</span><span lang=ZH-CN
style='font-family:楷体'>；</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:45.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span>1</span><span
lang=ZH-CN style='font-family:楷体'>个</span><span>8-bit</span><span lang=ZH-CN
style='font-family:楷体'>长的</span><span>Control Register</span><span lang=ZH-CN
style='font-family:楷体'>；</span><span>Read/Write</span><span lang=ZH-CN
style='font-family:楷体'>。</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
lang=ZH-CN style='font-family:楷体'>有两个端口地址：</span><span>60h</span><span
lang=ZH-CN style='font-family:楷体'>和</span><span>64h</span><span lang=ZH-CN
style='font-family:楷体'>，有关对它们的读写操作描述如下：</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:45.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>读</span><span>60h</span><span lang=ZH-CN
style='font-family:楷体'>端口，读</span><span>output buffer&nbsp;</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:45.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>写</span><span>60h</span><span lang=ZH-CN
style='font-family:楷体'>端口，写</span><span>input buffer&nbsp;</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:45.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>读</span><span>64h</span><span lang=ZH-CN
style='font-family:楷体'>端口，读</span><span>Status Register</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:45.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-21.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>操作</span><span>Control Register</span><span lang=ZH-CN
style='font-family:楷体'>，首先要向</span><span>64h</span><span lang=ZH-CN
style='font-family:楷体'>端口写一个命令（</span><span>20h</span><span lang=ZH-CN
style='font-family:楷体'>为读命令，</span><span>60h</span><span lang=ZH-CN
style='font-family:楷体'>为写命令），然后根据命令从</span><span>60h</span><span lang=ZH-CN
style='font-family:楷体'>端口读出</span><span>Control Register</span><span
lang=ZH-CN style='font-family:楷体'>的数据或者向</span><span>60h</span><span
lang=ZH-CN style='font-family:楷体'>端口写入</span><span>Control Register</span><span
lang=ZH-CN style='font-family:楷体'>的数据（</span><span>64h</span><span lang=ZH-CN
style='font-family:楷体'>端口还可以接受许多其它的命令）。</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>Status Register</span><span lang=ZH-CN
style='font-family:楷体'>的定义（要用</span><span>bit 0</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span>bit 1</span><span lang=ZH-CN
style='font-family:楷体'>）：</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>&nbsp;&nbsp;&nbsp;bit&nbsp;&nbsp;&nbsp; meaning</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span> -----------------------------------------------------------------------</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:48.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-24.0pt'><span>0<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>output register (60h) </span><span lang=ZH-CN
style='font-family:楷体'>中有数据</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:48.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-24.0pt'><span>1<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>input register (60h/64h) </span><span lang=ZH-CN
style='font-family:楷体'>有数据</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:48.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-24.0pt'><span>2<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-family:楷体'>系统标志（上电复位后被置为</span><span>0</span><span
lang=ZH-CN style='font-family:楷体'>）</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:48.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-24.0pt'><span>3<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>data in input register is command (1) or data (0)</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:48.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-24.0pt'><span>4<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>1=keyboard enabled, 0=keyboard disabled (via switch)</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:48.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-24.0pt'><span>5<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>1=transmit timeout (data transmit not complete)</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:48.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-24.0pt'><span>6<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>1=receive timeout (data transmit not complete)</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:48.0pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-24.0pt'><span>7<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>1=even parity rec'd, 0=odd parity rec'd (should be odd)</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span>&nbsp;&nbsp;&nbsp;
 </span><span lang=ZH-CN style='font-family:楷体'>除了这些资源外，</span><span>8042</span><span
lang=ZH-CN style='font-family:楷体'>还有</span><span>3</span><span lang=ZH-CN
style='font-family:楷体'>个内部端口：</span><span>Input Port</span><span lang=ZH-CN
style='font-family:楷体'>、</span><span>Outport Port</span><span lang=ZH-CN
style='font-family:楷体'>和</span><span>Test Port</span><span lang=ZH-CN
style='font-family:楷体'>，这三个端口的操作都是通过向</span><span>64h</span><span lang=ZH-CN
style='font-family:楷体'>发送命令，然后在</span><span>60h</span><span lang=ZH-CN
style='font-family:楷体'>进行读写的方式完成，其中本文要操作的</span><span>A20 Gate</span><span
lang=ZH-CN style='font-family:楷体'>被定义在</span><span>Output Port</span><span
lang=ZH-CN style='font-family:楷体'>的</span><span>bit 1</span><span lang=ZH-CN
style='font-family:楷体'>上，所以有必要对</span><span>Outport Port</span><span
lang=ZH-CN style='font-family:楷体'>的操作及端口定义做一个说明。</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>读</span><span>Output Port</span><span lang=ZH-CN
style='font-family:楷体'>：向</span><span>64h</span><span lang=ZH-CN
style='font-family:楷体'>发送</span><span>0d0h</span><span lang=ZH-CN
style='font-family:楷体'>命令，然后从</span><span>60h</span><span lang=ZH-CN
style='font-family:楷体'>读取</span><span>Output Port</span><span lang=ZH-CN
style='font-family:楷体'>的内容</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>写</span><span>Output Port</span><span lang=ZH-CN
style='font-family:楷体'>：向</span><span>64h</span><span lang=ZH-CN
style='font-family:楷体'>发送</span><span>0d1h</span><span lang=ZH-CN
style='font-family:楷体'>命令，然后向</span><span>60h</span><span lang=ZH-CN
style='font-family:楷体'>写入</span><span>Output Port</span><span lang=ZH-CN
style='font-family:楷体'>的数据</span><span>&nbsp;</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>禁止键盘操作命令：向</span><span>64h</span><span lang=ZH-CN
style='font-family:楷体'>发送</span><span>0adh&nbsp;</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span style='font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-family:楷体'>打开键盘操作命令：向</span><span>64h</span><span lang=ZH-CN
style='font-family:楷体'>发送</span><span>0aeh&nbsp;</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>&nbsp;&nbsp;</span><span lang=ZH-CN style='font-family:
楷体'>有了这些命令和知识，就可以实现操作</span><span>A20 Gate</span><span lang=ZH-CN
style='font-family:楷体'>来从实模式切换到保护模式了。</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span lang=ZH-CN style='font-family:楷体'>理论上讲，我们只要操作</span><span>8042</span><span
lang=ZH-CN style='font-family:楷体'>芯片的输出端口（</span><span>64h</span><span
lang=ZH-CN style='font-family:楷体'>）的</span><span>bit 1</span><span lang=ZH-CN
style='font-family:楷体'>，就可以控制</span><span>A20 Gate</span><span lang=ZH-CN
style='font-family:楷体'>，但实际上，当你准备向</span><span>8042</span><span lang=ZH-CN
style='font-family:楷体'>的输入缓冲区里写数据时，可能里面还有其它数据没有处理，所以，我们要首先禁止键盘操作，同时等待数据缓冲区中没有数据以后，才能真正地去操作</span><span>8042</span><span
lang=ZH-CN style='font-family:楷体'>打开或者关闭</span><span>A20 Gate</span><span
lang=ZH-CN style='font-family:楷体'>。打开</span><span>A20 Gate</span><span
lang=ZH-CN style='font-family:楷体'>的具体步骤大致如下（参考</span><span>bootasm.S</span><span
lang=ZH-CN style='font-family:楷体'>）：</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>    1.</span><span lang=ZH-CN style='font-family:
楷体'>等待</span><span>8042 Input buffer</span><span lang=ZH-CN style='font-family:
楷体'>为空；</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>    2.</span><span lang=ZH-CN style='font-family:
楷体'>发送</span><span>Write 8042 Output Port </span><span lang=ZH-CN
style='font-family:楷体'>（</span><span>P2</span><span lang=ZH-CN
style='font-family:楷体'>）命令到</span><span>8042 Input buffer</span><span
lang=ZH-CN style='font-family:楷体'>；</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>    3.</span><span lang=ZH-CN style='font-family:
楷体'>等待</span><span>8042 Input buffer</span><span lang=ZH-CN style='font-family:
楷体'>为空；</span></p>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:0cm;text-align:justify;text-justify:inter-ideograph;
text-indent:24.0pt'><span>    4.</span><span lang=ZH-CN style='font-family:
楷体'>将</span><span>8042 Output Port</span><span lang=ZH-CN style='font-family:
楷体'>（</span><span>P2</span><span lang=ZH-CN style='font-family:楷体'>）得到字节的第</span><span>2</span><span
lang=ZH-CN style='font-family:楷体'>位置</span><span>1</span><span lang=ZH-CN
style='font-family:楷体'>，然后写入</span><span>8042 Input buffer</span><span
lang=ZH-CN style='font-family:楷体'>；</span></p>

<h1 style='margin-left:0cm;text-align:justify;text-justify:inter-ideograph'><span
lang=AR-SA style='font-size:17.0pt;font-family:楷体'>附录“启动后第一条执行的指令”</span></h1>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:35.45pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-11.45pt'><span lang=ZH-CN style='font-family:楷体'>【参考</span><span>IA-32
Intel Architecture Software Developer’s Manual Volume 3: System Programming
Guide Section 9.1.4</span><span lang=ZH-CN style='font-family:楷体'>】</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:35.45pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=534 valign=top style='width:534.1pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:35.45pt;text-align:justify;text-justify:inter-ideograph;
  text-indent:-11.45pt'><span>9.1.4 First Instruction Executed</span></p>
  <p class=MsoBodyText style='margin-top:12.0pt;margin-right:12.95pt;
  margin-bottom:6.0pt;margin-left:9.7pt;text-align:justify;text-justify:inter-ideograph'><span>The
  first instruction that is fetched and executed following a hardware reset is located
  at physical address FFFFFFF0H. This address is 16 bytes below the processor’s
  uppermost physical address. The EPROM containing the softwareinitialization code
  must be located at this address.</span></p>
  <p class=MsoBodyText style='margin-top:12.0pt;margin-right:12.95pt;
  margin-bottom:6.0pt;margin-left:9.7pt;text-align:justify;text-justify:inter-ideograph'><span> The
  address FFFFFFF0H is beyond the 1-MByte addressable range of the processor while
  in real-address mode. The processor is initialized to this starting address
  as follows. The CS register has two parts: the visible segment selector part
  and the hidden base address part. In real-address mode, the base address is
  normally formed by shifting the 16-bit segment selector value 4 bits to the
  left to produce a 20-bit base address. However, during a hardware reset, the
  segment selector in the CS register is loaded with F000H and the base address
  is loaded with FFFF0000H. The starting address is thus formed by adding the
  base address to the value in the EIP register (that is, FFFF0000 + FFF0H =
  FFFFFFF0H). </span></p>
  <p class=MsoBodyText style='margin-top:12.0pt;margin-right:12.95pt;
  margin-bottom:6.0pt;margin-left:9.7pt;text-align:justify;text-justify:inter-ideograph'><span>The
  first time the CS register is loaded with a new value after a hardware reset,
  the processor will follow the normal rule for address translation in real-address
  mode (that is, [CS base address = CS segment selector * 16]). To insure that
  the base address in the CS register remains unchanged until the EPROM based
  softwareinitialization code is completed, the code must not contain a far
  jump or far call or allow an interrupt to occur (which would cause the CS
  selector value to be changed).</span></p>
  </td>
 </tr>
</table>

<p class=MsoBodyText style='margin-top:12.0pt;margin-right:0cm;margin-bottom:
6.0pt;margin-left:35.45pt;text-align:justify;text-justify:inter-ideograph;
text-indent:-11.45pt'><span>&nbsp;</span></p>

</div>

</body>

</html>
