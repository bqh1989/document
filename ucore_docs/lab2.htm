<html>

<head>
<meta name=标题 content="实验二：内存管理">
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=Generator content="Microsoft Word 14 (filtered)">
<title>实验二：内存管理</title>
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Arial;
	panose-1:2 11 6 4 2 2 2 2 2 4;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"\@宋体";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"Lucida Sans";
	panose-1:2 11 6 2 3 5 4 2 2 4;}
@font-face
	{font-family:"Palatino Linotype";
	panose-1:2 4 5 2 5 5 5 3 3 4;}
@font-face
	{font-family:楷体;
	panose-1:2 1 6 9 6 1 1 1 1 1;}
@font-face
	{font-family:"\@楷体";
	panose-1:2 1 6 9 6 1 1 1 1 1;}
@font-face
	{font-family:永中宋体;
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"\@永中宋体";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:"Times New Roman";}
h1
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:12.0pt;
	margin-left:21.25pt;
	text-align:center;
	text-indent:-6.85pt;
	line-height:12.0pt;
	font-size:12.0pt;
	font-family:宋体;
	font-weight:bold;}
h2
	{margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:63.8pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:-49.6pt;
	font-size:15.0pt;
	font-family:Arial;
	font-weight:bold;}
h3
	{margin-top:13.0pt;
	margin-right:0cm;
	margin-bottom:13.0pt;
	margin-left:70.9pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:-70.9pt;
	line-height:172%;
	font-size:14.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
h4
	{margin-top:14.0pt;
	margin-right:0cm;
	margin-bottom:14.5pt;
	margin-left:84.0pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:-21.0pt;
	line-height:156%;
	font-size:10.5pt;
	font-family:"Times New Roman";
	font-weight:bold;}
p.MsoNormalIndent, li.MsoNormalIndent, div.MsoNormalIndent
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:10.0pt;
	font-size:10.5pt;
	font-family:"Times New Roman";}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	layout-grid-mode:char;
	border:none;
	padding:0cm;
	font-size:9.0pt;
	font-family:"Times New Roman";}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:"Times New Roman";}
p.MsoBodyText, li.MsoBodyText, div.MsoBodyText
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:"Times New Roman";}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p.MsoDocumentMap, li.MsoDocumentMap, div.MsoDocumentMap
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	background:navy;
	font-size:10.5pt;
	font-family:"Times New Roman";}
p
	{margin-right:0cm;
	margin-left:0cm;
	font-size:12.0pt;
	font-family:宋体;}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:9.0pt;
	font-family:"Times New Roman";}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:21.0pt;
	font-size:10.5pt;
	font-family:"Times New Roman";}
span.1
	{font-family:宋体;
	font-weight:bold;}
span.2
	{font-family:Arial;
	font-weight:bold;}
span.3
	{font-family:"Lucida Sans";
	font-weight:bold;}
span.4
	{font-family:"Lucida Sans";
	font-weight:bold;}
span.a1
	{font-family:"Lucida Sans";}
.MsoChpDefault
	{font-size:10.0pt;}
 /* Page Definitions */
@page WordSection1
	{size:596.0pt 842.0pt;
	margin:36.0pt 36.0pt 36.0pt 36.0pt;}
div.WordSection1
	{page:WordSection1;}
@page WordSection2
	{size:596.0pt 842.0pt;
	margin:78.0pt 44.0pt 14.0pt 51.0pt;}
div.WordSection2
	{page:WordSection2;}
@page WordSection3
	{size:596.0pt 842.0pt;
	margin:78.0pt 44.0pt 14.0pt 51.0pt;}
div.WordSection3
	{page:WordSection3;}
 /* List Definitions */
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>

</head>

<body lang=EN-US link=blue vlink=purple>

<div class=WordSection1>

<p class=MsoNormal align=left style='margin-left:164.0pt;text-align:left;
line-height:23.6pt;text-autospace:none'><b><span lang=ZH-CN style='font-size:
16.0pt;font-family:楷体;vertical-align:sub;letter-spacing:.05pt'>实</span></b><b><span
lang=ZH-CN style='font-size:16.0pt;font-family:楷体;vertical-align:sub;
letter-spacing:.1pt'>验二</span></b><b><span lang=ZH-CN style='font-size:16.0pt;
font-family:楷体;vertical-align:sub;letter-spacing:.05pt'>：物理</span></b><b><span
lang=ZH-CN style='font-size:16.0pt;font-family:楷体;vertical-align:sub;
letter-spacing:.1pt'>内存管</span></b><b><span lang=ZH-CN style='font-size:16.0pt;
font-family:楷体;vertical-align:sub'>理</span></b></p>

<p class=MsoNormal align=left style='margin-left:5.7pt;text-align:left;
text-autospace:none'><b><span style='font-size:17.0pt'>1    </span></b><b><span
lang=ZH-CN style='font-size:17.0pt;font-family:楷体;letter-spacing:.05pt'>实验目</span></b><b><span
lang=ZH-CN style='font-size:17.0pt;font-family:楷体'>的</span></b></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:47.6pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>理解基于段页式内存地址的转换机制</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:47.6pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>理解页表的建立和使用方法</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:47.6pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>理解物理内存的管理方法</span></p>

<p class=MsoNormal align=left style='margin-left:5.7pt;text-align:left;
text-autospace:none'><b><span style='font-size:17.0pt'>2    </span></b><b><span
lang=ZH-CN style='font-size:17.0pt;font-family:楷体;letter-spacing:.05pt'>实验内</span></b><b><span
lang=ZH-CN style='font-size:17.0pt;font-family:楷体'>容</span></b></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>实验一过后大家做出来了一个可以启动的系统，实验二主要涉及操作系统的物理内存管理。操作系统为了使用内存，还需高效地管理内存资源。在实验二中大家会了解并且自己动手完成一个简单的物理内存管理系统。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>本次实验包含三个部分。首先了解如何发现系统中的物理内存；然后了解如何建立对物理内存的初步管理，即了解连续物理内存管理；最后了解页表相关的操作，即如何建立页表来实现虚拟内存到物理内存之间的映射，对段页式内存管理机制有一个比较全面的了解。本实验里面实现的内存管理还是非常基本的，并没有涉及到对实际机器的优化，比如</span><span
lang=ZH-CN style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>针对</span><span style='font-size:12.0pt'> cache </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的优化等。实际操作系统（如</span><span
style='font-size:12.0pt'>Linux</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>等）中的内存管理是相当复杂的。</span><span lang=ZH-CN style='font-size:12.0pt'>
</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>如果大家有余力，尝试完成扩展练习。</span></p>

<p class=MsoNormal align=left style='text-align:left;text-autospace:none'><b><span
style='font-size:14.0pt'>2.1 </span></b><b><span lang=ZH-CN style='font-size:
14.0pt;font-family:楷体'>练习</span></b></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:red'>练习</span></b><b><span
style='font-size:12.0pt;color:red'>0 </span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:red'>：填写已有实验</span></b></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;line-height:17.9pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>本实验依赖实验</span><span
style='font-size:12.0pt'>1</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>。请把你做的实验</span><span style='font-size:12.0pt'>1</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的代码填入本实验中代码中有</span><span
style='font-size:12.0pt'>“LAB1”</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的注释相应部分。提示：可采用</span><span style='font-size:12.0pt'>merge</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>工具，比如</span><span
style='font-size:12.0pt'>kdiff3</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，</span><span style='font-size:12.0pt'>eclipse</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中的</span><span
style='font-size:12.0pt'>diff/merge</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>工具，</span><span style='font-size:12.0pt'>understand</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中的</span><span
style='font-size:12.0pt'>diff/merge</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>工具等。</span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:red'>练习</span></b><b><span
lang=ZH-CN style='font-size:12.0pt;color:red'> </span></b><b><span
style='font-size:12.0pt;color:red'>1</span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:red'>：实现</span></b><b><span
style='font-size:12.0pt;color:red'>first-fit</span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:red'>连续物理内存分配算法（需要编程）</span></b></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;line-height:17.9pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在实现</span><span
style='font-size:12.0pt'>first fit </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>内存分配算法的回收函数时，要考虑地址连续的空闲块之间的合并操作。提示</span><span
style='font-size:12.0pt'>:</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>在建立空闲页块链表时，需要按照空闲页块起始地址来排序，形成一个有序的链表。可能会修改</span><span
style='font-size:12.0pt'>default_pmm.c</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>中的</span><span style='font-size:12.0pt'>default_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，</span><span
style='font-size:12.0pt'>default_init_memmap</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>，</span><span style='font-size:12.0pt'>default_alloc_pages</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，</span><span
style='font-size:12.0pt'> default_free_pages</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>等相关函数。请仔细查看和理解</span><span
style='font-size:12.0pt'>default_pmm.c</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>中的注释。</span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:red'>练习</span></b><b><span
lang=ZH-CN style='font-size:12.0pt;color:red'> </span></b><b><span
style='font-size:12.0pt;color:red'>2</span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:red'>：实现寻找虚拟地址对应的页表项（需要编程）</span></b></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;line-height:17.9pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系。其中的</span><span
style='font-size:12.0pt'>get_pte</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数是设置页表项环节中的一个重要步骤。此函数找到一个虚地址对应的二级页表项的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。本练习需要补全</span><span
style='font-size:12.0pt'>get_pte</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数</span><span style='font-size:12.0pt'> <a name="OLE_LINK14"><a
name="OLE_LINK13">in kern/mm/pmm.c</a></a></span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>，实现其功能。请仔细查看和理解</span><span
style='font-size:12.0pt'>get_pte</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数中的注释。</span><span style='font-size:12.0pt'>get_pte</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数的调用关系图如下所示：</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;line-height:17.9pt;text-autospace:none'>

<table cellpadding=0 cellspacing=0 align=left>
 <tr>
  <td width=46 height=11></td>
 </tr>
 <tr>
  <td></td>
  <td><img width=386 height=180 src="lab2.files/image001.png"></td>
 </tr>
</table>

<span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=center style='text-align:center;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<br clear=ALL>

<p class=MsoNormal align=center style='margin-top:0cm;margin-right:9.8pt;
margin-bottom:0cm;margin-left:9.7pt;margin-bottom:.0001pt;text-align:center;
text-indent:23.9pt;line-height:17.9pt;text-autospace:none'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>图</span><span style='font-size:12.0pt'>1 
get_pte</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数的调用关系图</span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:red'>练习</span></b><b><span
lang=ZH-CN style='font-size:12.0pt;color:red'> </span></b><b><span
style='font-size:12.0pt;color:red'>3</span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:red'>：释放某虚地址所在的页并取消对应二级页表项的映射（需要编程）</span></b></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:9.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>当释放一个包含某虚地址的物理内存页时，需要让对应此物理内存页的管理数据结构</span><span
style='font-size:12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>做相关的清除处理，使得此物理内存页成为空闲；另外还需把表示虚地址与物理地址对应关系的二级页表项清除。请仔细查看和理解</span><span
style='font-size:12.0pt'>page_remove_pte</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>函数中的注释。为此，需要补全在</span><span
style='font-size:12.0pt'> kern/mm/pmm.c</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>中的</span><span style='font-size:12.0pt'>page_remove_pte</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数。</span><span
style='font-size:12.0pt'>page_remove_pte</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>函数的调用关系图如下所示：</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:9.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'>

<table cellpadding=0 cellspacing=0 align=left>
 <tr>
  <td width=56 height=15></td>
 </tr>
 <tr>
  <td></td>
  <td><img width=348 height=75 src="lab2.files/image002.png"></td>
 </tr>
</table>

<span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:9.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:9.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:9.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=center style='text-align:center;line-height:10.0pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<br clear=ALL>

<p class=MsoNormal align=center style='margin-top:0cm;margin-right:9.8pt;
margin-bottom:0cm;margin-left:9.7pt;margin-bottom:.0001pt;text-align:center;
text-indent:23.9pt;line-height:17.9pt;text-autospace:none'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>图</span><span style='font-size:12.0pt'>2 
page_remove_pte</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>函数的调用关系图</span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:red'>扩展练习</span></b><b><span
style='font-size:12.0pt;color:red'>Challenge </span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:red'>：任意大小的内存单元</span></b><b><span
style='font-size:12.0pt;color:red'>slub</span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:red'>分配算法（需要编程）</span></b></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:9.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>如果觉得上诉练习难度不够，可考虑完成此扩展练习。实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。比如，如果连续分配</span><span
style='font-size:12.0pt'>8</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>个</span><span style='font-size:12.0pt'>16</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>字节的内存块，当分配完毕后，实际只消耗了一个空闲物理页。要求时空都高效，可参考</span><span
style='font-size:12.0pt'>slub</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>算法来实现，可简化实现，能够体现其主体思想即可。要求有设计文档。</span><span style='font-size:
12.0pt'>slub</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>相关网页在</span><a
href="http://www.ibm.com/developerworks/cn/linux/l-cn-slub/"><span
style='font-size:12.0pt;color:windowtext;text-decoration:none'>http://www.ibm.com/developerworks/cn/linux/l-cn-slub/</span></a><span
style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>。完成</span><span style='font-size:12.0pt'>challenge</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的同学可单独提交</span><span
style='font-size:12.0pt'>challenge</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>。完成得好的同学可获得最终考试成绩的加分。</span></p>

<p class=MsoNormal align=left style='text-align:left;text-autospace:none'><b><span
style='font-size:14.0pt'>2.2 </span></b><b><span lang=ZH-CN style='font-size:
14.0pt;font-family:楷体'>项目组成</span></b></p>

<p class=MsoNormal align=center style='margin-top:0cm;margin-right:9.75pt;
margin-bottom:0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-align:center;
text-indent:23.9pt;line-height:17.9pt;text-autospace:none'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>表</span><span style='font-size:12.0pt'>1</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>：</span><span lang=ZH-CN
style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>实验二文件列表</span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:33.75pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=397 valign=top style='width:14.0cm;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormalIndent style='text-indent:7.3pt'><span style='font-size:
  9.0pt'>     |-- boot</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |-- asm.h</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |-- <span style='color:red'>bootasm.S</span></span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   `-- bootmain.c</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|-- kern</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |-- init</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |   |-- <span style='color:red'>entry.S</span></span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |   `-- <span style='color:red'>init.c</span></span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |-- mm</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |   |-- <span style='color:red'>default_pmm.c</span></span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |   |-- <span style='color:red'>default_pmm.h</span></span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |   |-- memlayout.h</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |   |-- mmu.h</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |   |-- <span style='color:red'>pmm.c</span></span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |   `-- <span style='color:red'>pmm.h</span></span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |-- sync</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |   `--<span style='color:red'> sync.h</span></span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   `-- trap</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|       |-- trap.c</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|       |-- trapentry.S</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|       |-- trap.h</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|       `-- vectors.S</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|-- libs</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |-- <span style='color:red'>atomic.h</span></span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>|   |-- <span style='color:red'>list.h</span></span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>`-- tools</span></p>
  <p class=MsoNormalIndent style='text-indent:18.0pt'><span style='font-size:
  9.0pt'>    |--<span style='color:red'> kernel.ld</span></span></p>
  <p class=MsoNormalIndent style='text-indent:21.0pt'><span>&nbsp;</span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormalIndent style='text-indent:21.0pt'><span>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>相对与实验一，实验二主要增加和修改的文件如上表红色部分所示。主要改动如下：</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:23.7pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-size:12.0pt'>boot/bootasm.S</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>：增加了对计算机系统中物理内存布局的探测功能；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:23.7pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-size:12.0pt'>kern/init/entry.S</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>：根据临时段表重新暂时建立好新的段空间，为进行分页做好准备。</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:23.7pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-size:12.0pt'>kern/mm/default_pmm.[ch]</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>：提供基本的基于链表方法的物理内存管理（分配单位为页，即</span><span
style='font-size:12.0pt'>4096</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>字节）；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:23.7pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-size:12.0pt'>kern/mm/pmm.[ch]</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>：</span><span style='font-size:12.0pt'>pmm.h</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>定义物理内存管理类框架</span><span
style='font-size:12.0pt'>struct</span><span style='font-size:12.0pt'>&nbsp;</span><span
style='font-size:12.0pt'>pmm_manager</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>，基于此通用框架可以实现不同的物理内存管理策略和算法</span><span style='font-size:
12.0pt'>(default_pmm.[ch] </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>实现了一个基于此框架的简单物理内存管理策略</span><span style='font-size:12.0pt'>)</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>；</span><span
style='font-size:12.0pt'>&nbsp;</span><span style='font-size:12.0pt'>pmm.c</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>包含了对此物理内存管理类框架的访问，以及与建立、修改、访问页表相关的各种函数实现。</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:23.7pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-size:12.0pt'>kern/sync/sync.h</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>：为确保内存管理修改相关数据时不被中断打断，提供两个功能，一个是保存</span><span
style='font-size:12.0pt'>eflag</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>寄存器中的中断屏蔽位信息并屏蔽中断的功能，另一个是根据保存的中断屏蔽位信息来使能中断的功能；<span
style='color:red'>（可不用细看）</span></span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:23.7pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-size:12.0pt'>libs/list.h</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>：定义了通用双向链表结构以及相关的查找、插入等基本操作，这是建立基于链表方法的物理内存管理（以及其他内核功能）的基础。其他有类似双向链表需求的内核功能模块可直接使用</span><span
style='font-size:12.0pt'>list.h</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中定义的函数。</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:23.7pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-size:12.0pt'>libs/atomic.h</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>：定义了对一个变量进行读写的原子操作，确保相关操作不被中断打断。<span style='color:red'>（可不用细看）</span></span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:23.7pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-size:12.0pt'>tools/kernel.ld</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>：</span><span style='font-size:12.0pt'>ld</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>形成执行文件的地址所用到的链接脚本。修改了</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的起始入口和代码段的起始地址。相关细节可参看附录</span><span style='font-size:12.0pt'>C</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>。</span></p>

<p class=MsoNormal align=left style='margin-top:.7pt;text-align:left;
line-height:10.0pt;text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>编译方法</span></b></p>

<p class=MsoNormal align=left style='margin-top:.7pt;text-align:left;
line-height:10.0pt;text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>编译并运行代码的命令如下：</span></p>

<p class=MsoBodyText style='margin-left:21.0pt'><span>make</span></p>

<p class=MsoBodyText style='margin-left:21.0pt'><span>make qemu</span></p>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>则可以得到如下显示界面（仅供参考）</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:29.8pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=409 valign=top style='width:408.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:9.0pt'>chenyu$ make qemu</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>(THU.CST) os is loading ...</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>Special kernel symbols:</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>  entry  0xc010002c (phys)</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>  etext  0xc010537f (phys)</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>  edata  0xc01169b8 (phys)</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>  end    0xc01178dc (phys)</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>Kernel executable memory
  footprint: 95KB</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>memory managment: default_pmm_manager</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>e820map:</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>  memory: 0009f400,
  [00000000, 0009f3ff], type = 1.</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>  memory: 00000c00,
  [0009f400, 0009ffff], type = 2.</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>  memory: 00010000,
  [000f0000, 000fffff], type = 2.</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>  memory: 07efd000,
  [00100000, 07ffcfff], type = 1.</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>  memory: 00003000,
  [07ffd000, 07ffffff], type = 2.</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>  memory: 00040000,
  [fffc0000, ffffffff], type = 2.</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>check_alloc_page()
  succeeded!</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>check_pgdir() succeeded!</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>check_boot_pgdir()
  succeeded!</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>-------------------- BEGIN
  --------------------</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>PDE(0e0) c0000000-f8000000
  38000000 urw</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>  |-- PTE(38000)
  c0000000-f8000000 38000000 -rw</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>PDE(001) fac00000-fb000000
  00400000 -rw</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>  |-- PTE(000e0)
  faf00000-fafe0000 000e0000 urw</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>  |-- PTE(00001)
  fafeb000-fafec000 00001000 -rw</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>--------------------- END
  ---------------------</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>++ setup timer interrupts</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>100 ticks</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>100 ticks</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>……</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal align=center style='text-align:center'><span>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>通过上图，我们可以看到</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>在显示其</span><span style='font-size:12.0pt'>entry</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>（入口地址）、</span><span
style='font-size:12.0pt'>etext</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>（代码段截止处地址）、</span><span style='font-size:12.0pt'>edata</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>（数据段截止处地址）、和</span><span
style='font-size:12.0pt'>end</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>（</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>截止处地址）的值后，探测出计算机系统中的物理内存的布局（</span><span
style='font-size:12.0pt'>e820map</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>下的显示内容）。接下来</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>会以页为最小分配单位实现一个简单的内存分配管理，完成二级页表的建立，进入分页模式，执行各种我们设置的检查，最后显示</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>建立好的二级页表内容，并在分页模式下响应时钟中断。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><b><span style='font-size:17.0pt'>&nbsp;</span></b></p>

<p class=MsoNormal align=left style='margin-left:5.7pt;text-align:left;
text-autospace:none'><b><span style='font-size:17.0pt'>3    </span></b><b><span
lang=ZH-CN style='font-size:17.0pt;font-family:楷体'>物理内存管理</span></b></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><b><span style='font-size:17.0pt'>&nbsp;</span></b></p>

<p class=MsoNormal align=left style='margin-left:5.65pt;text-align:left;
text-autospace:none'><b><span style='font-size:14.0pt'>3.1 </span></b><b><span
lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>实验执行流程概述</span></b></p>

<p class=MsoNormal style='margin-right:9.8pt;text-indent:24.0pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>本次实验主要完成</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>内核对物理内存的管理工作。参考</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>总控函数</span><span style='font-size:12.0pt'>kern_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的代码，可以清楚地看到在调用完成物理内存初始化的</span><span
style='font-size:12.0pt'>pmm_init</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数之前和之后，是已有</span><span style='font-size:12.0pt'>lab1</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>实验的工作，好像没啥修改。其实不然，</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>有两个方面的扩展。首先，</span><span style='font-size:12.0pt'>bootloader</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的工作有增加，在</span><span
style='font-size:12.0pt'>bootloader</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>中，完成了对物理内存资源的探测工作（可进一步参阅附录</span><span style='font-size:
12.0pt'>A</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>和附录</span><span
style='font-size:12.0pt'>B</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>），让</span><span style='font-size:12.0pt'>ucore kernel</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在后续执行中能够基于</span><span
style='font-size:12.0pt'>bootloader</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>探测出的物理内存情况进行物理内存管理初始化工作。其次，</span><span
style='font-size:12.0pt'>bootloader</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>不像</span><span style='font-size:12.0pt'>lab1</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>那样，直接调用</span><span
style='font-size:12.0pt'>kern_init</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数，而是先调用位于</span><span style='font-size:12.0pt'>lab2/kern/init/entry.S</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中的</span><span
style='font-size:12.0pt'>kern_entry</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数。</span><span style='font-size:12.0pt'>kern_entry</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数的主要任务是为执行</span><span
style='font-size:12.0pt'>kern_init</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>建立一个良好的</span><span style='font-size:12.0pt'>C</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>语言运行环境（设置堆栈），而且临时建立了一个段映射关系，为之后建立分页机制的过程做一个准备（细节在</span><span
style='font-size:12.0pt'>3.5</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>小节有进一步阐述）。完成这些工作后，才调用</span><span style='font-size:12.0pt'>kern_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数。</span></p>

<p class=MsoNormal style='margin-right:9.8pt;text-indent:24.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>kern_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数在完成一些输出并对</span><span
style='font-size:12.0pt'>lab1</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>实验结果的检查后，将进入物理内存管理初始化的工作，即调用</span><span style='font-size:12.0pt'>pmm_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数完成物理内存的管理，这也是我们</span><span
style='font-size:12.0pt'>lab2</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的内容。接着是执行中断和异常相关的初始化工作，即调用</span><span style='font-size:12.0pt'>pic_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数和</span><span
style='font-size:12.0pt'>idt_init</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数等，这些工作与</span><span style='font-size:12.0pt'>lab1</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的中断异常初始化工作的内容是相同的。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>为了完成物理内存管理，这里首先需要探测可用的物理内存资源；了解到物理内存位于什么地方，有多大之后，就以固定页面大小来划分整个物理内存空间，并准备以此为最小内存分配单位来管理整个物理内存，管理在内核运行过程中每页内存，设定其可用状态（</span><span
style='font-size:12.0pt'>free</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的，</span><span style='font-size:12.0pt'>used</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的，还是</span><span
style='font-size:12.0pt'>reserved</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的），这其实就对应了我们在课本上讲到的连续内存分配概念和原理的具体实现；接着</span><span
style='font-size:12.0pt'>ucore kernel</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>就要建立页表，</span><span lang=ZH-CN style='font-size:12.0pt'>
</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>启动分页机制，让</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的</span><span style='font-size:12.0pt'>MMU</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>把预先建立好的页表中的页表项读入到</span><span
style='font-size:12.0pt'>TLB</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中，根据页表项描述的虚拟页（</span><span style='font-size:12.0pt'>Page</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>）与物理页帧（</span><span
style='font-size:12.0pt'>Page Frame</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>）的对应关系完成</span><span style='font-size:12.0pt'>CPU</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>对内存的读、写和执行操作。这一部分其实就对应了我们在课本上讲到内存映射、页表、多级页表等概念和原理的具体实现。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在代码分析上，建议根据执行流程来直接看源代码，并可采用</span><span
style='font-size:12.0pt'>GDB</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>源码调试的手段来动态地分析</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的执行过程。内存管理相关的总体控制函数是</span><span
style='font-size:12.0pt'>pmm_init</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数，它完成的主要工作包括：</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>初始化物理内存页管理器框架</span><span
style='font-size:12.0pt'>pmm_manager</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>建立空闲的</span><span
style='font-size:12.0pt'>page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>链表，这样就可以分配以页（</span><span style='font-size:12.0pt'>4KB</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>）为单位的空闲内存了；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>检查物理内存页分配算法；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>4.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>为确保切换到分页机制后，代码能够正常执行，先建立一个临时二级页表；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>5.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>建立一一映射关系的二级页表；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>6.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>使能分页机制；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>7.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>从新设置全局段描述符表；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>8.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>取消临时二级页表；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>9.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>检查页表建立是否正确；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>10.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>通过自映射机制完成页表的打印输出（这部分是扩展知识）</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:0cm;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>另外，主要注意的相关代码内容包括：</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt;font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span
style='font-size:12.0pt'>boot/bootasm.S</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>中探测内存部分（从</span><span style='font-size:
12.0pt'>probe_memory</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>到</span><span style='font-size:12.0pt'>finish_probe</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>的代码）；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt;font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>管理每个物理页的</span><span style='font-size:
12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>数据结构（在</span><span
style='font-size:12.0pt'>mm/memlayout.h</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>中），这个数据结构也是实现连续物理内存分配算法的关键数据结构，可通过此数据结构来完成空闲块的链接和信息存储，而基于这个数据结构的管理物理页数组起始地址就是全局变量</span><span
style='font-size:12.0pt'>pages</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，具体初始化此数组的函数位于</span><span style='font-size:12.0pt'>page_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数中；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt;font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>用于实现连续物理内存分配算法的物理内存页管理器框架</span><span
style='font-size:12.0pt'>pmm_manager</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>，这个数据结构定义了实现内存分配算法的关键函数指针，而同学需要完成这些函数的具体实现；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt;font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>设定二级页表和建立页表项以完成虚实地址映射关系，这与硬件相关，且用到不少内联函数，源代码相对难懂一些。具体完成页表和页表项建立的重要函数是</span><span
style='font-size:12.0pt'>boot_map_segment</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>函数，而</span><span style='font-size:12.0pt'>get_pte</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数是完成虚实映射关键的关键。</span></p>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><b><span style='font-size:14.0pt'>&nbsp;</span></b></p>

<p class=MsoNormal align=left style='margin-left:5.65pt;text-align:left;
text-autospace:none'><b><span style='font-size:14.0pt'>3.2 </span></b><b><span
lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>探测系统物理内存布局</span></b></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>当</span><span
style='font-size:12.0pt'> ucore </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>被启动之后，最重要的事情就是知道还有多少内存可用，一般来说，获取内存大小的方法由</span><span
style='font-size:12.0pt'> BIOS </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中断调用和直接探测两种。但</span><span style='font-size:12.0pt'>BIOS </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中断调用方法是一般只能在实模式下完成，而直接探测方法必须在保护模式下完成。通过</span><span
style='font-size:12.0pt'> BIOS </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中断获取内存布局有三种方式，都是基于</span><span style='font-size:12.0pt'>INT 
15h</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中断，分别为</span><span
style='font-size:12.0pt'>88h e801h   e820h</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>。但是</span><span lang=ZH-CN
style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>并非在所有情况下这三种方式都能工作。在</span><span style='font-size:12.0pt'> Linux
kernel </span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>里，采用的方法是依次尝试这三</span><span
lang=ZH-CN style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>种方法。而在本实验中，我们通过</span><span style='font-size:12.0pt'>e820h</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中断获取内存信息。因为</span><span
style='font-size:12.0pt'>e820h</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中断必须在实模式下使用，所以我们在</span><span style='font-size:12.0pt'>
bootloader </span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>进入保护模式之前调用这个</span><span
style='font-size:12.0pt'> BIOS </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中断，并且把</span><span style='font-size:12.0pt'> e820 </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>映</span><span lang=ZH-CN
style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>射结构保存在物理地址</span><span style='font-size:12.0pt'>0x8000</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>处。具体实现详见</span><span
style='font-size:12.0pt'>boot/bootasm.S</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>。有关探测系统物理内存方法和具体实现的</span><span
lang=ZH-CN style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>信息参见</span><a
href="http://wiki.osdev.org/How_Do_I_Determine_The_Amount_Of_RAM"><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:windowtext;text-decoration:
none'>附录</span><span style='font-size:12.0pt;color:windowtext;text-decoration:
none'>A</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:windowtext;text-decoration:none'>和附录</span><span style='font-size:12.0pt;
color:windowtext;text-decoration:none'>B</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:windowtext;text-decoration:none'>。</span></a></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:5.65pt;text-align:left;
text-autospace:none'><b><span style='font-size:14.0pt'>3.3 </span></b><b><span
lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>以页为单位管理物理内存</span></b></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在获得可用物理内存范围后，系统需要建立相应的数据结构来管理以物理页（按</span><span
style='font-size:12.0pt'>4KB</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>对齐，且大小为</span><span style='font-size:12.0pt'>4KB</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的物理内存单元）为最小单位的整个物理内存，以配合后续涉及的分页管理机制。每个物理页可以用一个</span><span
style='font-size:12.0pt'> Page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>数据结构来表示。由于一个物理页需要占用一个</span><span style='font-size:12.0pt'>Page</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>结构的空间，</span><span
style='font-size:12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>结构在设计时须尽可能小，以减少对内存的占用。</span><span style='font-size:12.0pt'>Page</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的定义在</span><span
style='font-size:12.0pt'>kern/mm/memlayout.h</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>中。以页为单位的物理内存分配管理的实现在</span><span
style='font-size:12.0pt'>kern/default_pmm.[ch]</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>为了与以后的分页机制配合，我们首先需要建立对整个计算机的每一个物理页的属性用结构</span><span
style='font-size:12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>来表示，它包含了映射此物理页的虚拟页个数，描述物理页属性的</span><span style='font-size:
12.0pt'>flags</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>和双向链接各个</span><span
style='font-size:12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>结构的</span><span style='font-size:12.0pt'>page_link</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>双向链表。</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:21.0pt'><span>&nbsp;</span></p>

<div align=center>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:27.95pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=447 valign=top style='width:446.5pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p><b><span style='font-size:10.0pt;font-family:Courier;color:navy'>struct</span></b><span
  style='font-size:10.0pt;font-family:Courier;color:gray'>&nbsp;</span><span
  style='font-size:10.0pt;font-family:Courier'>Page<span style='color:gray'>&nbsp;</span><b>{</b><span
  style='color:gray'><br>
  &nbsp;&nbsp;&nbsp;&nbsp;</span><b><span style='color:navy'>int</span></b><span
  style='color:gray'>&nbsp;</span>ref<b>;</b><span style='color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><i><span
  style='color:blue'>//&nbsp;page&nbsp;frame's&nbsp;reference&nbsp;counter<br>
  </span></i><span style='color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span>uint32_t<span
  style='color:gray'>&nbsp;</span>flags<b>;</b><span style='color:gray'>&nbsp;</span><i><span
  style='color:blue'>//&nbsp;array&nbsp;of&nbsp;flags&nbsp;that&nbsp;describe&nbsp;the&nbsp;status&nbsp;of&nbsp;the&nbsp;page&nbsp;frame<br>
  </span></i><span style='color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><b><span
  style='color:navy'>unsigned</span></b><span style='color:gray'>&nbsp;</span><b><span
  style='color:navy'>int</span></b><span style='color:gray'>&nbsp;</span>property<b>;</b><i><span
  style='color:blue'>//&nbsp;the&nbsp;num&nbsp;of&nbsp;free&nbsp;block,&nbsp;used&nbsp;in&nbsp;first&nbsp;fit&nbsp;pm&nbsp;manager<br>
  </span></i><span style='color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span>list_entry_t<span
  style='color:gray'>&nbsp;</span>page_link<b>;</b><i><span style='color:blue'>//&nbsp;free&nbsp;list&nbsp;link<br>
  </span></i><b>};</b></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:21.0pt'><span>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>这里看看</span><span
style='font-size:12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>数据结构的各个成员变量有何具体含义。</span><span style='font-size:12.0pt'>ref</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>表示这样页被页表的引用记数（在“实现分页机制”一节会讲到）。如果这个页被页表引用了，即在某页表中有一个页表项设置了一个虚拟页到这个</span><span
style='font-size:12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>管理的物理页的映射关系，就会把</span><span style='font-size:12.0pt'>Page</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的</span><span
style='font-size:12.0pt'>ref</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>加一；反之，若页表项取消，即映射关系解除，就会把</span><span style='font-size:12.0pt'>Page</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的</span><span
style='font-size:12.0pt'>ref</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>减一。</span><span style='font-size:12.0pt'>flags</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>表示此物理页的状态标记，进一步查看</span><span
style='font-size:12.0pt'>kern/mm/memlayout.h</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>中的定义，可以看到：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:19.6pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=482 valign=top style='width:17.0cm;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p><i><span style='font-size:10.0pt;font-family:Courier;color:blue'>/*&nbsp;Flags&nbsp;describing&nbsp;the&nbsp;status&nbsp;of&nbsp;a&nbsp;page&nbsp;frame&nbsp;*/</span></i><span
  style='font-size:10.0pt;font-family:Courier;color:gray'><br>
  </span><b><span style='font-size:10.0pt;font-family:Courier;color:green'>#define</span></b><span
  style='font-size:10.0pt;font-family:Courier;color:gray'>&nbsp;</span><span
  style='font-size:10.0pt;font-family:Courier'>PG_reserved<span
  style='color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='color:teal'>0</span><span style='color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><i><span
  style='color:blue'>//&nbsp;the&nbsp;page&nbsp;descriptor&nbsp;is&nbsp;reserved&nbsp;for&nbsp;kernel&nbsp;or&nbsp;unusable<br>
  </span></i><b><span style='color:green'>#define</span></b><span
  style='color:gray'>&nbsp;</span>PG_property<span style='color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='color:teal'>1</span><span style='color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><i><span
  style='color:blue'>//&nbsp;the&nbsp;member&nbsp;'property'&nbsp;is&nbsp;valid</span></i></span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>这表示</span><span
style='font-size:12.0pt'>flags</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>目前用到了两个</span><span style='font-size:12.0pt'>bit</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>表示页目前具有的两种属性，</span><span
style='font-size:12.0pt'>bit 0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>表示此页是否被保留（</span><span style='font-size:12.0pt'>reserved</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>），如果是被保留的页，则</span><span
style='font-size:12.0pt'>bit 0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>会设置为</span><span style='font-size:12.0pt'>1</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，且不能放到空闲页链表中，即这样的页不是空闲页，不能动态分配与释放。比如目前内核代码占用的空间就属于这样“被保留”的页。在本实验中，</span><span
style='font-size:12.0pt'>bit 1</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>表示此页是否是</span><span style='font-size:12.0pt'>free</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的，如果设置为</span><span
style='font-size:12.0pt'>1</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，表示这页是</span><span style='font-size:12.0pt'>free</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的，可以被分配；如果设置为</span><span
style='font-size:12.0pt'>0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，表示这页已经被分配出去了，不能被再二次分配。另外，本实验这里取的名字</span><span
style='font-size:12.0pt'>PG_property</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>比较不直观</span><span style='font-size:12.0pt'>&nbsp;</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，主要是我们可以设计不同的页分配算法（</span><span
style='font-size:12.0pt'>best fit, buddy system</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>等），那么这个</span><span style='font-size:
12.0pt'>PG_property</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>就有不同的含义了。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在本实验中，</span><span
style='font-size:12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>数据结构的成员变量</span><span style='font-size:12.0pt'>property</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>用来记录某连续内存空闲块的大小（即地址连续的空闲页的个数）。这里需要注意的是用到此成员变量的这个</span><span
style='font-size:12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>比较特殊，是这个连续内存空闲块地址最小的一页（即头一页，</span><span style='font-size:12.0pt'>
Head Page</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>）。连续内存空闲块利用这个页的成员变量</span><span
style='font-size:12.0pt'>property</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>来记录在此块内的空闲页的个数。这里去的名字</span><span style='font-size:12.0pt'>property</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>也不是很直观，原因与上面类似，在不同的页分配算法中，</span><span
style='font-size:12.0pt'>property</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>有不同的含义。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>Page</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>数据结构的成员变量</span><span
style='font-size:12.0pt'>page_link</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>是便于把多个连续内存空闲块链接在一起的双向链表指针（可回顾在</span><span
style='font-size:12.0pt'>lab0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>实验指导书中有关双向链表数据结构的介绍）。这里需要注意的是用到此成员变量的这个</span><span
style='font-size:12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>比较特殊，是这个连续内存空闲块地址最小的一页（即头一页，</span><span style='font-size:12.0pt'>
Head Page</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>）。连续内存空闲块利用这个页的成员变量</span><span
style='font-size:12.0pt'>page_link</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>来链接比它地址小和大的其他连续内存空闲块。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在初始情况下，也许这个物理内存的空闲物理页都是连续的，这样就形成了一个大的连续内存空闲块。但随着物理页的分配与释放，这个大的连续内存空闲块会分裂为一系列地址不连续的多个小连续内存空闲块，且每个连续内存空闲块内部的物理页是连续的。那么为了有效地管理这些小连续内存空闲块。所有的连续内存空闲块可用一个双向链表管理起来，便于分配和释放，为此定义了一个</span><span
style='font-size:12.0pt'>free_area_t</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>数据结构，包含了一个</span><span style='font-size:12.0pt'>list_entry</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>结构的双向链表指针和记录当前空闲页的个数的无符号整型变量</span><span
style='font-size:12.0pt'>nr_free</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>。其中的链表指针指向了空闲的物理页。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<div align=center>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:35.9pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=409 valign=top style='width:409.25pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span>/* free_area_t - maintains a doubly linked list to
  record free (unused) pages */</span></p>
  <p class=MsoNormal><span>typedef struct {</span></p>
  <p class=MsoNormal><span>            list_entry_t free_list;                                //
  the list header</span></p>
  <p class=MsoNormal><span>            unsigned int nr_free;                                 //
  # of free pages in this free list</span></p>
  <p class=MsoNormal><span>} free_area_t;</span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>有了这两个数据结构，</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>就可以管理起来整个以页为单位的物理内存空间。接下来需要解决两个问题：</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:54.0pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>管理页级物理内存空间所需的</span><span
style='font-size:12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>结构的内存空间从哪里开始，占多大空间？</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:54.0pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>空闲内存空间的起始地址在哪里？</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>对于这两个问题，我们首先根据</span><span
style='font-size:12.0pt'>bootloader</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>给出的内存布局信息找出最大的物理内存地址</span><span style='font-size:12.0pt'>maxpa</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>（定义在</span><span
style='font-size:12.0pt'>page_init</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数中的局部变量），由于</span><span style='font-size:12.0pt'>x86</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的起始物理内存地址为</span><span
style='font-size:12.0pt'>0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，所以可以得知需要管理的物理页个数为</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:60.3pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=427 valign=top style='width:426.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span>npage = maxpa / PGSIZE</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>这样，我们就可以预估出管理页级物理内存空间所需的</span><span
style='font-size:12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>结构的内存空间所需的内存大小为：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:60.3pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=427 valign=top style='width:426.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span>  sizeof(struct Page) * npage)</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>由于</span><span
style='font-size:12.0pt'>bootloader</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>加载</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的结束地址（用全局指针变量</span><span
style='font-size:12.0pt'>end</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>记录）以上的空间没有被使用，所以我们可以把</span><span style='font-size:12.0pt'>end</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>按页大小为边界去整后，作为管理页级物理内存空间所需的</span><span
style='font-size:12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>结构的内存空间，记为：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:60.3pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=427 valign=top style='width:426.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span>pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>为了简化起见，从地址</span><span
style='font-size:12.0pt'>0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>到地址</span><span style='font-size:12.0pt'>pages+ sizeof(struct
Page) * npage)</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>结束的物理内存空间设定为已占用物理内存空间（起始</span><span
style='font-size:12.0pt'>0~640KB</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的空间是空闲的），地址</span><span style='font-size:12.0pt'>pages+
sizeof(struct Page) * npage)</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>以上的空间为空闲物理内存空间，这时的空闲空间起始地址为</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:60.3pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=427 valign=top style='width:426.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span>uintptr_t freemem = PADDR((uintptr_t)pages +
  sizeof(struct Page) * npage);</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>为此我们需要把这两部分空间给标识出来。首先，对于所有物理空间，通过如下语句即可实现占用标记：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:60.3pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=427 valign=top style='width:426.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span>for (i = 0; i &lt; npage; i ++) {</span></p>
  <p class=MsoNormal><span>            <a name="OLE_LINK5">SetPageReserved</a>(pages
  + i);</span></p>
  <p class=MsoNormal><span>}</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>然后，根据探测到的空闲物理空间，通过如下语句即可实现空闲标记：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:60.3pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=427 valign=top style='width:426.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span>//</span><span lang=ZH-CN style='font-family:楷体'>获得空闲空间的起始地址</span><span>begin</span><span
  lang=ZH-CN style='font-family:楷体'>和结束地址</span><span>end</span></p>
  <p class=MsoNormal><span>……</span></p>
  <p class=MsoNormal><span>init_memmap(pa2page(begin), (end - begin) / PGSIZE);</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal><span>                         </span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>其实</span><span
style='font-size:12.0pt'>SetPageReserved</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>只需把物理地址对应的</span><span
style='font-size:12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>结构中的</span><span style='font-size:12.0pt'>flags</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>标志设置为</span><span
style='font-size:12.0pt'>PG_reserved </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>，表示这些页已经被使用了，将来不能被用于分配。而</span><span style='font-size:
12.0pt'>init_memmap</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>函数则是把空闲物理页对应的</span><span style='font-size:12.0pt'>Page</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>结构中的</span><span
style='font-size:12.0pt'>flags</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>和引用计数</span><span style='font-size:12.0pt'>ref</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>清零，并加到</span><span
style='font-size:12.0pt'>free_area.free_list</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>指向的双向列表中，为将来的空闲页管理做好初始化准备工作。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>关于内存分配的操作系统原理方面的知识有很多，但在本实验中只实现了最简单的内存页分配算法。相应的实现在</span><span
style='font-size:12.0pt'>default_pmm.c</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>中的</span><span style='font-size:12.0pt'>default_alloc_pages</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数和</span><span
style='font-size:12.0pt'>default_free_pages</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>函数，相关实现很简单，这里就不具体分析了，直接看源码，应该很好理解。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>其实实验二在内存分配和释放方面最主要的作用是建立了一个物理内存页管理器框架，这实际上是一个函数指针列表，定义如下：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:21.0pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=487 valign=top style='width:487.0pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span>struct pmm_manager {</span></p>
  <p class=MsoNormal><span>            const char *name; //</span><span
  style='font-family:楷体'>物理内存页管理器的名字</span></p>
  <p class=MsoNormal><span>            void (*init)(void); //</span><span
  style='font-family:楷体'>初始化内存管理器</span></p>
  <p class=MsoNormal><span>            void (*init_memmap)(struct Page *base,
  size_t n); //</span><span style='font-family:楷体'>初始化管理空闲内存页的数据结构</span></p>
  <p class=MsoNormal><span>            struct Page *(*alloc_pages)(size_t n);
  //</span><span style='font-family:楷体'>分配</span><span>n</span><span
  style='font-family:楷体'>个物理内存页</span></p>
  <p class=MsoNormal><span>            void (*free_pages)(struct Page *base,
  size_t n); //</span><span style='font-family:楷体'>释放</span><span>n</span><span
  style='font-family:楷体'>个物理内存页</span></p>
  <p class=MsoNormal><span>            size_t (*nr_free_pages)(void); //</span><span
  style='font-family:楷体'>返回当前剩余的空闲页数</span></p>
  <p class=MsoNormal><span>            void (*check)(void); //</span><span
  style='font-family:楷体'>用于检测分配</span><span>/</span><span style='font-family:
  楷体'>释放实现是否正确的辅助函数</span></p>
  <p class=MsoNormal><span>};</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>重点是实现</span><span
style='font-size:12.0pt'>init_memmap/ alloc_pages/ free_pages</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>这三个函数。当完成物理内存页管理初始化工作后，<a
name="OLE_LINK12"><a name="OLE_LINK11">计算机系统的内存布局</a>如下图所示：</a></span></p>

<p class=MsoNormal align=center style='margin-left:18.05pt;text-align:center;
text-indent:21.0pt'><span><img border=0 width=261 height=377 id="_x0000_i1025"
src="lab2.files/image003.png"></span></p>

<p class=MsoNormal align=center style='margin-left:18.05pt;text-align:center;
text-indent:24.0pt'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>图</span><span
style='font-size:12.0pt'>3  </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>计算机系统的内存布局</span></p>

<p class=MsoNormal align=left style='margin-left:5.65pt;text-align:left;
text-autospace:none'><b><span style='font-size:14.0pt'>3.4 </span></b><b><span
lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>物理内存页分配算法实现</span></b></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>如果要在</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中实现连续物理内存分配算法，则需要考虑的事情比较多，相对课本上的物理内存分配算法描述要复杂不少。下面介绍一下如果要实现一个</span><span
style='font-size:12.0pt'>FirstFit</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>内存分配算法的大致流程。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>lab2</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的第一部分是完成</span><span
style='font-size:12.0pt'>first_fit</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>的分配算法。原理</span><span style='font-size:12.0pt'>FirstFit</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>内存分配算法上很简单，但要在</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中实现，需要充分了解和利用</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>已有的数据结构和相关操作、关键的一些全局变量等。</span></p>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><b><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>关键数据结构和变量</span></b></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>first_fit</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>分配算法需要维护一个查找有序（地址按从小到大排列）空闲块（以页为最小单位的连续地址空间）的数据结构，而双向链表是一个很好的选择。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>libs/list.h</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>定义了可挂接任意元素的通用双向链表结构和对应的操作，所以需要了解如何使用这个文件提供的各种函数，从而可以完成对双向链表的初始化</span><span
style='font-size:12.0pt'>/</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>插入</span><span style='font-size:12.0pt'>/</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>删除等。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>kern/mm/memlayout.h</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中定义了一个</span><span
lang=ZH-CN style='font-size:12.0pt'> </span><a name="OLE_LINK23"><a
name="OLE_LINK22"><span style='font-size:12.0pt'>free_area_t </span></a></a><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>数据结构，包含成员结构</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:40.85pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=425 valign=top style='width:15.0cm;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
  none'><span style='font-size:10.0pt'>  list_entry_t free_list;         // the
  list header   </span><span style='font-size:10.0pt;font-family:楷体'>空闲块双向链表的头</span></p>
  <p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
  none'><span style='font-size:10.0pt'>  unsigned int nr_free;           // #
  of free pages in this free list  </span><span style='font-size:10.0pt;
  font-family:楷体'>空闲块的总数（以页为单位）</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>显然，我们可以通过此数据结构来完成对空闲块的管理。而</span><span
style='font-size:12.0pt'>default_pmm.c</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>中定义的</span><span style='font-size:12.0pt'>free_area</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>变量就是干这个事情的。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>kern/mm/pmm.h</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中定义了一个通用的分配算法的函数列表，用</span><span
style='font-size:12.0pt'>pmm_manager </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>表示。其中</span><span style='font-size:12.0pt'>init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数就是用来初始化</span><span
style='font-size:12.0pt'>free_area</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>变量的</span><span style='font-size:12.0pt'>, first_fit</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>分配算法可直接重用</span><span
style='font-size:12.0pt'>default_init</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数的实现。</span><span style='font-size:12.0pt'>init_memmap</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数需要根据现有的内存情况构建空闲块列表的初始状态。何时应该执行这个函数呢？</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>通过分析代码，可以知道：</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>kern_init --&gt;
pmm_init--&gt;page_init--&gt;init_memmap--&gt; pmm_manager-&gt;init_memmap</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>所以，</span><span
style='font-size:12.0pt'>default_init_memmap</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>需要根据</span><span style='font-size:12.0pt'>page_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数中传递过来的参数（某个连续地址的空闲块的起始页，页个数）来建立一个连续内存空闲块的双向链表。这里有一个假定</span><span
style='font-size:12.0pt'>page_init</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数是按地址从小到大的顺序传来的连续内存空闲块的。链表头是</span><span
style='font-size:12.0pt'>free_area.free_list</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>，链表项是</span><span style='font-size:
12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>数据结构的</span><span
style='font-size:12.0pt'>base-&gt;page_link</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>。这样我们就依靠</span><span style='font-size:
12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>数据结构中的成员变量</span><span
style='font-size:12.0pt'>page_link</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>形成了连续内存空闲块列表。</span></p>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><b><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>设计实现</span></b></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>default_init_memmap</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数讲根据每个物理页帧的情况来建立空闲页链表，且空闲页块应该是根据地址高低形成一个有序链表。根据上述变量的定义，</span><span
style='font-size:12.0pt'>default_init_memmap</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>可大致实现如下：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:5.7pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=520 valign=top style='width:519.8pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>default_init_memmap(struct
  Page *base, size_t n) {</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>    struct Page *p
  = base;</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>    for (; p !=
  base + n; p ++) {</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>       
  p-&gt;flags = p-&gt;property = 0;</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>       
  set_page_ref(p, 0);</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>    }</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>   
  base-&gt;property = n;</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>   
  SetPageProperty(base);</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>    nr_free += n;</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>   
  list_add(&amp;free_list, &amp;(base-&gt;page_link));</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>}</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>如果要分配一个页，那要考虑哪些呢？这里就需要考虑实现</span><span
style='font-size:12.0pt'>default_alloc_pages</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>函数，注意参数</span><span style='font-size:
12.0pt'>n</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>表示要分配</span><span
style='font-size:12.0pt'>n</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>个页。另外，需要注意实现时尽量多考虑一些边界情况，这样确保软件的鲁棒性。比如</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>    if (n &gt; nr_free) {</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>        return NULL;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>    }</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>这样可以确保分配不会超出范围。也可加一些</span><span
style='font-size:12.0pt'> assert</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数，在有错误出现时，能够迅速发现。比如</span><span style='font-size:12.0pt'> n</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>应该大于</span><span
style='font-size:12.0pt'>0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，我们就可以加上</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>   assert(n &gt; 0);</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>这样在</span><span
style='font-size:12.0pt'>n&lt;=0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的情况下，</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>会迅速报错。</span><span
style='font-size:12.0pt'>firstfit</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>需要从空闲链表头开始查找最小的地址，通过</span><span style='font-size:12.0pt'>list_next</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>找到下一个空闲块元素，通过</span><span
style='font-size:12.0pt'>le2page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>宏可以更加链表元素获得对应的</span><span style='font-size:12.0pt'>Page</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>指针</span><span
style='font-size:12.0pt'>p</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>。通过</span><span style='font-size:12.0pt'>p-&gt;property</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>可以了解此空闲块的大小。如果</span><span
style='font-size:12.0pt'>&gt;=n</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，这就找到了！如果</span><span style='font-size:12.0pt'>&lt;n</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，则</span><span
style='font-size:12.0pt'>list_next</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>，继续查找。直到</span><span style='font-size:12.0pt'>list_next==
&amp;free_list</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，这表示找完了一遍了。找到后，就要从新组织空闲块，然后把找到的</span><span
style='font-size:12.0pt'>page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>返回。所以</span><span style='font-size:12.0pt'>default_alloc_pages</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>可大致实现如下：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:5.7pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=520 valign=top style='width:519.8pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>static struct Page
  *</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>default_alloc_pages(size_t
  n) {</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>    if (n &gt;
  nr_free) {</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>        return
  NULL;</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>    }</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>    struct Page
  *page = NULL;</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>    list_entry_t
  *le = &amp;free_list;</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>    while ((le =
  list_next(le)) != &amp;free_list) {</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>        struct
  Page *p = le2page(le, page_link);</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>        if
  (p-&gt;property &gt;= n) {</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>            page =
  p;</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>            break;</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>        }</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>    }</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>    if (page !=
  NULL) {</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>       
  list_del(&amp;(page-&gt;page_link));</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>        if
  (page-&gt;property &gt; n) {</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>            struct
  Page *p = page + n;</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>           
  p-&gt;property = page-&gt;property - n;</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>           
  list_add(&amp;free_list, &amp;(p-&gt;page_link));</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>        }</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>        nr_free -=
  n;</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>       
  ClearPageProperty(page);</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>    }</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>    return page;</span></p>
  <p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
  0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
  17.9pt;text-autospace:none'><span style='font-size:11.0pt'>}</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>default_free_pages</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数的实现其实是</span><span
style='font-size:12.0pt'>default_alloc_pages</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>的逆过程，不过需要考虑空闲块的合并问题。这里就不再细讲了。注意，上诉代码只是参考设计，不是完整的正确设计。更详细的说明位于</span><span
style='font-size:12.0pt'>lab2/kernel/mm/default_pmm.c</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>的注释中。希望同学能够顺利完成本实验的第一部分。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:5.65pt;text-align:left;
text-autospace:none'><b><span style='font-size:14.0pt'>3.5 </span></b><b><span
lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>实现分页机制</span></b></p>

<h3 style='margin-top:8.0pt;margin-right:0cm;margin-bottom:8.0pt;margin-left:
368.1pt;text-indent:-368.1pt;line-height:normal'><span> </span><span>3.5.1 </span><span
lang=ZH-CN style='font-family:楷体'>段页式管理基本概念</span></h3>

<p class=MsoNormal style='margin-top:0cm;margin-right:3.05pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>如图</span><span style='font-size:12.0pt'>4</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在保护模式中，</span><span
style='font-size:12.0pt'>x86 </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>体系结构将内存地址分成三种：逻辑地址（也称虚地址）、线性地址和物理地址。逻辑地址即是程序指令中使用的地址，物理地址是实际访问内存的地址。逻</span><span
lang=ZH-CN style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>辑地址通过段式管理的地址映射可以得到线性地址，线性地址通过页式管理的地址映射得到物理地址。</span></p>

<p class=MsoNormal align=center style='margin-right:3.05pt;text-align:center;
line-height:17.9pt;text-autospace:none'>

<table cellpadding=0 cellspacing=0>
 <tr>
  <td width=34 height=0></td>
 </tr>
 <tr>
  <td></td>
  <td><img width=445 height=371 src="lab2.files/image004.png"></td>
 </tr>
</table>

<br clear=ALL>
<span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>图</span><span
lang=ZH-CN style='font-size:12.0pt'> </span><span style='font-size:12.0pt'>4  </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>段页式管理总体框架图</span></p>

<p class=MsoNormal align=left style='margin-top:.85pt;text-align:left;
line-height:13.0pt;text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:3.1pt;margin-bottom:0cm;
margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>段式管理前一个实验已经讨论过。在</span><span
style='font-size:12.0pt'> ucore </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中段式管理只起到了一个过渡作用，它将逻辑地址不加转换直接映射成线性地址，所以我们在下面的讨论中可以对这两个地址不加区分（目前的</span><span
style='font-size:12.0pt'> OS </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>实现也是不加区分的）。对段式管理有兴趣的同学可以参照《</span><span style='font-size:12.0pt'>Intel</span><span
style='font-size:12.0pt'>®</span><span style='font-size:12.0pt'>  64 and
IA-32Architectures Software Developer ’s Manual – Volume 3A</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>》</span><span
style='font-size:12.0pt'>3.2 </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>节。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:2.6pt;margin-bottom:0cm;
margin-left:9.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='position:absolute;z-index:251606517;
left:0px;margin-left:153px;margin-top:67px;width:9px;height:5px'><img width=9
height=5 src="lab2.files/image005.png"></span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>如图</span><span style='font-size:12.0pt'>5</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>所示，页式管理将线性地址分成三部分（图中的</span><span
style='font-size:12.0pt'> Linear Address </span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>的</span><span style='font-size:12.0pt'>
Directory </span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>部分、</span><span
style='font-size:12.0pt'> Table </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>部分和</span><span style='font-size:12.0pt'> Offset </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>部分）。</span><span
style='font-size:12.0pt'>ucore </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的页式管理通过一个二级的页表实现。一级页表的起始物理地址存放在</span><span style='font-size:
12.0pt'> cr3 </span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>寄存器中，这个地址必须是一个页对齐的地址，也就是低</span><span
style='font-size:12.0pt'> 12 </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>位必须为</span><span style='font-size:12.0pt'> 0</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>。目前，</span><span
style='font-size:12.0pt'>ucore </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>用</span><span style='font-size:12.0pt'>boot_cr3</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>（</span><span
style='font-size:12.0pt'>mm/pmm.c</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>）记录这个值。</span></p>

<p class=MsoNormal align=center style='margin-top:0cm;margin-right:2.6pt;
margin-bottom:0cm;margin-left:9.7pt;margin-bottom:.0001pt;text-align:center;
text-indent:23.9pt;line-height:17.9pt;text-autospace:none'><span
style='font-size:12.0pt;color:black'>&nbsp;</span></p>

<p class=MsoNormal align=center style='margin-top:0cm;margin-right:2.6pt;
margin-bottom:0cm;margin-left:9.7pt;margin-bottom:.0001pt;text-align:center;
text-indent:23.9pt;line-height:17.9pt;text-autospace:none'><span
style='font-size:12.0pt;color:black'>&nbsp;</span></p>

<p class=MsoNormal align=center style='margin-top:0cm;margin-right:2.6pt;
margin-bottom:0cm;margin-left:9.7pt;margin-bottom:.0001pt;text-align:center;
text-indent:23.9pt;line-height:17.9pt;text-autospace:none'><img width=497
height=269 src="lab2.files/image006.png" align=left hspace=9><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:black'>图</span><span lang=ZH-CN
style='font-size:12.0pt;color:black;letter-spacing:-2.95pt'> </span><span
style='font-size:12.0pt;color:black'>5<span style='letter-spacing:.9pt'> </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black;letter-spacing:
.9pt'>分页机制</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black;letter-spacing:.05pt'>管</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体;color:black'>理</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:9.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<h3 style='margin-top:8.0pt;margin-right:0cm;margin-bottom:8.0pt;margin-left:
368.1pt;text-indent:-368.1pt;line-height:normal'><span> </span><span>3.5.2</span><span
lang=ZH-CN style='font-family:楷体'>建立段页式管理中需要考虑的关键问题</span></h3>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>为了实现分页机制，需要建立好虚拟内存和物理内存的页映射关系，即正确建立二级页表。此过程涉及硬件细节，不同的地址映射关系组合，相对比较复杂。总体而言，我们需要思考如下问题：</span></p>

<p class=MsoNormal style='margin-left:66.4pt;text-indent:-21.0pt'><span
style='font-size:12.0pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>如何在建立页表的过程中维护全局段描述符表（</span><span
style='font-size:12.0pt'>GDT</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>）和页表的关系，确保</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>能够在各个时间段上都能正常寻址？</span></p>

<p class=MsoNormal style='margin-left:66.4pt;text-indent:-21.0pt'><span
style='font-size:12.0pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>对于哪些物理内存空间需要建立页映射关系？</span></p>

<p class=MsoNormal style='margin-left:66.4pt;text-indent:-21.0pt'><span
style='font-size:12.0pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>具体的页映射关系是什么？</span></p>

<p class=MsoNormal style='margin-left:66.4pt;text-indent:-21.0pt'><span
style='font-size:12.0pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>页目录表的起始地址设置在哪里？</span></p>

<p class=MsoNormal style='margin-left:66.4pt;text-indent:-21.0pt'><span
style='font-size:12.0pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>页表的起始地址设置在哪里，需要多大空间？</span></p>

<p class=MsoNormal style='margin-left:66.4pt;text-indent:-21.0pt'><span
style='font-size:12.0pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>如何设置页目录表项的内容？</span></p>

<p class=MsoNormal style='margin-left:66.4pt;text-indent:-21.0pt'><span
style='font-size:12.0pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>如何设置页表项的内容？</span></p>

<h3 style='margin-top:8.0pt;margin-right:0cm;margin-bottom:8.0pt;margin-left:
368.1pt;text-indent:-368.1pt;line-height:normal'><span> </span><span>3.5.3</span><span
lang=ZH-CN style='font-family:楷体'>建立虚拟页和物理页帧的地址映射关系</span></h3>

<p class=MsoNormal><span style='font-size:12.0pt'>    </span><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>从链接脚本分析</span></b><b><span
style='font-size:12.0pt'>ucore</span></b><b><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>执行时的地址</span></b></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>首先观察一下</span><span
style='font-size:12.0pt'>tools/kernel.ld</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>文件在</span><span style='font-size:12.0pt'>lab1</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>和</span><span
style='font-size:12.0pt'>lab2</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中的区别。在</span><span style='font-size:12.0pt'>lab1</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:55.05pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=390 valign=top style='width:389.55pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:10.0pt'>ENTRY(kern_init)</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>SECTIONS {</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>            /* Load the
  kernel at this address: &quot;.&quot; means the current address */</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>            . = 0x100000;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>            .text : {</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>                        *(.text
  .stub .text.* .gnu.linkonce.t.*)</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>            }</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:30.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>这意味着在</span><span
style='font-size:12.0pt'>lab1</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中通过</span><span style='font-size:12.0pt'>ld</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>工具形成的</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的起始虚拟地址从</span><span style='font-size:12.0pt'>0x100000</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>开始，<a name="OLE_LINK25"><a
name="OLE_LINK24">注意：这个地址是虚拟地址。</a>但由于</a></span><span style='font-size:12.0pt'>lab1</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中建立的段地址映射关系为对等关系，所以</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的物理地址也是</span><span style='font-size:12.0pt'>0x100000</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>。而入口函数为</span><span
style='font-size:12.0pt'>kern_init</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数。在</span><span style='font-size:12.0pt'>lab2</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:55.05pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=390 valign=top style='width:389.55pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:10.0pt'>ENTRY(kern_entry)</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>SECTIONS {</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>            /* Load the
  kernel at this address: &quot;.&quot; means the current address */</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>            . = 0xC0100000;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>            .text : {</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>                        *(.text
  .stub .text.* .gnu.linkonce.t.*)</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>            }</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:21.0pt'>   <span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>这意味着</span><span
style='font-size:12.0pt'>lab2</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中通过</span><span style='font-size:12.0pt'>ld</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>工具形成的</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的起始虚拟地址从</span><span style='font-size:12.0pt'>0xC0100000</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>开始，注意：这个地址也是虚拟地址。入口函数为</span><span
style='font-size:12.0pt'>kern_entry</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数。这与</span><span style='font-size:12.0pt'>lab1</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>有很大差别。但其实在</span><span
style='font-size:12.0pt'>lab1</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>和</span><span style='font-size:12.0pt'>lab2</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中，</span><span
style='font-size:12.0pt'>bootloader</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>把</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>都放在了起始物理地址为</span><span
style='font-size:12.0pt'>0x100000</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的物理内存空间。这实际上说明了</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在</span><span
style='font-size:12.0pt'>lab1</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>和</span><span style='font-size:12.0pt'>lab2</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中采用的地址映射不同：</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>lab1</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>：</span><span lang=ZH-CN style='font-size:12.0pt'> </span><span
style='font-size:12.0pt'>&nbsp;virtual addr = linear addr = phy addr</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>lab2</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>：</span><span style='font-size:12.0pt'>  virtual addr = linear
addr = phy addr + 0xC0000000</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>lab1</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>只采用了段映射机制，但在</span><span style='font-size:12.0pt'>lab2</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中，启动好分页管理机制后，形成的是段页式映射机制，从而使得虚拟地址空间和物理地址空间之间存在如下的映射关系：</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>   Virtual Address=LinearAddress=0xC0000000+Physical
Address</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>   </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>另外，</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的入口地址也改为了</span><span
style='font-size:12.0pt'>kern_entry</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数，这个函数位于</span><span style='font-size:12.0pt'>init/entry.S</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中，分析代码可以看出，</span><span
style='font-size:12.0pt'>entry.S</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>重新建立了段映射关系，从以前的</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>   Virtual Address= Linear Address</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>改为</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>   Virtual Address=Linear Address-0xC0000000</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>由于</span><span
style='font-size:12.0pt'>gcc</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>编译出的虚拟起始地址从</span><span style='font-size:12.0pt'>0xC0100000</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>开始，</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>被</span><span style='font-size:12.0pt'>bootloader</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>放置在从物理地址</span><span
style='font-size:12.0pt'>0x100000</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>处开始的物理内存中。所以当</span><span style='font-size:12.0pt'>kern_entry</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数完成新的段映射关系后，且</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>在没有建立好页映射机制前，</span><span style='font-size:12.0pt'>CPU</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>按照</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中的虚拟地址执行，能够被分段机制映射到正确的物理地址上，确保</span><span style='font-size:
12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>运行正确。</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>由于物理内存页管理器管理了从</span><span
style='font-size:12.0pt'>0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>到实际可用物理内存大小的物理内存空间，所以对于这些物理内存空间都需要建立好页映射关系。由于目前</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>只运行在内核空间，所以可以建立一个一一映射关系。假定内核虚拟地址空间的起始地址为</span><span
style='font-size:12.0pt'>0xC0000000</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>，则虚拟内存和物理内存的具体页映射关系为：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:45.4pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=487 valign=top style='width:487.0pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span>Virtual Address=Physical Address+0xC0000000 </span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>建立二级页表</span></b></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>由于我们已经具有了一个物理内存页管理器</span><span
style='font-size:12.0pt'>default_pmm_manager</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>，我们就可以用它来获得所需的空闲物理页。在二级页表结构中，页目录表占</span><span
style='font-size:12.0pt'>4KB</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>空间，</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>就可通过</span><span
style='font-size:12.0pt'>default_pmm_manager</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>的</span><span style='font-size:12.0pt'>default_alloc_pages</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数获得一个空闲物理页，这个页的起始物理地址就是页目录表的起始地址。同理，</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>也通过这种方式获得各个页表所需的空间。页表的空间大小取决与页表要管理的物理页数</span><span
style='font-size:12.0pt'>n</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，一个页表项（</span><span style='font-size:12.0pt'>32</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>位，即</span><span
style='font-size:12.0pt'>4</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>字节）可管理一个物理页，页表需要占</span><span style='font-size:12.0pt'>n/256</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>个物理页空间。这样页目录表和页表所占的总大小为</span><span
style='font-size:12.0pt'>4096+1024*n</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>字节。</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>为把</span><span
style='font-size:12.0pt'>0~KERNSIZE</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>（明确</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>设定实际物理内存不能超过</span><span
style='font-size:12.0pt'>KERNSIZE</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>值，即</span><span style='font-size:12.0pt'>0x38000000</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>字节，</span><span
style='font-size:12.0pt'>896MB</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，</span><span style='font-size:12.0pt'>3670016</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>个物理页）的物理地址一一映射到页目录表项和页表项的内容，其大致流程如下：</span></p>

<p class=MsoNormal style='margin-left:66.4pt;text-indent:-21.0pt'><span
style='font-size:12.0pt'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>先通过</span><span
style='font-size:12.0pt'>default_pmm_manager</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>获得一个空闲物理页，用于页目录表；</span></p>

<p class=MsoNormal style='margin-left:66.4pt;text-indent:-21.0pt'><span
style='font-size:12.0pt'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>调用</span><a
name="OLE_LINK8"><a name="OLE_LINK7"><a name="OLE_LINK20"><span
style='font-size:12.0pt'>boot_map_segmen</span></a></a></a><span
style='font-size:12.0pt'>t</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数建立一一映射关系，具体处理过程以页为单位进行设置，即</span></p>

<p class=MsoNormal style='margin-left:39.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>Virtual Address=Physical Address+0xC0000000</span></p>

<p class=MsoNormal style='margin-left:87.4pt;text-indent:-21.0pt'><span
style='font-size:12.0pt;font-family:Wingdings'>Ø<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>设一个逻辑地址</span><span
style='font-size:12.0pt'>la</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>（按页对齐，故低</span><span style='font-size:12.0pt'>12</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>位为零）对应的物理地址</span><span
style='font-size:12.0pt'>pa</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>（按页对齐，故低</span><span style='font-size:12.0pt'>12</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>位为零），如果在页目录表项（</span><span
style='font-size:12.0pt'>la</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的高</span><span style='font-size:12.0pt'>10</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>位为索引值）中的存在位（</span><span
style='font-size:12.0pt'>PTE_P</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>）为</span><span style='font-size:12.0pt'>0</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，表示缺少对应的页表空间，则可通过</span><span
style='font-size:12.0pt'>default_pmm_manager</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>获得一个空闲物理页给页表，页表起始物理地址是按</span><span
style='font-size:12.0pt'>4096</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>字节对齐的，这样填写页目录表项的内容为</span></p>

<p class=MsoNormal style='margin-left:57.1pt;text-indent:45.45pt'><b><i><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>页目录表项内容</span></i></b><b><i><span
style='font-size:12.0pt'> = </span></i></b><b><i><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>页表起始物理地址</span></i></b><b><i><span
style='font-size:12.0pt'>| PTE_U | PTE_W | PTE_P </span></i></b></p>

<p class=MsoNormal style='margin-left:66.4pt'><span style='font-size:12.0pt'>   
</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>进一步对于页表中对应页表项（</span><span
style='font-size:12.0pt'>la</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的中</span><span style='font-size:12.0pt'>10</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>位为索引值）的内容为</span></p>

<p class=MsoNormal style='margin-left:45.4pt'><span style='font-size:12.0pt'>          
        </span><b><i><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>页表项内容</span></i></b><b><i><span
style='font-size:12.0pt'> =  pa | PTE_P | PTE_W</span></i></b></p>

<p class=MsoNormal style='margin-left:45.4pt'><span style='font-size:12.0pt'>       
</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>其中：</span></p>

<p class=MsoNormal style='margin-left:127.45pt;text-indent:-21.0pt'><span
style='font-size:12.0pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-size:12.0pt'>PTE_U</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>：位</span><span style='font-size:12.0pt'>3</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，表示用户态的软件可以读取对应地址的物理内存页内容</span></p>

<p class=MsoNormal style='margin-left:127.45pt;text-indent:-21.0pt'><span
style='font-size:12.0pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-size:12.0pt'>PTE_W</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>：位</span><span style='font-size:12.0pt'>2</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，表示物理内存页内容可写</span></p>

<p class=MsoNormal style='margin-left:127.45pt;text-indent:-21.0pt'><span
style='font-size:12.0pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-size:12.0pt'>PTE_P</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>：位</span><span style='font-size:12.0pt'>1</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，表示物理内存页存在</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>ucore </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的内存管理经常需要查找页表：给定一个虚拟地址，找出这个虚拟地址在二级页表中对应的项。通过更改此项的值可以方便地将虚拟地址映射到另外的页上。可完成此功能的这个函数是</span><span
style='font-size:12.0pt'>get_pte</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数。它的原型为</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:40.85pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=404 valign=top style='width:404.0pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='margin-top:1.85pt;text-align:left;
  line-height:12.0pt;text-autospace:none'><span>pte_t  *get_pte (pde_t *pgdir, 
  uintptr_t la, bool  create)</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>下面的<a name="OLE_LINK21">调用关系图</a>可以比较好地看出</span><span
style='font-size:12.0pt'>get_pte</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>在实现上诉流程中的位置：</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'><img border=0 width=465 height=280 id="_x0000_i1026"
src="lab2.files/image007.png"></span></p>

<p class=MsoNormal align=center style='margin-left:18.05pt;text-align:center;
text-indent:24.0pt'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>图</span><span
style='font-size:12.0pt'>6  get_pte</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>调用关系图</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>这里涉及到三个类型</span><span
style='font-size:12.0pt'>pte t</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>、</span><span style='font-size:12.0pt'>pde t</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>和</span><span
style='font-size:12.0pt'>uintptr t</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>。通过参见</span><span style='font-size:12.0pt'>mm/mmlayout.h</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>和</span><span
style='font-size:12.0pt'>libs/types.h</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>，可知它们其实都是</span><span style='font-size:12.0pt'>unsigned 
int</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>类型。在此做区分，是为了分清概念。</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>pde_t</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>全称为</span><span style='font-size:12.0pt'> page directory entry</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，也就是一级页表的表项（注意：</span><span
style='font-size:12.0pt'>pgdir</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>实际不是表</span><span lang=ZH-CN style='font-size:12.0pt'> </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>项，而是一级页表本身。实际上应该新定义一个类型</span><span
style='font-size:12.0pt'>pgd_t</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>来表示一级页表本身）。</span><span style='font-size:12.0pt'>pte t</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>全</span><span lang=ZH-CN
style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>称为</span><span style='font-size:12.0pt'> page table entry</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，表示二级页表的表项。</span><span
style='font-size:12.0pt'>uintptr t</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>表示为线性地址，由于段式管理只做直接映射，所以它也是逻辑地址。</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>pgdir</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>给出页表起始地址。通过查找这个页表，我们需要给出二级页表中对应项的地址。</span><span lang=ZH-CN
style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>虽然目前我们只有</span><span style='font-size:12.0pt'>boot_pgdir</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>一个页表，但是引入进程的概念之后每个进程都会有自己的页</span><span
lang=ZH-CN style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>表。</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>有可能根本就没有对应的二级页表的情况，所以二级页表不必要一开始就分配，而是等到需要的时候再添加对应的二级页表。如果在查找二级页表项时，发现对应的二级页表不存在，则需要根据</span><span
style='font-size:12.0pt'>create</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>参数的值来处理是否创建新的二级页表。如果</span><span style='font-size:12.0pt'>create</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>参数为</span><span
style='font-size:12.0pt'>0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，则</span><span style='font-size:12.0pt'>get_pte</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>返回</span><span
style='font-size:12.0pt'>NULL</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>；如果</span><span style='font-size:12.0pt'>create</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>参数不为</span><span
style='font-size:12.0pt'>0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，则</span><span style='font-size:12.0pt'>get_pte</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>需要申请一个新的物理页（通过</span><span
style='font-size:12.0pt'>alloc_page</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>来实现，可在</span><span style='font-size:12.0pt'>mm/pmm.h</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中找到它的定义），再在一级页表中添加页目录表项指向表示二级页表的新物理页。注意，新申请的页必须全部设定为零，因为这个页所代表的虚拟地址都没有被映射。</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>当建立从一级页表到二级页表的映射时，需要注意设置控制位。这里应该设置同时设置</span><span
lang=ZH-CN style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>上</span><span style='font-size:12.0pt'>PTE_U</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>、</span><span
style='font-size:12.0pt'>PTE_W</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>和</span><span style='font-size:12.0pt'>PTE_P</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>（定义可在</span><span
style='font-size:12.0pt'>mm/mmu.h</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>）。如果原来就有二级页表，或者新建立了页表，则只需返回对应项的地址即可。</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>虚拟地址只有映射上了物理页才可以正常的读写。在完成映射物理页的过程中，除了要象上面那样在页表的对应表项上填上相应的物理地址外，还要设置正确的控制位。有关</span><span
style='font-size:12.0pt'> x86 </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中页表控制位的详细信息，请参照《</span><span style='font-size:12.0pt'>Intel</span><span
style='font-size:12.0pt'>®</span><span style='font-size:12.0pt'> 64 and IA-32
Architectures Software Developer ’s Manual – Volume 3A</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>》</span><span style='font-size:12.0pt'>4.11
</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>节。</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>只有当一级二级页表的项都设置了用户写权限后，用户才能对对应的物理地址进行读写。</span><span
lang=ZH-CN style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>所以我们可以在一级页表先给用户写权限，再在二级页表上面根据需要限制用户的权限，对物理页进行保护。由于一个物理页可能被映射到不同的虚拟地址上去（譬如一块内存在不同进程</span><span
lang=ZH-CN style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>间共享），当这个页需要在一个地址上解除映射时，操作系统不能直接把这个页回收，而是要先看看它还有没有映射到别的虚拟地址上。这是通过查找管理该物理页的</span><span
style='font-size:12.0pt'>Page</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>数据结构的成员变量</span><span style='font-size:12.0pt'>ref</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>（用来表示虚拟页到物理页的映射关系的个数）来实现的，如果</span><span
style='font-size:12.0pt'>ref</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>为</span><span style='font-size:12.0pt'>0</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>了，表示没有虚拟页到物理页的映射关系了，就可以把这个物理页给回收了，从而这个物理页是</span><span
style='font-size:12.0pt'>free</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的了，可以再被分配。</span><span style='font-size:12.0pt'>page_insert</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数将物理页映射在了页表上。可参看</span><span
style='font-size:12.0pt'>page_insert</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数的实现来了解</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>内核是如何维护这个变量的。当不需要再访问这块虚拟地址时，可以把这块物理页回收并在将来用在其他地方。取消映射由</span><span
style='font-size:12.0pt'>page_remove</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>来做，这其实是</span><span style='font-size:12.0pt'>page insert</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的逆操作。</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>建立好一一映射的二级页表结构后，接下来就要使能分页机制了，这主要是通过</span><span
style='font-size:12.0pt'>enable_paging</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数实现的，这个函数主要做了两件事：</span></p>

<p class=MsoNormal style='margin-left:148.45pt;text-indent:-69.15pt'><span
style='font-size:12.0pt'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>通过</span><span
style='font-size:12.0pt'>lcr3</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>指令把页目录表的起始地址存入</span><span style='font-size:12.0pt'>CR3</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>寄存器中；</span></p>

<p class=MsoNormal style='margin-left:148.45pt;text-indent:-69.15pt'><span
style='font-size:12.0pt'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>通过</span><span
style='font-size:12.0pt'>lcr0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>指令把</span><span style='font-size:12.0pt'>cr0</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中的</span><span
style='font-size:12.0pt'>CR0_PG</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>标志位设置上。</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>执行完</span><a name="OLE_LINK6"><span
style='font-size:12.0pt'>enable_paging</span></a><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>函数后，计算机系统进入了分页模式！但到这一步还不够，还记得</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>在最开始通过</span><span style='font-size:12.0pt'>kern_entry</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数设置了临时的新段映射机制吗？这个临时的新段映射机制不是最简单的对等映射，导致虚拟地址和线性地址不相等。而刚才建立的页映射关系是建立在简单的段对等映射，即虚拟地址</span><span
style='font-size:12.0pt'>=</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>线性地址的假设基础之上的。所以我们需要进一步调整段映射关系，即重新设置新的</span><span
style='font-size:12.0pt'>GDT</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，建立对等段映射。</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>这里需要注意：在进入分页模式到重新设置新</span><span
style='font-size:12.0pt'>GDT</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的过程是一个过渡过程。在这个过渡过程中，已经建立了页表机制，所以通过现在的段机制和页机制实现的地址映射关系为：</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>&nbsp;</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:40.85pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=446 valign=top style='width:446.15pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span>Virtual Address=Linear Address + 0xC0000000 =
  Physical Address +0xC0000000+0xC0000000</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>在这个特殊的阶段，如果不把段映射关系改为</span><span
style='font-size:12.0pt'>Virtual Address = Linear Address</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，则通过段页式两次地址转换后，无法得到正确的物理地址。为此我们需要进一步调用</span><span
style='font-size:12.0pt'>gdt_init</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数，根据新的</span><span style='font-size:12.0pt'>gdt</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>全局段描述符表内容（</span><span
style='font-size:12.0pt'>gdt</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>定义位于</span><span style='font-size:12.0pt'>pmm.c</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中），恢复以前的段映射关系，即使得</span><span
style='font-size:12.0pt'>Virtual Address = Linear Address</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>。这样在执行完</span><span
style='font-size:12.0pt'>gdt_init</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>后，通过的段机制和页机制实现的地址映射关系为：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:40.85pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=446 valign=top style='width:446.15pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span>Virtual Address=Linear Address = Physical Address
  +0xC0000000</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>这里存在的一个问题是，在调用</span><span
style='font-size:12.0pt'>enable_page</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数使能分页机制后到执行完毕</span><span style='font-size:12.0pt'>gdt_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数重新建立好段页式映射机制的过程中，内核使用的还是旧的段表映射，也就是说，</span><span
style='font-size:12.0pt'>enable paging </span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>之后，内核使用的是页表的低地址</span><span
style='font-size:12.0pt'> entry</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>。</span><span lang=ZH-CN style='font-size:12.0pt'> </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>如何保证此时内核依然能够正常工作呢？其实只需让低地址目录表项的内容等于以</span><span
style='font-size:12.0pt'>KERNBASE</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>开始的高地址目录表项的内容即可。目前内核大小不超过</span><span style='font-size:12.0pt'>
4M </span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>（实际上是</span><span
style='font-size:12.0pt'>3M</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，因为内核从</span><span style='font-size:12.0pt'> 0x100000 </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>开始编址），这样就只需要让页表在</span><span
style='font-size:12.0pt'>0~4MB</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的线性地址与</span><span style='font-size:12.0pt'>KERNBASE ~
KERNBASE+4MB</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的线性地址获得相同的映射即可，都映射到</span><span
style='font-size:12.0pt'> 0~4MB </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的物理地址空间，具体实现在</span><span style='font-size:12.0pt'>pmm.c</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中</span><span
style='font-size:12.0pt'>pmm_init</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数的语句：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:40.85pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=446 valign=top style='width:446.15pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span>boot_pgdir[0] = boot_pgdir[PDX(KERNBASE)];</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal><span style='font-size:12.0pt'>            </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>实际上这种映射也限制了内核的大小。当内核大小超过预期的</span><span
style='font-size:12.0pt'>3MB </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>就可能导致打开分页之后内核</span><span style='font-size:12.0pt'> crash</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，在后面的试验中，也的确出现了这种情况。解决方法同样简单，就是拷贝更多的高地址项到低地址。</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>当执行完毕</span><span style='font-size:
12.0pt'>gdt_init</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>函数后，新的段页式映射已经建立好了，上面的</span><span style='font-size:12.0pt'>0~4MB</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的线性地址与</span><span
style='font-size:12.0pt'>0~4MB</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的物理地址一一映射关系已经没有用了。所以可以通过如下语句解除这个老的映射关系。</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:47.95pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=439 valign=top style='width:439.05pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span>boot_pgdir[0] = 0;</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>在</span><span style='font-size:12.0pt'>page_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数建立完实现物理内存一一映射和页目录表自映射的页目录表和页表后，一旦使能分页机制，则</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>看到的内核虚拟地址空间如下图所示：</span></p>

<p class=MsoNormal align=center style='margin-left:45.4pt;text-align:center'><span
style='font-size:12.0pt;color:red'><img border=0 width=353 height=194
id="Picture 4" src="lab2.files/image008.png" alt="说明: proj5-vm-map"></span></p>

<p class=MsoNormal align=center style='margin-left:45.4pt;text-align:center'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>图</span><span
style='font-size:12.0pt'>7  </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>使能分页机制后的虚拟地址空间图</span></p>

<p class=MsoNormal><span>&nbsp;</span></p>

<h3 style='margin-top:8.0pt;margin-right:0cm;margin-bottom:8.0pt;margin-left:
368.1pt;text-indent:-368.1pt;line-height:normal'><span> </span><span>3.5.4</span><span
lang=ZH-CN style='font-family:楷体'>不同运行阶段的地址映射关系</span></h3>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在大多数课本中，描述了基于段的映射关系，基于页的映射关系以及基于段页式的映射关系和</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>访存时对应的地址转换过程。但很少涉及操作系统如何一步一步建立这个映射关系的。其实，在</span><span
style='font-size:12.0pt'>lab1</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>和</span><span style='font-size:12.0pt'>lab2</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中都会涉及如何建立映射关系的操作。在</span><span
style='font-size:12.0pt'>lab1</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中，我们已经碰到到了简单的段映射，即对等映射关系，保证了物理地址和虚拟地址相等，也就是通过建立全局段描述符表，让每个段的基址为</span><span
style='font-size:12.0pt'>0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，从而确定了对等映射关系。</span></p>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在</span><span
style='font-size:12.0pt'>lab2</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中，由于在段地址映射的基础上进一步引入了页地址映射，形成了组合式的段页式地址映射。这种方式虽然更加灵活了，但实现的复杂性也增加了。在</span><span
style='font-size:12.0pt'>lab2</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中，</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>从计算机加电，启动段式管理机制，启动段页式管理机制，在段页式管理机制下运行这整个过程中，虚地址到物理地址的映射产生了多次变化，接下来我们会逐一进行说明。</span></p>

<p class=MsoListParagraph style='margin-left:63.05pt;text-indent:-21.0pt'><span
style='font-size:12.0pt'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>首先是</span><span
style='font-size:12.0pt'>bootloader</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>地址映射阶段，</span><span style='font-size:12.0pt'>bootloader</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>完成了与</span><span
style='font-size:12.0pt'>lab1</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>一样的工作，即建立了基于段的对等映射（请查看</span><span style='font-size:12.0pt'>lab2/boot/bootasm.S</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中的</span><span
style='font-size:12.0pt'>finish_probe</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>地址处）；</span></p>

<p class=MsoListParagraph style='margin-left:63.05pt;text-indent:-21.0pt'><span
style='font-size:12.0pt'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>接着进入了</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>启动页机制前的地址映射阶段，</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>建立了一个一一段映射关系，其中虚拟地址</span><span
style='font-size:12.0pt'> = </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>物理地址</span><span style='font-size:12.0pt'> + 0xC0000000</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>（请查看</span><span
style='font-size:12.0pt'>lab2/kern/init/entry.S</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>中的</span><span style='font-size:12.0pt'>kern_entry</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数）；</span></p>

<p class=MsoListParagraph style='margin-left:63.05pt;text-indent:-21.0pt'><span
style='font-size:12.0pt'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>再接下来是建立并使能页表的临时段页式地址映射阶段，页表要表示的是线性地址与物理地址的对应关系为：线性地址</span><span
style='font-size:12.0pt'> = </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>物理地址</span><span style='font-size:12.0pt'> + 0xC0000000</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>；然后这里有一个小技巧，让在</span><span
style='font-size:12.0pt'>0~4MB</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的线性地址区域空间的</span><span lang=ZH-CN style='font-size:12.0pt'> </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>线性地址</span><span lang=ZH-CN
style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>（</span><span style='font-size:12.0pt'>0~4MB</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>）对应的物理地址</span><span
style='font-size:12.0pt'> = </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>线性地址</span><span lang=ZH-CN style='font-size:12.0pt'> </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>（</span><span
style='font-size:12.0pt'>0xC0000000~0xC0000000 + 4MB</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>）对应的物理地址，这是通过</span><span
style='font-size:12.0pt'>lab2/kern/mm/pmm.c</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>中第</span><span style='font-size:12.0pt'>321</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>行的代码实现的：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:83.4pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=376 valign=top style='width:375.6pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p><span style='font-size:10.0pt;font-family:Courier'>boot_pgdir<b>[</b><span
  style='color:teal'>0</span><b>]</b><span style='color:gray'>&nbsp;</span><b>=</b><span
  style='color:gray'>&nbsp;</span>boot_pgdir<b>[</b>PDX<b>(</b>KERNBASE<b>)];</b></span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-left:18.05pt;text-indent:24.0pt'><span
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:63.65pt;text-indent:.1pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>注意此时</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>在寻址时还是只采用了分段机制。最后后并使能分页映射机制（请查看</span><span style='font-size:
12.0pt'>lab2/kern/mm/pmm.c</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中的</span><span style='font-size:12.0pt'>enable_paging</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数），一旦执行完</span><span
style='font-size:12.0pt'>enable_paging</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数中的加载</span><span style='font-size:12.0pt'>cr0</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>指令（即让</span><span
style='font-size:12.0pt'>CPU</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>使能分页机制），则接下来的访问是基于段页式的映射关系了。对于（</span><span style='font-size:
12.0pt'>0xC0000000~0xC0000000 + 4MB</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>）这块虚拟地址空间，最终会映射到哪些物理地址空间中呢？</span></p>

<p class=MsoNormal style='margin-left:63.65pt;text-indent:.1pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>由于段映射关系没有改变，使得经过段映射机制，虚拟地址范围（</span><span
style='font-size:12.0pt'>0xC0000000~0xC0000000 + 4MB</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>）对应的线性地址</span><span style='font-size:
12.0pt'> = </span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>（</span><span
style='font-size:12.0pt'>0~4MB</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>）。而根据页表建立过程的描述，我们可知道线性地址空间（</span><span style='font-size:12.0pt'>0~4MB</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>）与线性地址空间</span><span
lang=ZH-CN style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>（</span><span style='font-size:12.0pt'>0xC0000000~0xC0000000
+ 4MB</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>）对应同样的物理地址，而线性地址空间（</span><span
style='font-size:12.0pt'>0xC0000000~0xC0000000 + 4MB</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>）对应的物理地址空间为（</span><span
style='font-size:12.0pt'>0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，</span><span style='font-size:12.0pt'>4MB</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>）。这样对于（</span><span
style='font-size:12.0pt'>0xC0000000~0xC0000000 + 4MB</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>）这块虚拟地址空间，段页式的地址映射关系为</span><span
lang=ZH-CN style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>虚拟地址</span><span style='font-size:12.0pt'> = </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>线性地址</span><span
style='font-size:12.0pt'> + 0xC0000000 =</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>物理地址</span><span style='font-size:12.0pt'>
+ 0xC0000000</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>。</span></p>

<p class=MsoNormal style='margin-left:63.65pt;text-indent:.1pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>注意，这只是针对（</span><span
style='font-size:12.0pt'>0xC0000000~0xC0000000 + 4MB</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>）这块虚拟地址空间。如果是（</span><span
style='font-size:12.0pt'>0xD0000000~0xD0000000 + 4MB</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>）这块虚拟地址空间，则段页式的地址映射关系为虚拟地址</span><span
style='font-size:12.0pt'> = </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>线性地址</span><span style='font-size:12.0pt'> + 0xC0000000 =</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>物理地址</span><span
style='font-size:12.0pt'> + 0xC0000000 + 0xC0000000</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>。这不是我们需要的映射关系，所以</span><span
style='font-size:12.0pt'>0xC0000000 + 4MB</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>以上的虚拟地址访问会出页错误异常。</span></p>

<p class=MsoListParagraph style='margin-left:63.05pt;text-indent:-21.0pt'><span
style='font-size:12.0pt'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>最后一步完成收尾工作的正常段页式地址映射阶段，即首先调整段映射关系，这是通过加载新的全局段描述符表（</span><span
style='font-size:12.0pt'>pmm_init</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>函数调用</span><span style='font-size:12.0pt'>gdt_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数来完成）实现，这时的段映射关系为：虚拟地址</span><span
style='font-size:12.0pt'> = </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>线性地址。然后通过执行语句“</span><span style='font-size:10.0pt;font-family:
Courier'>boot_pgdir<b>[</b><span style='color:teal'>0</span><b>]</b><span
style='color:gray'>&nbsp;</span><b>=</b><span style='color:gray'>&nbsp;</span><span
style='color:teal'>0</span><b>;</b></span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>”把</span><span style='font-size:12.0pt'>boot_pgdir[0]</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的第一个页目录表项（</span><span
style='font-size:12.0pt'>0~4MB</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>）清零来取消临时的页映射关系。至此，新的段页式的地址映射关系为虚拟地址</span><span
style='font-size:12.0pt'> = </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>线性地址</span><span style='font-size:12.0pt'> =</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>物理地址</span><span
style='font-size:12.0pt'> + 0xC0000000</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>。这也形成了</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>操作系统的内核虚拟地址空间的段页式映射关系，即虚拟地址空间（</span><span
style='font-size:12.0pt'>KERNBASE, KERNBASE + KMEMSIZE</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>）</span><span style='font-size:12.0pt'>=
</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>线性地址空间（</span><span
style='font-size:12.0pt'>KERNBASE, KERNBASE + KMEMSIZE</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>）</span><span style='font-size:12.0pt'>
= </span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>物理地址空间（</span><span
style='font-size:12.0pt'>0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，</span><span style='font-size:12.0pt'>KMEMSIZE</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>）。</span></p>

<p class=MsoNormal><span>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;text-autospace:none'><b><span
style='font-size:14.0pt'>3.6 </span></b><b><span lang=ZH-CN style='font-size:
14.0pt;font-family:楷体'>自映射机制</span></b></p>

<p class=MsoNormal><span style='font-size:12.0pt'>   </span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>这是扩展知识。</span><span lang=ZH-CN
style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>上一小节讲述了通过</span><span style='font-size:12.0pt'>boot_map_segment</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数建立了基于一一映射关系的页目录表项和页表项，这里的映射关系为：</span></p>

<p class=MsoNormal style='text-indent:30.0pt'><span style='font-size:12.0pt'>virtual
addr (KERNBASE~KERNBASE+KMEMSIZE) = physical_addr (0~KMEMSIZE)</span></p>

<p class=MsoNormal><span style='font-size:12.0pt'>    </span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>这样只要给出一个虚地址和一个物理地址，就可以设置相应</span><span
style='font-size:12.0pt'>PDE</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>和</span><span style='font-size:12.0pt'>PTE</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，就可完成正确的映射关系。</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>如果我们这时需要按虚拟地址的地址顺序显示整个页目录表和页表的内容，则要查找页目录表的页目录表项内容，根据页目录表项内容找到页表的物理地址，再转换成对应的虚地址，然后访问页表的虚地址，搜索整个页表的每个页目录项。这样过程比较繁琐。</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>我们需要有一个简洁的方法来实现这个查找。</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>做了一个很巧妙的地址自映射设计，把页目录表和页表放在一个连续的</span><span style='font-size:
12.0pt'>4MB</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>虚拟地址空间中，并设置页目录表自身的虚地址</span><span
style='font-size:12.0pt'>&lt;--&gt;</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>物理地址映射关系。这样在已知页目录表起始虚地址的情况下，通过连续扫描这特定的</span><span
style='font-size:12.0pt'>4MB</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>虚拟地址空间，就很容易访问每个页目录表项和页表项内容。</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>具体而言，</span><span style='font-size:
12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>是这样设计的，首先设置了一个常量（</span><span
style='font-size:12.0pt'>memlayout.h</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>）：</span></p>

<p class=MsoNormal style='text-indent:54.0pt'><span style='font-size:12.0pt'>VPT=0xFAC00000</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，</span><span lang=ZH-CN
style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>这个地址的二进制表示为：</span></p>

<p class=MsoNormal style='text-indent:54.0pt'><span style='font-size:12.0pt'>1111
1010 1100 0000 0000 0000 0000 0000</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>高</span><span style='font-size:12.0pt'>10</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>位为</span><span
style='font-size:12.0pt'>1111 1010 11</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>，即</span><span style='font-size:12.0pt'>10</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>进制的</span><span
style='font-size:12.0pt'>1003</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，中间</span><span style='font-size:12.0pt'>10</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>位为</span><span
style='font-size:12.0pt'>0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，低</span><span style='font-size:12.0pt'>12</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>位也为</span><span
style='font-size:12.0pt'>0</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>。在</span><span style='font-size:12.0pt'>pmm.c</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中有两个全局初始化变量</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt'>pte_t
* const vpt = (pte_t *)VPT;</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt'>pde_t
* const vpd = (pde_t *)PGADDR(PDX(VPT), PDX(VPT), 0);</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>并在</span><span style='font-size:12.0pt'>pmm_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数执行了如下语句：</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt'>boot_pgdir[PDX(VPT)]
= PADDR(boot_pgdir) | PTE_P | PTE_W;</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>这些变量和语句有何特殊含义呢？其实</span><span
style='font-size:12.0pt'>vpd</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>变量的值就是页目录表的起始虚地址</span><span style='font-size:12.0pt'>0xFAFEB000</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，且它的高</span><span
style='font-size:12.0pt'>10</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>位和中</span><span style='font-size:12.0pt'>10</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>位是相等的，都是</span><span
style='font-size:12.0pt'>10</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>进制的</span><span style='font-size:12.0pt'>1003</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>。当执行了上述语句，就确保了</span><span
style='font-size:12.0pt'>vpd</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>变量的值就是页目录表的起始虚地址，且</span><span style='font-size:12.0pt'>vpt</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>是页目录表中第一个目录表项指向的页表的起始虚地址。此时描述内核虚拟空间的页目录表的虚地址为</span><span
style='font-size:12.0pt'>0xFAFEB000</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>，大小为</span><span style='font-size:12.0pt'>4KB</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>。页表的理论连续虚拟地址空间</span><span
style='font-size:12.0pt'>0xFAC00000~0xFB000000</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>，大小为</span><span style='font-size:12.0pt'>4MB</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>。因为这个连续地址空间的大小为</span><span
style='font-size:12.0pt'>4MB</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，可有</span><span style='font-size:12.0pt'>1M</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>个</span><span
style='font-size:12.0pt'>PTE</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，即可映射</span><span style='font-size:12.0pt'>4GB</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的地址空间。</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>但</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>实际上不会用完这么多项，在</span><span
style='font-size:12.0pt'>memlayout.h</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>中定义了常量</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt'>#define
KMEMSIZE            0x38000000</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>表示</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>只支持</span><span
style='font-size:12.0pt'>896MB</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的物理内存空间，这个</span><span style='font-size:12.0pt'>896MB</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>只是一个设定，可以根据情况改变。则最大的内核虚地址为常量</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt'>#define
KERNTOP             (KERNBASE + KMEMSIZE)=0xF8000000</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>所以最大内核虚地址</span><span style='font-size:
12.0pt'>KERNTOP</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>的页目录项虚地址为</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt'>vpd+0xF8000000/0x400000=0xFAFEB000+0x3E0=0xFAFEB3E0</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>最大内核虚地址</span><span style='font-size:
12.0pt'>KERNTOP</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>的页表项虚地址为：</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt'>vpt+0xF8000000/0x1000=0xFAC00000+0xF8000=0xFACF8000</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>在</span><span style='font-size:12.0pt'>pmm.c</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中的函数</span><span
style='font-size:12.0pt'>print_pgdir</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>就是基于</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的页表自映射方式完成了对整个页目录表和页表的内容扫描和打印。注意，这里不会出现某个页表的虚地址与页目录表虚地址相同的情况。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='position:absolute;
z-index:251713013;left:0px;margin-left:116px;margin-top:13px;width:9px;
height:5px'><img width=9 height=5 src="lab2.files/image009.png"></span><span
style='position:absolute;z-index:251714037;left:0px;margin-left:486px;
margin-top:13px;width:9px;height:5px'><img width=9 height=5
src="lab2.files/image010.png"></span><span style='position:absolute;z-index:
251715061;left:0px;margin-left:281px;margin-top:31px;width:9px;height:5px'><img
width=9 height=5 src="lab2.files/image011.png"></span><span style='font-size:
12.0pt'>print pgdir</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>函数使得</span><span style='font-size:12.0pt'> ucore </span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>具备和</span><span style='font-size:12.0pt'>
qemu </span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的</span><span
style='font-size:12.0pt'>info  pg</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>相同的功能，即</span><span style='font-size:12.0pt'>print pgdir</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>能</span><span lang=ZH-CN
style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>够从内存中，将当前页表内有效数据（</span><span style='font-size:12.0pt'>PTE_P</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>）印出来。拷贝出的格式如下所示</span><span
style='font-size:12.0pt'>:</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:26.7pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=493 valign=top style='width:493.1pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='margin-left:29.6pt;text-align:left;
  line-height:17.95pt;text-autospace:none'><span style='font-family:"Lucida Sans";
  color:black;letter-spacing:.05pt'>PDE(0e0)  c0000000-f8000000  38000000  urw</span></p>
  <p class=MsoNormal align=left style='margin-left:29.6pt;text-align:left;
  line-height:17.95pt;text-autospace:none'><span style='font-family:"Lucida Sans";
  color:black;letter-spacing:.05pt'>|-- PTE(38000) c0000000-f8000000  38000000
  -rw</span></p>
  <p class=MsoNormal align=left style='margin-left:29.6pt;text-align:left;
  line-height:17.95pt;text-autospace:none'><span style='font-family:"Lucida Sans";
  color:black;letter-spacing:.05pt'>PDE(001)  fac00000-fb000000  00400000  -rw</span></p>
  <p class=MsoNormal align=left style='margin-left:29.6pt;text-align:left;
  line-height:17.95pt;text-autospace:none'><span style='font-family:"Lucida Sans";
  color:black;letter-spacing:.05pt'>|-- PTE(000e0)  faf00000-fafe0000 
  000e0000  urw</span></p>
  <p class=MsoNormal align=left style='margin-left:29.6pt;text-align:left;
  line-height:17.95pt;text-autospace:none'><span style='font-family:"Lucida Sans";
  color:black;letter-spacing:.05pt'>|-- PTE(00001)  fafeb000-fafec000 
  00001000  -rw</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:9.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>上面中的数字包括括号里的，都是十六进制。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.8pt;margin-bottom:0cm;
margin-left:9.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:17.9pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>主要的功能是从页表中将具备相同权限的</span><span
style='font-size:12.0pt'> PDE </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>和</span><span style='font-size:12.0pt'> PTE </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>项目组织起来。比如上表中：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:47.95pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=447 valign=top style='width:446.5pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='margin-left:29.6pt;text-align:left;
  line-height:14.95pt;text-autospace:none'><span style='font-family:"Lucida Sans";
  color:black;vertical-align:sub;letter-spacing:.05pt'>PDE(0e0) 
  c0000000-f8000000  38000000  urw</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal align=left style='margin-left:29.6pt;text-align:left;
line-height:14.95pt;text-autospace:none'><span style='font-size:12.0pt;
color:black;vertical-align:sub;letter-spacing:.05pt'>&nbsp;</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:51.6pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt;color:black'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-size:12.0pt'>PDE(0e0)</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>：</span><span style='font-size:12.0pt'>0e0</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>表示</span><span
style='font-size:12.0pt'> PDE </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>表中相邻的</span><span style='font-size:12.0pt'> 224 </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>项具有相同的权限；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:51.6pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt;color:black'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-size:12.0pt'>c0000000-f8000000</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>：表示</span><span style='font-size:12.0pt'>
PDE </span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>表中</span><span
style='font-size:12.0pt'>,</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>这相邻的两项所映射的线性地址的范围；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:51.6pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt;color:black'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-size:12.0pt'>38000000</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>：同样表示范围，即</span><span style='font-size:12.0pt'>f8000000</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>减去</span><span
style='font-size:12.0pt'>c0000000</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的结果；</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:51.6pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt;color:black'>•<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-size:12.0pt'>urw</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>：</span><span style='font-size:12.0pt'>PDE </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>表中所给出的权限位，</span><span
style='font-size:12.0pt'>u</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>表示用户可读，即</span><span style='font-size:12.0pt'>PTE_U</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，</span><span
style='font-size:12.0pt'>r</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>表示</span><span style='font-size:12.0pt'>PTE_P</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，</span><span
style='font-size:12.0pt'>w</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>表示用</span><span lang=ZH-CN style='font-size:12.0pt'> </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>户可写，即</span><span
style='font-size:12.0pt'>PTE_W</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>。</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:51.6pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=436 valign=top style='width:435.75pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='margin-top:1.85pt;margin-right:0cm;
  margin-bottom:0cm;margin-left:33.6pt;margin-bottom:.0001pt;text-align:left;
  line-height:12.0pt;text-autospace:none'><span style='color:black'>PDE(001) <span
  style='letter-spacing:1.3pt'> </span>fac00000-fb000000 <span
  style='letter-spacing:1.3pt'> </span>00400000 <span style='letter-spacing:
  .05pt'> </span>-rw</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-left:29.6pt;line-height:14.95pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black;
letter-spacing:.25pt'>表示</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体;color:black'>仅</span><span lang=ZH-CN style='font-size:12.0pt;
color:black;letter-spacing:-2.8pt'> </span><span style='font-size:12.0pt;
color:black'>1<span style='letter-spacing:.1pt'> </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black;letter-spacing:
.25pt'>条</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black;vertical-align:sub;letter-spacing:.05pt'>连续的</span><span
lang=ZH-CN style='font-size:12.0pt;color:black;letter-spacing:-2.8pt'> </span><span
style='font-size:12.0pt;color:black'>P<span style='letter-spacing:.05pt'>D</span>E<span
style='letter-spacing:-.1pt'> </span></span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体;color:black;letter-spacing:.25pt'>表项具备相同的属</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black;letter-spacing:
.05pt'>性。</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black;letter-spacing:.25pt'>相应</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体;color:black;letter-spacing:.05pt'>的，</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black;letter-spacing:
.25pt'>在这条表项中遍历找</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体;color:black'>到</span><span lang=ZH-CN style='font-size:12.0pt;color:black;
letter-spacing:-2.8pt'> </span><span style='font-size:12.0pt;color:black'>2<span
style='letter-spacing:.1pt'> </span></span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体;color:black'>组</span><span lang=ZH-CN style='font-size:
12.0pt;color:black;letter-spacing:-2.8pt'> </span><span style='font-size:12.0pt;
color:black'>PTE<span style='letter-spacing:-.05pt'> </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>表<span
style='letter-spacing:.05pt'>项，输出如下</span></span><span style='font-size:12.0pt;
color:black'>:</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:55.05pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=432 valign=top style='width:432.3pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='margin-left:40.6pt;text-align:left;
  text-autospace:none'><span style='color:black'>|-- PTE(000e0) 
  faf00000-fafe0000  000e0000  urw</span></p>
  <p class=MsoNormal align=left style='margin-top:4.7pt;margin-right:0cm;
  margin-bottom:0cm;margin-left:40.6pt;margin-bottom:.0001pt;text-align:left;
  line-height:12.0pt;text-autospace:none'><span style='color:black'>|--
  PTE(00001)  fafeb000-fafec000  00001000  -rw</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-right:9.8pt;text-indent:18.0pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>注意：</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:51.6pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-size:12.0pt'>PTE </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中输出的权限是</span><span style='font-size:12.0pt'> PTE </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>表中的数据给出的，并没有和</span><span
style='font-size:12.0pt'> PDE </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>表中权限做与运算。</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:51.6pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='position:absolute;z-index:251727349;left:0px;margin-left:145px;
margin-top:13px;width:9px;height:5px'><img width=9 height=5
src="lab2.files/image012.png"></span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>整个</span><span style='font-size:12.0pt'>print_pgdir</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数强调两点：第一是相同权限，第二是连续。</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.8pt;margin-bottom:
0cm;margin-left:51.6pt;margin-bottom:.0001pt;text-indent:-18.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='position:absolute;z-index:251728373;left:0px;margin-left:122px;
margin-top:13px;width:8px;height:5px'><img width=8 height=5
src="lab2.files/image013.png"></span><span style='font-size:12.0pt'>print_pgdir</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中用到了</span><span
style='font-size:12.0pt'>vpt</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>和</span><span style='font-size:12.0pt'>vpd</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>两个变量。可以参</span><span
lang=ZH-CN style='font-size:12.0pt'> </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>考</span><span style='font-size:12.0pt'>VPT</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>和</span><span
style='font-size:12.0pt'>PGADDR</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>两个宏。</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>自映射机制还可方便用户态程序访问页表。因为页表是内核维护的，用户程序很难知道自己页表的映射结构。</span><span
style='font-size:12.0pt'>VPT </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>实际上在内核地址空间的，我们可以用同样的方式实现一个用户地址空间的映射（比如</span><span
style='font-size:12.0pt'> pgdir[UVPT] = PADDR(pgdir) | PTE_P | PTE_U</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，注意，这里不能给写权限，并且</span><span
style='font-size:12.0pt'> pgdir </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>是每个进程的</span><span style='font-size:12.0pt'> page table</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，不是</span><span
style='font-size:12.0pt'> boot_pgdir</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>），这样，用户程序就可以用和内核一样的</span><span style='font-size:12.0pt'>
print_pgdir </span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数遍历自己的页表结构了。</span></p>

</div>

<span style='font-size:12.0pt;font-family:"Times New Roman"'><br clear=all
style='page-break-before:auto'>
</span>

<div class=WordSection2></div>

<span style='font-size:7.0pt;font-family:"Times New Roman";color:black'><br
clear=all style='page-break-before:always'>
</span>

<div class=WordSection3>

<p class=MsoNormal style='margin-right:9.75pt;line-height:17.9pt;text-autospace:
none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:5.7pt;text-align:left;
text-autospace:none'><b><span style='font-size:17.0pt'>4</span></b><b><span
lang=ZH-CN style='font-size:17.0pt;font-family:楷体'>．</span></b><b><span
lang=ZH-CN style='font-size:17.0pt'> </span></b><b><span lang=ZH-CN
style='font-size:17.0pt;font-family:楷体'>实验报告要求</span></b></p>

<p class=MsoNormal align=left style='margin-top:.5pt;text-align:left;
line-height:11.0pt;text-autospace:none'><span style='font-size:11.0pt;
color:black'>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>从网站上下载</span><span style='font-size:12.0pt'>lab2.zip</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>后，解压得到本文档和代码目录</span><span
style='font-size:12.0pt'> lab2</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，完成实验中的各个练习。完成代码编写并检查无误后，在对应目录下执行</span><span style='font-size:
12.0pt'> make handin </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>任务，即会自动生成</span><span style='font-size:12.0pt'> lab2-handin.tar.gz</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>。最后请一定提前或按时提交到网络学堂上。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>注意有</span><b><i><span lang=ZH-CN style='font-family:楷体'>“</span></i></b><b><i><span>LAB2</span></i></b><b><i><span
lang=ZH-CN style='font-family:楷体'>”</span></i></b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>的注释，代码中所有需要完成的地方</span><span
lang=ZH-CN style='font-family:楷体'>（</span><span>challenge</span><span
lang=ZH-CN style='font-family:楷体'>除外）</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>都有</span><b><i><span lang=ZH-CN style='font-family:楷体'>“</span></i></b><b><i><span>LAB2</span></i></b><b><i><span
lang=ZH-CN style='font-family:楷体'>”和“</span></i></b><b><i><span>YOUR CODE</span></i></b><b><i><span
lang=ZH-CN style='font-family:楷体'>”</span></i></b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>的注释，请在提交时特别注意保持注释，并将</span><b><i><span
lang=ZH-CN style='font-family:楷体'>“</span></i></b><b><i><span>YOUR CODE</span></i></b><b><i><span
lang=ZH-CN style='font-family:楷体'>”</span></i></b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>替换为自己的学号，并且将所有标有对应注释的部分填上正确的代码。</span></p>

<span style='font-size:12.0pt;font-family:"Times New Roman"'><br clear=all
style='page-break-before:always'>
</span>

<p class=MsoNormal align=left style='text-align:left'><span style='font-size:
12.0pt'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:5.7pt;text-align:left;
text-autospace:none'><b><span lang=ZH-CN style='font-family:楷体'>附录</span></b></p>

<p class=MsoListParagraph align=left style='margin-left:23.65pt;text-align:
left;text-indent:-18.0pt;text-autospace:none'><b><span style='font-size:12.0pt'>A.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span></b><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>探测物理内存分布和大小的方法</span></b><b><span
lang=ZH-CN style='font-size:12.0pt'> </span></b></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>操作系统需要知道了解整个计算机系统中的物理内存如何分布的，哪些被可用，哪些不可用。其基本方法是通过</span><span
style='font-size:12.0pt'>BIOS</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中断调用来帮助完成的。其中</span><span style='font-size:12.0pt'>BIOS</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中断调用必须在实模式下进行，所以在</span><span
style='font-size:12.0pt'>bootloader</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>进入保护模式前完成这部分工作相对比较合适。这些部分由</span><span style='font-size:
12.0pt'>boot/bootasm.S</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中从</span><span style='font-size:12.0pt'>probe_memory</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>处到</span><span
style='font-size:12.0pt'>finish_probe</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>处的代码部分完成完成。通过</span><span style='font-size:12.0pt'>BIOS</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中断获取内存可调用参数为</span><span
style='font-size:12.0pt'>e820h</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的</span><span style='font-size:12.0pt'>INT 15h BIOS</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中断。</span><span
style='font-size:12.0pt'>BIOS</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>通过系统内存映射地址描述符（</span><span style='font-size:12.0pt'>Address
Range Descriptor</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>）格式来表示系统物理内存布局，其具体表示如下：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:29.8pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=421 valign=top style='width:420.9pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:9.0pt;color:black'>Offset</span><span
  style='font-size:9.0pt;color:black'>&nbsp;</span><span style='font-size:9.0pt;
  color:black'> Size</span><span style='font-size:9.0pt;color:black'>&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:9.0pt;color:black'> Description</span><span
  style='font-size:9.0pt;color:black'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;color:black'>00h</span><span
  style='font-size:9.0pt;color:black'>&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:9.0pt;color:black'> 8</span><span style='font-size:9.0pt;
  font-family:楷体;color:black'>字节</span><span style='font-size:9.0pt;color:black'>&nbsp;&nbsp;</span><span
  style='font-size:9.0pt;color:black'> base address</span><span
  style='font-size:9.0pt;color:black'>&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:9.0pt;color:black'>                                                      #</span><span
  style='font-size:9.0pt;font-family:楷体;color:black'>系统内存块基地址</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;color:black'>08h</span><span
  style='font-size:9.0pt;color:black'>&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:9.0pt;color:black'> 8</span><span style='font-size:9.0pt;
  font-family:楷体;color:black'>字节</span><span style='font-size:9.0pt;color:black'>&nbsp;&nbsp;</span><span
  style='font-size:9.0pt;color:black'> length in bytes                                                    #</span><span
  style='font-size:9.0pt;font-family:楷体;color:black'>系统内存大小</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;color:black'>10h</span><span
  style='font-size:9.0pt;color:black'>&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:9.0pt;color:black'> 4</span><span style='font-size:9.0pt;
  font-family:楷体;color:black'>字节</span><span style='font-size:9.0pt;color:black'>&nbsp;&nbsp;</span><span
  style='font-size:9.0pt;color:black'> type of address range     #</span><span
  style='font-size:9.0pt;font-family:楷体;color:black'>内存类型</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>看下面的</span><span style='font-size:12.0pt'>(Values for System
Memory Map address type)</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:42.0pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=409 valign=top style='width:408.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:9.0pt;color:black'>Values for
  System Memory Map address type:</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;color:black'>01h    memory,
  available to OS</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;color:black'>02h    reserved,
  not available (e.g. system ROM, memory-mapped device)</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;color:black'>03h    ACPI
  Reclaim Memory (usable by OS after reading ACPI tables)</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;color:black'>04h    ACPI NVS
  Memory (OS is required to save this memory between NVS sessions)</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;color:black'>other  not
  defined yet -- treat as Reserved</span></p>
  <p class=MsoNormal><span>&nbsp;</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='text-indent:15.75pt'><span>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>INT15h BIOS</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中断的详细调用参数</span><span
style='font-size:12.0pt'>: </span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:42.0pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=409 valign=top style='width:408.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormalIndent style='text-indent:0cm'><span style='font-size:9.0pt'>eax</span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>：</span><span
  style='font-size:9.0pt'>e820h</span><span lang=ZH-CN style='font-size:9.0pt;
  font-family:楷体'>：</span><span style='font-size:9.0pt'>INT 15</span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>的中断调用参数；</span></p>
  <p class=MsoNormalIndent style='text-indent:0cm'><span style='font-size:9.0pt'>edx</span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>：</span><span
  style='font-size:9.0pt'>534D4150h (</span><span lang=ZH-CN style='font-size:
  9.0pt;font-family:楷体'>即</span><span style='font-size:9.0pt'>4</span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>个</span><span
  style='font-size:9.0pt'>ASCII</span><span lang=ZH-CN style='font-size:9.0pt;
  font-family:楷体'>字符</span><span style='font-size:9.0pt'>“SMAP”) </span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>，这只是一个签名而已；</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>ebx</span><span lang=ZH-CN
  style='font-size:9.0pt;font-family:楷体'>：<span style='color:black'>如果是第一次调用或内存区域扫描完毕，则为</span></span><span
  style='font-size:9.0pt;color:black'>0</span><span lang=ZH-CN
  style='font-size:9.0pt;font-family:楷体;color:black'>。</span><span lang=ZH-CN
  style='font-size:9.0pt;color:black'> </span><span lang=ZH-CN
  style='font-size:9.0pt;font-family:楷体;color:black'>如果不是，则存放上次调用之后的计数值</span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>；</span></p>
  <p class=MsoNormalIndent style='text-indent:0cm'><span style='font-size:9.0pt'>ecx</span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>：保存地址范围描述符的内存大小</span><span
  style='font-size:9.0pt'>,</span><span lang=ZH-CN style='font-size:9.0pt;
  font-family:楷体'>应该大于等于</span><span style='font-size:9.0pt'>20</span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>字节；</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>es:di</span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>：<span style='color:black'>指向保存</span>地址范围描述符<span
  style='color:black'>结构的缓冲区，</span></span><span style='font-size:9.0pt;
  color:black'>BIOS</span><span lang=ZH-CN style='font-size:9.0pt;font-family:
  楷体;color:black'>把信息写入这个结构的起始地址。</span></p>
  <p class=MsoNormalIndent style='text-indent:0cm'><span>&nbsp;</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormalIndent style='text-indent:0cm'><span>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>此中断的返回值为</span><span style='font-size:12.0pt'>: </span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:42.0pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=409 valign=top style='width:408.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormalIndent style='text-indent:0cm'><span style='font-size:9.0pt'>cflags</span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>的</span><span
  style='font-size:9.0pt'>CF</span><span lang=ZH-CN style='font-size:9.0pt;
  font-family:楷体'>位：若</span><span style='font-size:9.0pt'>INT 15</span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>中断执行成功，则不置位，否则置位；</span><span
  lang=ZH-CN style='font-size:9.0pt'> </span></p>
  <p class=MsoNormalIndent style='text-indent:0cm'><span style='font-size:9.0pt'>eax</span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>：</span><span
  style='font-size:9.0pt'>534D4150h ('SMAP') </span><span lang=ZH-CN
  style='font-size:9.0pt;font-family:楷体'>；</span></p>
  <p class=MsoNormalIndent style='text-indent:0cm'><span style='font-size:9.0pt'>es:di</span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>：指向保存地址范围描述符的缓冲区</span><span
  style='font-size:9.0pt'>,</span><span lang=ZH-CN style='font-size:9.0pt;
  font-family:楷体'>此时缓冲区内的数据已由</span><span style='font-size:9.0pt'>BIOS</span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>填写完毕</span><span
  lang=ZH-CN style='font-size:9.0pt'> </span></p>
  <p class=MsoNormalIndent style='text-indent:0cm'><span style='font-size:9.0pt'>ebx</span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>：下一个地址范围描述符的计数地址</span><span
  lang=ZH-CN style='font-size:9.0pt'> </span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>ecx            </span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>：返回</span><span
  style='font-size:9.0pt;color:black'>BIOS</span><span lang=ZH-CN
  style='font-size:9.0pt;font-family:楷体;color:black'>往</span><span
  style='font-size:9.0pt;color:black'>ES:DI</span><span lang=ZH-CN
  style='font-size:9.0pt;font-family:楷体;color:black'>处写</span><span lang=ZH-CN
  style='font-size:9.0pt;font-family:楷体'>的地址范围描述符的字节大小</span><span lang=ZH-CN
  style='font-size:9.0pt'> </span></p>
  <p class=MsoNormalIndent style='text-indent:0cm'><span style='font-size:9.0pt'>ah</span><span
  lang=ZH-CN style='font-size:9.0pt;font-family:楷体'>：失败时保存出错代码</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormalIndent style='text-indent:0cm'><span>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>这样，我们通过调用</span><span style='font-size:12.0pt'>INT 15h BIOS</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中断，递增</span><span
style='font-size:12.0pt'>di</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的值（</span><span style='font-size:12.0pt'>20</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的倍数），让</span><span
style='font-size:12.0pt'>BIOS</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>帮我们查找出一个一个的内存布局</span><span style='font-size:12.0pt'>entry</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，并放入到一个保存地址范围描述符结构的缓冲区中，供后续的</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>进一步进行物理内存管理。这个缓冲区结构定义在</span><span style='font-size:12.0pt'>memlayout.h</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:42.0pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=409 valign=top style='width:408.7pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:9.0pt'>struct e820map {</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  int
  nr_map;</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  struct {</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                                    long
  long addr;</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                                    long
  long size;</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                                    long
  type;</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  }
  map[E820MAX];</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>};</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal><span>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-right:9.75pt;text-align:left;
line-height:17.9pt;text-autospace:none'><b><span style='font-size:12.0pt'>&nbsp;</span></b></p>

<p class=MsoListParagraph align=left style='margin-left:23.65pt;text-align:
left;text-indent:-18.0pt;text-autospace:none'><a name="OLE_LINK2"><a
name="OLE_LINK1"><b><span style='font-size:12.0pt'>B.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span></b><b><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>实现物理内存探测</span></b></a></a></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>物理内存探测是在</span><span style='font-size:12.0pt'>bootasm.S</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中实现的，相关代码很短，如下所示：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:66.4pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=390 valign=top style='width:390.4pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:9.0pt'>probe_memory:</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>//</span><span
  style='font-size:9.0pt;font-family:楷体'>对</span><span style='font-size:9.0pt'>0x8000</span><span
  style='font-size:9.0pt;font-family:楷体'>处的</span><span style='font-size:9.0pt'>32</span><span
  style='font-size:9.0pt;font-family:楷体'>位单元清零</span><span style='font-size:
  9.0pt'>,</span><span style='font-size:9.0pt;font-family:楷体'>即给位于</span><span
  style='font-size:9.0pt'>0x8000</span><span style='font-size:9.0pt;font-family:
  楷体'>处的</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>//struct e820map</span><span
  style='font-size:9.0pt;font-family:楷体'>的<span lang=ZH-CN>成员变量</span></span><span
  style='font-size:9.0pt'>nr_map</span><span style='font-size:9.0pt;font-family:
  楷体'>清零</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>           movl $0,
  0x8000          </span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  xorl %ebx,
  %ebx    </span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>//</span><span
  style='font-size:9.0pt;font-family:楷体'>表示设置调用</span><span style='font-size:
  9.0pt'>INT 15h BIOS</span><span style='font-size:9.0pt;font-family:楷体'>中断后，</span><span
  style='font-size:9.0pt'>BIOS</span><span style='font-size:9.0pt;font-family:
  楷体'>返回的映射地址描述符的起始地址</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  movw
  $0x8004, %di </span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>start_probe:</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  movl
  $0xE820, %eax // INT 15</span><span style='font-size:9.0pt;font-family:楷体'>的中断调用参数</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>//</span><span
  style='font-size:9.0pt;font-family:楷体'>设置地址范围描述符的大小为</span><span
  style='font-size:9.0pt'>20</span><span style='font-size:9.0pt;font-family:
  楷体'>字节，其大小等于</span><span style='font-size:9.0pt'>struct e820map</span><span
  style='font-size:9.0pt;font-family:楷体'>的<span lang=ZH-CN>成员变量</span></span><span
  style='font-size:9.0pt'>map</span><span style='font-size:9.0pt;font-family:
  楷体'>的大小</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  movl $20,
  %ecx  </span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>//</span><span
  style='font-size:9.0pt;font-family:楷体'>设置</span><span style='font-size:9.0pt'>edx</span><span
  style='font-size:9.0pt;font-family:楷体'>为</span><span style='font-size:9.0pt'>534D4150h
  (</span><span style='font-size:9.0pt;font-family:楷体'>即</span><span
  style='font-size:9.0pt'>4</span><span style='font-size:9.0pt;font-family:
  楷体'>个</span><span style='font-size:9.0pt'>ASCII</span><span style='font-size:
  9.0pt;font-family:楷体'>字符</span><span style='font-size:9.0pt'>“SMAP”)</span><span
  style='font-size:9.0pt;font-family:楷体'>，这是一个约定</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  movl
  $SMAP, %edx</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>//</span><span
  style='font-size:9.0pt;font-family:楷体'>调用</span><span style='font-size:9.0pt'>int
  0x15</span><span style='font-size:9.0pt;font-family:楷体'>中断，要求</span><span
  style='font-size:9.0pt'>BIOS</span><span style='font-size:9.0pt;font-family:
  楷体'>返回一个用地址范围描述符表示的内存段信息</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  int $0x15</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>//</span><span
  style='font-size:9.0pt;font-family:楷体'>如果</span><span style='font-size:9.0pt'>eflags</span><span
  style='font-size:9.0pt;font-family:楷体'>的</span><span style='font-size:9.0pt'>CF</span><span
  style='font-size:9.0pt;font-family:楷体'>位为</span><span style='font-size:9.0pt'>0</span><span
  style='font-size:9.0pt;font-family:楷体'>，则表示还有内存段需要探测</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  jnc cont</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>//</span><span lang=ZH-CN
  style='font-size:9.0pt;font-family:楷体;color:red'>探测有问题，结束探测</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  movw
  $12345, 0x8000</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  jmp
  finish_probe</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>cont:</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>//</span><span
  style='font-size:9.0pt;font-family:楷体'>设置下一个</span><span style='font-size:
  9.0pt'>BIOS</span><span style='font-size:9.0pt;font-family:楷体'>返回的映射地址描述符的起始地址</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  addw $20,
  %di</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>//</span><span
  style='font-size:9.0pt;font-family:楷体'>递增</span><span style='font-size:9.0pt'>struct
  e820map</span><span style='font-size:9.0pt;font-family:楷体'>的<span lang=ZH-CN>成员变量</span></span><span
  style='font-size:9.0pt'>nr_map</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  incl
  0x8000</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>//</span><span
  style='font-size:9.0pt;font-family:楷体'>如果</span><span style='font-size:9.0pt'>INT0x15</span><span
  style='font-size:9.0pt;font-family:楷体'>返回的</span><span style='font-size:9.0pt'>ebx</span><span
  style='font-size:9.0pt;font-family:楷体'>为零，表示探测结束，否则继续探测</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  cmpl $0,
  %ebx</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>                  jnz
  start_probe</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt'>finish_probe</span><span>:</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal><span>&nbsp;</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>上述代码正常执行完毕后，在</span><span style='font-size:12.0pt'>0x8000</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>地址处保存了从</span><span
style='font-size:12.0pt'>BIOS</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中获得的内存分布信息，此信息按照</span><span style='font-size:12.0pt'>struct
e820map</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的设置来进行填充。这部分信息将在</span><span
style='font-size:12.0pt'>bootloader</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>启动</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>后，由</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的</span><span style='font-size:12.0pt'>page_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数来根据</span><span
style='font-size:12.0pt'>struct e820map</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>的</span><span style='font-size:12.0pt'>memmap</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>（定义了起始地址为</span><span
style='font-size:12.0pt'>0x8000</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>）来完成对整个机器中的物理内存的总体管理。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span>&nbsp;</span></p>

<p class=MsoListParagraph align=left style='margin-left:23.65pt;text-align:
left;text-indent:-18.0pt;text-autospace:none'><b><span style='font-size:12.0pt'>C.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span></b><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>链接地址</span></b><b><span
style='font-size:12.0pt'>/</span></b><b><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>虚地址</span></b><b><span style='font-size:12.0pt'>/</span></b><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>物理地址</span></b><b><span
style='font-size:12.0pt'>/</span></b><b><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>加载地址以及</span></b><a name="OLE_LINK18"><b><span
style='font-size:12.0pt'>edata/end/text</span></b></a><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>的含义</span></b></p>

<p class=MsoNormal><b><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>链接脚本简介</span></b></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>ucore kernel</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>各个部分由组成</span><span
style='font-size:12.0pt'>kernel</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的<a name="OLE_LINK17"><a name="OLE_LINK16">各个</a></a></span><span
style='font-size:12.0pt'>.o</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>或</span><span style='font-size:12.0pt'>.a</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>文件</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>构成，且各个部分在内存中地址位置由</span><span
style='font-size:12.0pt'>ld</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>工具根据</span><span style='font-size:12.0pt'>kernel.ld</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>链接脚本（</span><span
style='font-size:12.0pt'>linker script</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>）来设定。</span><span style='font-size:12.0pt'>ld</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>工具使用命令</span><span
style='font-size:12.0pt'>-T</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>指定链接脚本。链接脚本主要用于规定如何把输入文件（各个</span><span style='font-size:12.0pt'>.o</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>或</span><span
style='font-size:12.0pt'>.a</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>文件）内的</span><span style='font-size:12.0pt'>section</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>放入输出文件（</span><span
style='font-size:12.0pt'>lab2/bin/kernel</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>，即</span><span style='font-size:12.0pt'>ELF</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>格式的</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>内核）内，</span><span lang=ZH-CN style='font-size:12.0pt'> </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>并控制输出文件内各部分在程序地址空间内的布局。下面简单分析一下</span><span
style='font-size:12.0pt'>/lab2/tools/kernel.ld</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>，来了解一下</span><span style='font-size:
12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>内核的地址布局情况。</span><span
style='font-size:12.0pt'>kernel.ld</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>的内容如下所示：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:62.1pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=397 valign=top style='width:14.0cm;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:10.0pt'>/* Simple linker script for
  the ucore kernel.</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>   See the GNU ld 'info'
  manual (&quot;info ld&quot;) to learn the syntax. */</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>OUTPUT_FORMAT(&quot;elf32-i386&quot;,
  &quot;elf32-i386&quot;, &quot;elf32-i386&quot;)</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>OUTPUT_ARCH(i386)</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>ENTRY(kern_entry)</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>SECTIONS {</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    /* Load the kernel at
  this address: &quot;.&quot; means the current address */</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    . = 0xC0100000;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    .text : {</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>        *(.text .stub
  .text.* .gnu.linkonce.t.*)</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    }</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    PROVIDE(etext = .); /*
  Define the 'etext' symbol to this value */</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    .rodata : {</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>        *(.rodata .rodata.*
  .gnu.linkonce.r.*)</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    }</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    /* Include debugging
  information in kernel memory */</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    .stab : {</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>       
  PROVIDE(__STAB_BEGIN__ = .);</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>        *(.stab);</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>       
  PROVIDE(__STAB_END__ = .);</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>        BYTE(0)     /*
  Force the linker to allocate space</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>                   for this
  section */</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    }</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    .stabstr : {</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>       
  PROVIDE(__STABSTR_BEGIN__ = .);</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>        *(.stabstr);</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>       
  PROVIDE(__STABSTR_END__ = .);</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>        BYTE(0)     /*
  Force the linker to allocate space</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>                   for this
  section */</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    }</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    /* Adjust the address
  for the data segment to the next page */</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    . = ALIGN(0x1000);</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    /* The data segment */</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    .data : {</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>        *(.data)</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    }</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    PROVIDE(edata = .);</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    .bss : {</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>        *(.bss)</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    }</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    PROVIDE(end = .);</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    /DISCARD/ : {</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>        *(.eh_frame
  .note.GNU-stack)</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    }</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>}</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>其实从链接脚本的内容，可以大致猜出它指定告诉链接器的各种信息：</span></p>

<p class=MsoListParagraph style='margin-left:78.0pt;text-indent:-21.0pt'><span
style='font-size:12.0pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>内核加载地址：</span><span
style='font-size:12.0pt'>0xC0100000</span></p>

<p class=MsoListParagraph style='margin-left:78.0pt;text-indent:-21.0pt'><span
style='font-size:12.0pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>入口（起始代码）地址：</span><span
lang=ZH-CN style='font-size:12.0pt'> </span><span style='font-size:12.0pt'>ENTRY(kern_entry)</span></p>

<p class=MsoListParagraph style='margin-left:78.0pt;text-indent:-21.0pt'><span
style='font-size:12.0pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-size:12.0pt'>cpu</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>机器类型：</span><span style='font-size:
12.0pt'>i386</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>其最主要的信息是告诉链接器各输入文件的各</span><span style='font-size:12.0pt'>section</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>应该怎么组合：应该从哪个地址开始放，各个</span><span
style='font-size:12.0pt'>section</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>以什么顺序放，分别怎么对齐等等，最终组成输出文件的各</span><span style='font-size:12.0pt'>section</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>。除此之外，</span><span
style='font-size:12.0pt'>linker script</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>还可以定义各种符号（如</span><span style='font-size:12.0pt'>.text</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>、</span><span
style='font-size:12.0pt'>.data</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>、</span><span style='font-size:12.0pt'>.bss</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>等），形成最终生成的一堆符号的列表（符号表），每个符号包含了符号名字，符号所引用的内存地址，以及其他一些属性信息。符号实际上就是一个地址的符号表示，其本身不占用的程序运行的内存空间。</span></p>

<p class=MsoNormal><b><span style='font-size:12.0pt'>&nbsp;</span></b></p>

<p class=MsoNormal><b><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>链接地址</span></b><b><span style='font-size:12.0pt'>/</span></b><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>加载地址</span></b><b><span
style='font-size:12.0pt'>/</span></b><b><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>虚地址</span></b><b><span style='font-size:12.0pt'>/</span></b><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>物理地址</span></b><span
lang=ZH-CN style='font-size:12.0pt'> </span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>ucore </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>设定了</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>运行中的虚地址空间，具体设置可看</span><span lang=ZH-CN style='font-size:12.0pt'>
</span><span style='font-size:12.0pt'>lab2/kern/mm/memlayout.h </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中描述的</span><span
style='font-size:12.0pt'>&quot;Virtual memory map&nbsp;&quot;</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>图，可以了解虚地址和物理地址的对应关系。</span><span
style='font-size:12.0pt'>lab2/tools/kernel.ld</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>描述的是执行代码的链接地址（</span><span
style='font-size:12.0pt'>link_addr</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>），比如内核起始地址是</span><span style='font-size:12.0pt'>0xC0100000</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，这是一个虚地址。所以我们可以认为链接地址等于虚地址。在</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>建立内核页表时，设定了物理地址和虚地址的虚实映射关系是：</span><span lang=ZH-CN
style='font-size:12.0pt'> </span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>phy addr +
0xC0000000 = virtual addr</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>即虚地址和物理地址之间有一个偏移。但</span><span style='font-size:12.0pt'>boot loader</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>把</span><span
style='font-size:12.0pt'>ucore kernel</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>加载到内存时，采用的是加载地址（</span><span style='font-size:12.0pt'>load
addr</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>），这是由于</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>还没有运行，即还没有启动页表映射，导致这时采用的寻址方式是段寻址方式，用的是</span><span
style='font-size:12.0pt'>boot loader</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>在初始化阶段设置的段映射关系，其映射关系（可参看</span><span style='font-size:
12.0pt'>bootasm.S</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>的末尾处有关段描述符表的内容）是：</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>            linear
addr = phy addr = virtual addr</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>查看</span><span style='font-size:12.0pt'> bootloader</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的实现代码</span><span
style='font-size:12.0pt'> bootmain::bootmain.c</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>&nbsp; &nbsp;
&nbsp;readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:24.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'>&nbsp; </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>这里的</span><span
style='font-size:12.0pt'>ph-&gt;p_va=0xC0XXXXXX</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>，就是</span><span style='font-size:12.0pt'>ld</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>工具根据</span><span
style='font-size:12.0pt'>kernel.ld</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>设置的链接地址，且链接地址等于虚地址。考虑到</span><span style='font-size:
12.0pt'>ph-&gt;p_va &amp; 0xFFFFFF == 0x0XXXXXX</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>，所以</span><span style='font-size:12.0pt'>bootloader</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>加载</span><span
style='font-size:12.0pt'>ucore kernel</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>的加载地址是</span><span style='font-size:12.0pt'>0x0XXXXXX,
&nbsp;</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>这实际上是</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>内核所在的物理地址。简言之：</span><span style='font-size:12.0pt'> OS</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的链接地址（</span><span
style='font-size:12.0pt'>link addr</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>）</span><span lang=ZH-CN style='font-size:12.0pt'> </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在</span><span
style='font-size:12.0pt'>tools/kernel.ld</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>中设置好了，是一个虚地址（</span><span
style='font-size:12.0pt'>virtual addr</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>）；而</span><span style='font-size:12.0pt'>ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>　</span><span
style='font-size:12.0pt'>kernel</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>的加载地址（</span><span style='font-size:12.0pt'>load addr</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>）在</span><span
style='font-size:12.0pt'>boot loader</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>中的</span><span style='font-size:12.0pt'>bootmain</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数中指定，是一个物理地址。</span></p>

<p class=MsoNormal style='margin-right:9.75pt;line-height:17.9pt;text-autospace:
none'><span style='font-size:12.0pt'>         </span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>小结一下，</span><span style='font-size:
12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>内核的链接地址</span><span
style='font-size:12.0pt'>==ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>内核的虚拟地址；</span><span style='font-size:12.0pt'>boot loader</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>加载</span><span
style='font-size:12.0pt'>ucore</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>内核用到的加载地址</span><span style='font-size:12.0pt'>==ucore</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>内核的物理地址。</span></p>

<p class=MsoNormal style='margin-right:9.75pt;line-height:17.9pt;text-autospace:
none'><span style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-right:9.75pt;line-height:17.9pt;text-autospace:
none'><b><span style='font-size:12.0pt'>edata/end/text</span></b><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的含义</span></b></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:23.9pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>在基于</span><span style='font-size:12.0pt'>ELF</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>执行文件格式的代码中，存在一些对代码和数据的表述，基本概念如下：</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt;font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span
style='font-size:12.0pt'>BSS</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>段（</span><span style='font-size:12.0pt'>bss segment</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>）：指用来存放程序中未初始化的全局变量的内存区域。</span><span
style='font-size:12.0pt'>BSS</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>是英文</span><span style='font-size:12.0pt'>Block Started by
Symbol</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的简称。</span><span
style='font-size:12.0pt'>BSS</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>段属于静态内存分配。</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt;font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>数据段（</span><span style='font-size:12.0pt'>data
segment</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>）：指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</span></p>

<p class=MsoListParagraph style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:50.6pt;margin-bottom:.0001pt;text-indent:-21.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt;font-family:Wingdings'>l<span
style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>代码段（</span><span style='font-size:12.0pt'>code
segment/text segment</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>）：指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读</span><span
style='font-size:12.0pt'>,&nbsp;</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:24.0pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>在</span><span style='font-size:12.0pt'>lab2/kern/init/init.c</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>的</span><span
style='font-size:12.0pt'>kern_init</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>函数中，声明了外部全局变量：</span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:62.1pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=397 valign=top style='width:14.0cm;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:10.0pt'>extern&nbsp;char&nbsp;<a
  name="OLE_LINK19">edata[],&nbsp;end[]</a>;</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:24.0pt;line-height:
17.9pt;text-autospace:none'><span style='font-size:12.0pt'> </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>但搜寻所有源码文件</span><span
style='font-size:12.0pt'>*.[ch]</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>，没有发现有这两个变量的定义。那这两个变量从哪里来的呢？其实在</span><span style='font-size:
12.0pt'>lab2/tools/kernel.ld</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>中，可以<a name="OLE_LINK3">看到如下内容：</a></span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:62.1pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=397 valign=top style='width:14.0cm;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:10.0pt'>…    </span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>.text : {</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>        *(.text .stub
  .text.* .gnu.linkonce.t.*)</span></p>
  <p class=MsoNormal style='text-indent:13.5pt'><span style='font-size:10.0pt'>}</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>…</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    .data : {</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>        *(.data)</span></p>
  <p class=MsoNormal style='text-indent:9.75pt'><span style='font-size:10.0pt'>}</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>…</span></p>
  <p class=MsoNormal style='text-indent:13.5pt'><span style='font-size:10.0pt'>PROVIDE(edata
  = .);</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>…</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>    .bss : {</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>        *(.bss)</span></p>
  <p class=MsoNormal style='text-indent:9.75pt'><span style='font-size:10.0pt'>}</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>…</span></p>
  <p class=MsoNormal style='text-indent:13.5pt'><span style='font-size:10.0pt'>PROVIDE(end
  = .);</span></p>
  <p class=MsoNormal><span style='font-size:10.0pt'>…</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:24.0pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>这里的<a name="OLE_LINK9"><a name="OLE_LINK4">“</a></a></span><span
style='font-size:12.0pt'>.</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>”表示当前地址，“</span><span style='font-size:12.0pt'>.text</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>”</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>表示代码段起始地址，“</span><span
style='font-size:12.0pt'>.data</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>”也是一个地址，可以看出，它即代表了代码段的结束地址，也是数据段的起始地址。类推下去，“</span><span
style='font-size:12.0pt'>edata</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>”表示数据段的结束地址，“</span><span style='font-size:12.0pt'>.bss</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>”表示数据段的结束地址和</span><span
style='font-size:12.0pt'>BSS</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>段的起始地址，而“</span><span style='font-size:12.0pt'>end</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>”表示</span><a
name="OLE_LINK15"><a name="OLE_LINK10"><span style='font-size:12.0pt'>BSS</span></a></a><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>段</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>的结束地址。</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:9.75pt;margin-bottom:
0cm;margin-left:5.7pt;margin-bottom:.0001pt;text-indent:24.0pt;line-height:
17.9pt;text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>这样回头看</span><span style='font-size:12.0pt'>kerne_init</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中的外部全局变量，可知</span><span
style='font-size:12.0pt'>edata[]</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>和</span><span style='font-size:12.0pt'>&nbsp;end[]</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>这些变量是</span><span
style='font-size:12.0pt'>ld</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>根据</span><span style='font-size:12.0pt'>kernel.ld</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>链接脚本生成的全局变量，表示相应段的起始地址或结束地址等，它们不在任何一个</span><span
style='font-size:12.0pt'>.S</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>、</span><span style='font-size:12.0pt'>.c</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>或</span><span
style='font-size:12.0pt'>.h</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>文件中定义。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span>&nbsp;</span></p>

</div>

</body>

</html>
