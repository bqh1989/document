<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=Generator content="Microsoft Word 14 (filtered)">
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Arial;
	panose-1:2 11 6 4 2 2 2 2 2 4;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"\@宋体";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:楷体;
	panose-1:2 1 6 9 6 1 1 1 1 1;}
@font-face
	{font-family:"\@楷体";
	panose-1:2 1 6 9 6 1 1 1 1 1;}
@font-face
	{font-family:永中宋体;
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"\@永中宋体";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Microsoft JhengHei";}
@font-face
	{font-family:BatangChe;}
@font-face
	{font-family:"\@Microsoft JhengHei";}
@font-face
	{font-family:"\@BatangChe";}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:"Times New Roman";}
h1
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:14.2pt;
	font-size:16.0pt;
	font-family:Arial;
	font-weight:bold;}
h2
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:65.3pt;
	text-indent:-54.0pt;
	font-size:10.0pt;
	font-family:Arial;
	font-weight:bold;
	font-style:italic;}
p.MsoNormalIndent, li.MsoNormalIndent, div.MsoNormalIndent
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:10.0pt;
	font-size:10.5pt;
	font-family:"Times New Roman";}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	layout-grid-mode:char;
	border:none;
	padding:0cm;
	font-size:9.0pt;
	font-family:"Times New Roman";}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:"Times New Roman";}
p.MsoDate, li.MsoDate, div.MsoDate
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:125.0pt;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:"Times New Roman";}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p
	{margin-right:0cm;
	margin-left:0cm;
	font-size:12.0pt;
	font-family:宋体;}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:9.0pt;
	font-family:"Times New Roman";}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:21.0pt;
	font-size:10.5pt;
	font-family:"Times New Roman";}
p.1, li.1, div.1
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:10.0pt;
	font-size:10.5pt;
	font-family:"Times New Roman";}
span.a
	{font-family:"永中宋体","serif";}
.MsoChpDefault
	{font-size:10.0pt;}
 /* Page Definitions */
@page WordSection1
	{size:596.0pt 842.0pt;
	margin:36.0pt 36.0pt 36.0pt 36.0pt;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>

</head>

<body lang=EN-US link=blue vlink=purple style='text-justify-trim:punctuation'>

<div class=WordSection1>

<p class=MsoNormal align=center style='margin-right:31.1pt;text-align:center;
line-height:22.1pt;text-autospace:none'><span lang=ZH-CN style='font-size:17.0pt;
font-family:楷体'>实验六</span><span style='font-size:17.0pt;font-family:楷体'>: </span><span
lang=ZH-CN style='font-size:17.0pt;font-family:楷体'>调度器</span></p>

<p class=MsoNormal align=left style='text-align:left;line-height:10.0pt;
text-autospace:none'><span style='font-size:10.0pt;font-family:楷体'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;text-autospace:none'><b><span
style='font-size:14.0pt;font-family:楷体;letter-spacing:.05pt'>1 <span
lang=ZH-CN>实验目的</span></span></b></p>

<p class=MsoNormal style='text-indent:21.0pt;text-autospace:none'><span
lang=ZH-CN style='font-family:宋体'>•</span><span lang=ZH-CN style='font-family:
楷体'> </span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>理解操作系统的调度管理机制</span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'> 熟悉</span><span style='font-size:12.0pt;
font-family:楷体'> ucore <span lang=ZH-CN>的系统调度器框架，以及缺省的</span>Round-Robin <span
lang=ZH-CN>调度算法</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'> 基于调度器框架实现一个</span><span
style='font-size:12.0pt;font-family:楷体'>(Stride Scheduling)<span lang=ZH-CN>调度算法来替换缺省的调度算法</span></span></p>

<p class=MsoNormal align=left style='margin-top:.1pt;text-align:left;
line-height:11.0pt;text-autospace:none'><span style='font-size:14.0pt;
font-family:楷体'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;text-autospace:none'><b><span
style='font-size:14.0pt;font-family:楷体;letter-spacing:.05pt'>2 <span
lang=ZH-CN>实验内容</span></span></b></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>实验五完成了用户进程的管理，可在用户态运行多个进程。但到目前为止，采用的调度策略是很简单的</span><span
style='font-size:12.0pt;font-family:楷体'>FIFO<span lang=ZH-CN>调度策略。本次实验，主要是熟悉</span>ucore<span
lang=ZH-CN>的系统调度器框架，以及基于此框架的</span> Round-Robin<span lang=ZH-CN>（</span>RR<span
lang=ZH-CN>） 调度算法。然后参考</span>RR<span lang=ZH-CN>调度算法的实现，完成</span>Stride
Scheduling<span lang=ZH-CN>调度算法。</span></span></p>

<p class=MsoNormal align=left style='margin-left:5.65pt;text-align:left;
text-autospace:none'><b><span style='font-size:14.0pt'>2.1 </span></b><b><span
lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>练习</span></b></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:red'>练习</span></b><b><span
style='font-size:12.0pt;color:red'>0</span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:red'>：填写已有实验</span></b></p>

<p class=MsoNormal style='text-autospace:none'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>本实验依赖实验</span><span style='font-size:
12.0pt;font-family:楷体'>1/2/3/4/5<span lang=ZH-CN>。请把你做的实验</span>2/3/4/5<span
lang=ZH-CN>的代码填入本实验中代码中有“</span>LAB1<span lang=ZH-CN>”</span>/ <span
lang=ZH-CN>“</span>LAB2<span lang=ZH-CN>”</span>/<span lang=ZH-CN>“</span>LAB3<span
lang=ZH-CN>”</span>/<span lang=ZH-CN>“</span>LAB4<span lang=ZH-CN>”</span>/<span
lang=ZH-CN>“</span>LAB5<span lang=ZH-CN>”的注释相应部分。并确保编译通过。注意：为了能够正确执行</span>lab6<span
lang=ZH-CN>的测试应用程序，可能需对已完成的实验</span>1/2/3/4/5<span lang=ZH-CN>的代码进行进一步改进。</span></span></p>

<p class=MsoNormal><b><span style='font-size:12.0pt;font-family:楷体;color:red'>&nbsp;</span></b></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:red'>练习</span></b><b><span
style='font-size:12.0pt;color:red'>1 </span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:red'>使用</span></b><b><span
style='font-size:12.0pt;color:red'>Round Robin</span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:red'>调度算法（不需要编码）</span></b></p>

<p class=MsoNormal style='text-autospace:none'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>完成练习</span><span style='font-size:12.0pt;
font-family:楷体'>0<span lang=ZH-CN>后，建议大家比较一下（可用</span>kdiff3<span lang=ZH-CN>等文件比较软件）个人完成的</span>lab5<span
lang=ZH-CN>和练习</span>0<span lang=ZH-CN>完成后的刚修改的</span>lab6<span lang=ZH-CN>之间的区别，分析了解</span>lab6<span
lang=ZH-CN>采用</span>RR<span lang=ZH-CN>调度算法后的执行过程。执行</span>make grade<span
lang=ZH-CN>，大部分测试用例应该通过。但执行</span>priority.c<span lang=ZH-CN>应该过不去。</span></span></p>

<p class=MsoNormal style='text-autospace:none'><span style='font-size:12.0pt;
font-family:楷体'>&nbsp;</span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:red'>练习</span></b><b><span
style='font-size:12.0pt;color:red'>2 </span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:red'>实现</span></b><b><span
style='font-size:12.0pt;color:red'>Stride Scheduling</span></b><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:red'>调度算法（需要编码）</span></b></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>首先需要换掉</span><span
style='font-size:12.0pt;font-family:楷体'>RR<span lang=ZH-CN>调度器的实现，即用</span>default_sched_stride_c<span
lang=ZH-CN>覆盖</span>default_sched.c<span lang=ZH-CN>。然后根据此文件和后续文档对</span>Stride<span
lang=ZH-CN>度器的相关描述，完成</span></span><span style='font-size:12.0pt;font-family:
楷体'>Stride<span lang=ZH-CN>调度算法的</span></span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>实现。</span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:24.0pt;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>后面的实验文档部分给出了</span><span
style='font-size:12.0pt;font-family:楷体'>Stride<span lang=ZH-CN>调度算法的大体描述。这里给出</span></span><span
style='font-size:12.0pt;font-family:楷体'>Stride</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>调度算法的一些相关的资料（目前网上中文的资料比较欠缺）。</span></p>

<p class=MsoNormal align=left style='margin-left:21.65pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;letter-spacing:1.55pt'> </span><a
href="http://wwwagss.informatik.uni-kl.de/Projekte/Squirrel/stride/node3.html"><span
style='font-size:12.0pt;font-family:楷体'>http:/<span style='letter-spacing:-1.1pt'>/</span>wwwagss.informatik.uni<span
style='letter-spacing:-1.1pt'>-</span>kl.de<span style='letter-spacing:-1.1pt'>/</span>Projekte<span
style='letter-spacing:-1.1pt'>/</span>Squirrel<span style='letter-spacing:-1.1pt'>/</span>stride<span
style='letter-spacing:-1.1pt'>/</span>node3.html</span></a></p>

<p class=MsoNormal align=left style='margin-left:21.65pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;letter-spacing:1.55pt'> </span><a
href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.138.3502&amp;rank=1"><span
style='font-size:12.0pt;font-family:楷体'>http:/<span style='letter-spacing:-1.1pt'>/</span>citeseerx.ist.psu.edu<span
style='letter-spacing:-1.1pt'>/</span>viewdoc<span style='letter-spacing:-1.1pt'>/</span>summary<span
style='letter-spacing:-1.1pt'>?</span>doi=10.1.1.138.3502&amp;rank=1</span></a></p>

<p class=MsoNormal align=left style='margin-left:21.65pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;letter-spacing:1.55pt'> </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>也可</span><span
style='font-size:12.0pt;font-family:楷体'>GOOGLE <span style='letter-spacing:
.85pt'> </span><span lang=ZH-CN>“</span>Stride <span style='letter-spacing:
.65pt'> </span>S<span style='letter-spacing:-.3pt'>c</span>heduling<span
lang=ZH-CN>” <span style='letter-spacing:.15pt'>来查找相关资料</span></span></span></p>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><span style='font-size:12.0pt;font-family:楷体'>   </span></p>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>执行：</span><span
style='font-size:12.0pt;font-family:楷体'>make grade <span lang=ZH-CN>。</span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>如果所显示的应用程序检测都输出</span><span
style='font-size:12.0pt;font-family:楷体'>ok<span lang=ZH-CN>，则基本正确。如果只是</span></span><span
style='font-size:12.0pt;font-family:楷体'>priority.c<span lang=ZH-CN>过不去，可执行</span>
make run-priority <span lang=ZH-CN>命令来单独调试它。大致执行结果可看附录。</span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>（<b><span style='color:red'>使用的是</span></b></span><b><span
style='font-size:12.0pt;font-family:楷体;color:red'>qemu-1.0.1</span></b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>）。</span></p>

<p class=MsoNormal style='text-autospace:none'><b><span style='font-size:12.0pt;
font-family:楷体;color:red'>&nbsp;</span></b></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:red'>扩展练习</span></b><b><span
style='font-size:12.0pt;color:red'>Challenge</span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:red'>：实现</span></b><b><span
style='font-size:12.0pt;color:red'>Linux</span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:red'>的</span></b><b><span
style='font-size:12.0pt;color:red'>CFS</span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:red'>调度算法</span></b></p>

<p class=MsoNormal style='margin-right:9.8pt;line-height:17.9pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在</span><span
style='font-size:12.0pt;font-family:楷体'>ucore <span lang=ZH-CN>的调度器框架下实现下</span>Linux<span
lang=ZH-CN>的</span>CFS<span lang=ZH-CN>调度算法。可阅读相关</span>Linux<span lang=ZH-CN>内核书籍或查询网上资料，可了解</span>CFS<span
lang=ZH-CN>的细节，然后大致实现在</span>ucore<span lang=ZH-CN>中。</span></span></p>

<p class=MsoNormal align=left style='margin-left:5.65pt;text-align:left;
text-autospace:none'><b><span style='font-size:14.0pt'>2.2 </span></b><b><span
lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>项目组成</span></b></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=439 valign=top style='width:438.8pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>├──</span><span style='font-family:楷体'>
  boot</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>├──</span><span style='font-family:楷体'>
  kern</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>├──</span> debug</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>├──</span> driver</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>├──</span> fs</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>├──</span> init</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>├──</span> libs</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>├──</span> mm</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>├──</span> process</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>│</span></span><span
  style='font-family:宋体'>&nbsp;&nbsp;</span><span style='font-family:楷体'> <span
  lang=ZH-CN>├──</span> .....</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>│</span></span><span
  style='font-family:宋体'>&nbsp;&nbsp;</span><span style='font-family:楷体'> <span
  lang=ZH-CN>├── </span><span style='color:purple'>proc.c</span></span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>│</span></span><span
  style='font-family:宋体'>&nbsp;&nbsp;</span><span style='font-family:楷体'> <span
  lang=ZH-CN>├── </span><span style='color:purple'>proc.h</span></span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>│</span></span><span
  style='font-family:宋体'>&nbsp;&nbsp;</span><span style='font-family:楷体'> <span
  lang=ZH-CN>└──</span> switch.S</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>├──</span> schedule</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>│</span></span><span
  style='font-family:宋体'>&nbsp;&nbsp;</span><span style='font-family:楷体'> <span
  lang=ZH-CN>├── </span><span style='color:red'>default_sched.c</span></span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>│</span></span><span
  style='font-family:宋体'>&nbsp;&nbsp;</span><span style='font-family:楷体'> <span
  lang=ZH-CN>├── </span><span style='color:red'>default_sched.h</span></span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>│</span></span><span
  style='font-family:宋体'>&nbsp;&nbsp;</span><span style='font-family:楷体'> <span
  lang=ZH-CN>├── </span><span style='color:red'>default_sched_stride_c</span></span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>│</span></span><span
  style='font-family:宋体'>&nbsp;&nbsp;</span><span style='font-family:楷体'> <span
  lang=ZH-CN>├── </span><span style='color:purple'>sched.c</span></span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>│</span></span><span
  style='font-family:宋体'>&nbsp;&nbsp;</span><span style='font-family:楷体'> <span
  lang=ZH-CN>└── </span><span style='color:purple'>sched.h</span></span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>├──</span> syscall</span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>│</span></span><span
  style='font-family:宋体'>&nbsp;&nbsp;</span><span style='font-family:楷体'> <span
  lang=ZH-CN>├── </span><span style='color:purple'>syscall.c</span></span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>│</span><span style='font-family:宋体'>&nbsp;&nbsp;</span><span
  style='font-family:楷体'> <span lang=ZH-CN>│</span></span><span
  style='font-family:宋体'>&nbsp;&nbsp;</span><span style='font-family:楷体'> <span
  lang=ZH-CN>└── </span><span style='color:purple'>syscall.h</span></span></p>
  <p class=MsoNormal align=left style='text-align:left;text-autospace:none'><span
  lang=ZH-CN style='font-family:楷体'>…</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>相对与实验五，实验六主要增加的文件如上表红色部分所示，主要修改的文件如上表紫色部分所示。主要改动如下：</span></p>

<p class=MsoNormal align=left style='margin-top:3.7pt;margin-right:0cm;
margin-bottom:0cm;margin-left:5.3pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>简单说明如下：</span></p>

<p class=MsoNormal align=left style='margin-top:.25pt;text-align:left;
line-height:5.0pt;text-autospace:none'><span style='font-size:12.0pt;
font-family:楷体'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'> libs/skew_heap.h:  <span lang=ZH-CN>提供了基本的优先队列数据结构，为本次实验提供了抽象数据结构方面的支持。</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'> kern/process/proc.[ch]<span
lang=ZH-CN>：</span>proc.h<span lang=ZH-CN>中扩展了</span>proc_struct<span
lang=ZH-CN>的成员变量，用于</span>RR<span lang=ZH-CN>和</span>stride<span lang=ZH-CN>调度算法。</span>proc.c<span
lang=ZH-CN>中实现了</span>lab6_set_priority<span lang=ZH-CN>，用于设置进程的优先级。</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'> kern/schedule/{sched.h,sched.c}:  <span
lang=ZH-CN>定义了</span> ucore <span lang=ZH-CN>的调度器框架，其中包括相关的数 据结构（包括调度器的接口和运行队列的结构），和具体的运行时机制。</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'>
kern/schedule/{default_sched.h,default_sched.c}:   <span lang=ZH-CN>具体的</span>
round-robin <span lang=ZH-CN>算法，在本次实验中你需要了解其实现。</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'> kern/schedule/default_sched_stride_c:
Stride Scheduling<span lang=ZH-CN>调度器的基本框架，在此次 实验中你需要填充其中的空白部分以实现一个完整的</span>
Stride  <span lang=ZH-CN>调度器。</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'> kern/syscall/syscall.[ch]: <span
lang=ZH-CN>增加了</span>sys_gettime<span lang=ZH-CN>系统调用，便于用户进程获取当前时钟值；增加了</span>sys_lab6_set_priority<span
lang=ZH-CN>系统调用，便于用户进程设置进程优先级（给</span>priority.c<span lang=ZH-CN>用）</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'> user/{matrix.c,priority.c,. . . }:  <span
lang=ZH-CN>相关的一些测试用户程序，测试调度算法的正确性，</span>user <span lang=ZH-CN>目录下包含但不限于这些程序。在完成实验过程中，建议阅读这些测试程序，以了解这些程序的行为，便于进行调试。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
style='font-size:12.0pt;font-family:楷体'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;text-autospace:none'><b><span
style='font-size:14.0pt;font-family:楷体;letter-spacing:.05pt'>3   <span
lang=ZH-CN>调度框架和调度算法设计与实现</span></span></b></p>

<p class=MsoNormal style='margin-left:5.65pt;text-autospace:none'><b><span
style='font-size:14.0pt'>3.1</span></b><b><span lang=ZH-CN style='font-size:
14.0pt;font-family:楷体'>实验执行流程概述</span></b></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在实验五，创建了用户进程，并让它们正确运行。这中间也实现了</span><span
style='font-size:12.0pt;font-family:楷体'>FIFO<span lang=ZH-CN>调度策略。可通过阅读</span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>实验五</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>下的 </span><span style='font-size:12.0pt;
font-family:楷体'>kern/schedule/sched.c </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>的 </span><span style='font-size:12.0pt;font-family:楷体'>schedule
</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>函数的实现来了解其</span><span
style='font-size:12.0pt;font-family:楷体'>FIFO<span lang=ZH-CN>调度策略。与</span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>实验五</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>相比，实验六专门需要针对处理器调度框架和各种算法进行设计与实现，为此对</span><span
style='font-size:12.0pt;font-family:楷体'>ucore<span lang=ZH-CN>的调度部分</span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>进行了适当的修改，使得</span><span
style='font-size:12.0pt;font-family:楷体'>kern/schedule/sched.c </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>只实现调度器框架，而不再涉及具体的调度算法实现。而调度算法在单独的文件（</span><span
style='font-size:12.0pt;font-family:楷体'>default_sched.[ch]<span lang=ZH-CN>）中实现。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>除此之外，实验中还涉及了</span><span
style='font-size:12.0pt;font-family:楷体'>idle</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>进程的概念。当</span><span style='font-size:
12.0pt;font-family:楷体'>cpu</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>没有进程可以执行的时候，系统应该如何工作？在实验五的</span><span style='font-size:12.0pt;
font-family:楷体'>scheduler</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>实现中，</span><span style='font-size:12.0pt;font-family:楷体'>ucore<span
lang=ZH-CN>内核不断的遍历进程池，直到找到第一个</span></span><span style='font-size:12.0pt;
font-family:楷体'>runnable</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>状态的 </span><span style='font-size:12.0pt;font-family:楷体'>process</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>，调用并执行它。也就是说，当系统没有进程可以执行的时候，它会把所有
</span><span style='font-size:12.0pt;font-family:楷体'>cpu </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>时间用在搜索进程池，以实现 </span><span
style='font-size:12.0pt;font-family:楷体'>idle</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>的目的。但是这样的设计不被大多数操作系统所采用，原因在于它将进程调度和 </span><span
style='font-size:12.0pt;font-family:楷体'>idle </span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>进程两种不同的概念混在了一起，而且，当调度器比较复杂时，</span><span
style='font-size:12.0pt;font-family:楷体'>schedule </span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>函数本身也会比较复杂，这样的设计结构很不清晰而且难免会出现错误。所以在此次实验中，</span><span
style='font-size:12.0pt;font-family:楷体'>ucore </span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>建立了一个单独的进程</span><span
style='font-size:12.0pt;font-family:楷体'>(kern/process/proc.c </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>中的 </span><span
style='font-size:12.0pt;font-family:楷体'>idleproc)</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>作为 </span><span style='font-size:12.0pt;
font-family:楷体'>cpu </span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体'>空闲时的 </span><span style='font-size:12.0pt;font-family:楷体'>idle </span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>进程，这个程序是通常一个死循环。你需要了解这个程序的实现。</span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>接下来可看看实验六的大致执行过程，在</span><span
style='font-size:12.0pt;font-family:楷体'>init.c<span lang=ZH-CN>中的</span>kern_init<span
lang=ZH-CN>函数增加了对</span>sched_init<span lang=ZH-CN>函数的调用。</span>sched_init<span
lang=ZH-CN>函数主要完成了对实现特定调度算法的调度类（</span>sched_class<span lang=ZH-CN>）的绑定，使得</span>ucore<span
lang=ZH-CN>在后续的执行中，能够通过调度框架找到实现特定调度算法的调度类并完成进程调度相关工作。为了更好地理解实验六整个运行过程，这里需要关注的重点问题包括：</span></span></p>

<p class=MsoListParagraph style='margin-left:45.0pt;text-indent:-21.0pt;
text-autospace:none'><span style='font-size:12.0pt;font-family:楷体'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>何时或何事件发生后需要调度？</span></p>

<p class=MsoListParagraph style='margin-left:45.0pt;text-indent:-21.0pt;
text-autospace:none'><span style='font-size:12.0pt;font-family:楷体'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>何时或何事件发生后需要调整实现调度算法所涉及的参数？</span></p>

<p class=MsoListParagraph style='margin-left:45.0pt;text-indent:-21.0pt;
text-autospace:none'><span style='font-size:12.0pt;font-family:楷体'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>如果基于调度框架设计具体的调度算法？</span></p>

<p class=MsoListParagraph style='margin-left:45.0pt;text-indent:-21.0pt;
text-autospace:none'><span style='font-size:12.0pt;font-family:楷体'>4.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp; </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>如果灵活应用链表等数据结构管理进程调度？</span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>大家可带着这些问题进一步阅读后续的内容。</span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
style='font-size:12.0pt;font-family:楷体'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:5.65pt;text-align:left;
text-autospace:none'><b><span style='font-size:14.0pt'>3.2</span></b><b><span
lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>计时器的原理和实现</span></b></p>

<p class=MsoNormal align=left style='text-align:left;line-height:6.0pt;
text-autospace:none'><span style='font-size:6.0pt;font-family:楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在传统的操作系统中，计时器是其中一个基础而重要的功能</span><span
style='font-size:12.0pt;font-family:楷体'>.<span lang=ZH-CN>它提供了基于时间事件的调度机制。在</span>
ucore <span lang=ZH-CN>中，</span>timer  <span lang=ZH-CN>中断</span>(irq0) <span
lang=ZH-CN>给操作系统提供了有一定间隔的时间事件， 操作系统将其作为基本的调度和计时单位（我们记两次时间中断之间的时间间隔为一个 时间片，</span>timer
splice<span lang=ZH-CN>）。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>基于此时间单位，操作系统得以向上提供基于时间点的事件，并实现基于时间长度的等待和唤醒机制。在每个时钟中断发生时，操作系统产生对应的时间事件。应用程序或者操作系统的其他组件可以以此来构建更复杂和高级的调度。</span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'> sched.h,  sched.c <span lang=ZH-CN>定义了有关</span>timer<span
lang=ZH-CN>的各种相关接口来使用</span> timer  <span lang=ZH-CN>服务，其中主要包括</span>:</span></p>

<p class=MsoNormal style='margin-left:42.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'> typedef struct {<span lang=ZH-CN>……</span>}
timer_t:  <span lang=ZH-CN>定义了</span> timer_t <span lang=ZH-CN>的基本结构，其可以用</span>
sched.h  <span lang=ZH-CN>中的</span>timer_init<span lang=ZH-CN>函数对其进行初始化。</span></span></p>

<p class=MsoNormal style='margin-left:42.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'> void timer_init(timer t *timer, 
struct proc_struct *proc, int expires):  <span lang=ZH-CN>对某计时器 进行初始化，让它在</span>
expires <span lang=ZH-CN>时间片之后唤醒</span> proc <span lang=ZH-CN>进程。</span></span></p>

<p class=MsoNormal style='margin-left:42.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'> void add_timer(timer t *timer):  <span
lang=ZH-CN>向系统添加某个初始化过的</span> timer_t<span lang=ZH-CN>，该计时器在 指定时间后被激活，并将对应的进程唤醒至</span>
runnable<span lang=ZH-CN>（如果当前进程处在等待状态）。</span></span></p>

<p class=MsoNormal style='margin-left:42.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'> void del_timer(timer_t *time):  <span
lang=ZH-CN>向系统删除（或者说取消）某一个计时器。该计时 器在取消后不会被系统激活并唤醒进程。</span></span></p>

<p class=MsoNormal style='margin-left:42.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'> void run_timer_list(void):  <span
lang=ZH-CN>更新当前系统时间点，遍历当前所有处在系统管理内的 计时器，找出所有应该激活的计数器，并激活它们。该过程在且只在每次计时器中断时被调用。在</span>
ucore <span lang=ZH-CN>中，其还会调用调度器事件处理程序。</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span style='font-size:12.0pt;font-family:楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>一个</span><span
style='font-size:12.0pt;font-family:楷体'> timer_t <span lang=ZH-CN>在系统中的存活周期可以被描述如下：</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span style='font-size:12.0pt;font-family:楷体'>1.  timer_t <span
lang=ZH-CN>在某个位置被创建和初始化，并通过</span> add_timer<span lang=ZH-CN>加入系统管理列表中</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span style='font-size:12.0pt;font-family:楷体'>2.  <span lang=ZH-CN>系统时间被不断累加，直到</span>
run_timer_list <span lang=ZH-CN>发现该</span> timer_t<span lang=ZH-CN>到期。</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span style='font-size:12.0pt;font-family:楷体'>3.  run_timer_list <span
lang=ZH-CN>更改对应的进程状态，并从系统管理列表中移除该</span>timer_t<span lang=ZH-CN>。 尽管本次实验并不需要填充计时器相关的代码，但是作为系统重要的组件（同时计时器也是调度器的一个部分），你应该了解其相关机制和在</span>
ucore <span lang=ZH-CN>中的实现方法。接下来的实验描述将会在一定程度上忽略计时器对调度带来的影响，即不考虑基于固定时间点的调度。</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span style='font-size:12.0pt;font-family:楷体'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:5.65pt;text-align:left;
text-autospace:none'><b><span style='font-size:14.0pt'>3.3 </span></b><b><span
lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>进程状态</span></b></p>

<p class=MsoNormal align=left style='text-align:left;line-height:6.0pt;
text-autospace:none'><span style='font-size:6.0pt;font-family:楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在此次实验中，进程的状态之间的转换需要有一个更为清晰的表述，在</span><span
style='font-size:12.0pt;font-family:楷体'> ucore <span lang=ZH-CN>中，</span>runnable<span
lang=ZH-CN>的进程会被放在运行队列中。值得注意的是，在具体实现中，</span>ucore<span lang=ZH-CN>定义的进程控制块</span>struct
proc_struct<span lang=ZH-CN>包含了成员变量</span>state,<span lang=ZH-CN>用于描述进程的运行状态，而</span>running<span
lang=ZH-CN>和</span>runnable<span lang=ZH-CN>共享同一个状态</span>(state)<span
lang=ZH-CN>值</span>(PROC_RUNNABLE)<span lang=ZH-CN>。不同之处在于处于</span>running<span
lang=ZH-CN>态的进程不会放在运行队列中。进程的正常生命周期如下：</span></span></p>

<p class=MsoNormal style='margin-left:42.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'> 进程首先在</span><span
style='font-size:12.0pt;font-family:楷体'> cpu <span lang=ZH-CN>初始化或者</span>
sys_fork <span lang=ZH-CN>的时候被创建，当为该进程分配了一个进程描 述符之后，该进程进入</span> uninit<span
lang=ZH-CN>态</span>(<span lang=ZH-CN>在</span> proc.c <span lang=ZH-CN>中</span>
alloc_proc)<span lang=ZH-CN>。</span></span></p>

<p class=MsoNormal style='margin-left:42.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'> 当进程完全完成初始化之后，该进程转为</span><span
style='font-size:12.0pt;font-family:楷体'>runnable<span lang=ZH-CN>态。</span></span></p>

<p class=MsoNormal style='margin-left:42.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'> 当到达调度点时，由调度器</span><span
style='font-size:12.0pt;font-family:楷体'> sched_class <span lang=ZH-CN>根据运行队列</span>rq<span
lang=ZH-CN>的内容来判断一个进程是否应该被运行，即把处于</span>runnable<span lang=ZH-CN>态的进程转换成</span>
running<span lang=ZH-CN>状态，从而占用</span>CPU<span lang=ZH-CN>执行。</span></span></p>

<p class=MsoNormal style='margin-left:42.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'> running<span lang=ZH-CN>态的进程通过</span>wait<span
lang=ZH-CN>等系统调用被阻塞，进入</span>sleeping<span lang=ZH-CN>态。</span></span></p>

<p class=MsoNormal style='margin-left:42.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'> sleeping<span lang=ZH-CN>态的进程被</span>wakeup<span
lang=ZH-CN>变成</span>runnable<span lang=ZH-CN>态的进程。</span></span></p>

<p class=MsoNormal style='margin-left:42.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
style='font-size:12.0pt;font-family:楷体'> running<span lang=ZH-CN>态的进程主动</span>
exit <span lang=ZH-CN>变成</span> zombie<span lang=ZH-CN>态，然后由其父进程完成对其资源的最后释放，子进程的进程控制块成为</span>unused<span
lang=ZH-CN>。</span></span></p>

<p class=MsoNormal style='margin-left:42.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'> 所有从</span><span
style='font-size:12.0pt;font-family:楷体'>runnable<span lang=ZH-CN>态变成其他状态的进程都要出运行队列，反之，被放入某个运行队列中。</span></span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;text-align:left;
line-height:8.5pt;text-autospace:none'><span style='font-size:10.0pt;
font-family:楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:5.65pt;text-align:left;
text-autospace:none'><b><span style='font-size:14.0pt'>3.4   </span></b><b><span
lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>进程调度实现</span></b></p>

<p class=MsoNormal align=left style='text-align:left;line-height:6.0pt;
text-autospace:none'><span style='font-size:6.0pt;font-family:楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
style='font-size:12.0pt'>3.4.1 </span></b><b><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>内核抢占点</span></b></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>调度本质上体现了对</span><span style='font-size:
12.0pt;font-family:楷体'>CPU<span lang=ZH-CN>资源的抢占。对于用户进程而言，由于有中断的产生，可以随时打断用户进程的执行，转到操作系统内部，从而给了操作系统以调度控制权，让操作系统可以根据具体情况（比如用户进程时间片已经用完了）选择其他用户进程执行。这体现了用户进程的可抢占性（</span>preemptive<span
lang=ZH-CN>）。但如果把</span>ucore<span lang=ZH-CN>操作系统也看成是一个特殊的内核进程或多个内核线程的集合，那</span>ucore<span
lang=ZH-CN>是否也是可抢占的呢？其实</span>ucore <span lang=ZH-CN>内核执行是不可抢占的（</span>non-preemptive<span
lang=ZH-CN>），即在执行“任意”内核代码时，</span>CPU<span lang=ZH-CN>控制权可被强制剥夺。这里需要注意，不是在所有情况下</span>ucore<span
lang=ZH-CN>内核执行都是不可抢占的，有以下几种“固定”情况是例外：</span></span></p>

<p class=1 style='margin-left:1.0cm;text-indent:-21.25pt'><span
style='font-size:12.0pt;font-family:楷体'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>进行同步互斥操作，比如争抢一个信号量、锁（</span><span
style='font-size:12.0pt;font-family:楷体'>lab7<span lang=ZH-CN>中会详细分析）；</span></span></p>

<p class=1 style='margin-left:1.0cm;text-indent:-21.25pt'><span
style='font-size:12.0pt;font-family:楷体'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;
</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>进行磁盘读写等耗时的异步操作，由于等待完成的耗时太长，</span><span
style='font-size:12.0pt;font-family:楷体'>ucore<span lang=ZH-CN>会调用</span>shcedule<span
lang=ZH-CN>让其他就绪进程执行。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>这几种情况其实都是由于当前进程所需的某个资源（也可称为事件）无法得到满足，无法继续执行下去，从而不得不主动放弃对</span><span
style='font-size:12.0pt;font-family:楷体'>CPU<span lang=ZH-CN>的控制权。如果参照用户进程任何位置都可被内核打断并放弃</span>CPU<span
lang=ZH-CN>控制权的情况，这些在内核中放弃</span>CPU<span lang=ZH-CN>控制权的执行地点是“固定”而不是“任意”的，不能体现内核任意位置都可抢占性的特点。我们搜寻一下实验五的代码，可发现在如下几处地方调用了</span>shedule<span
lang=ZH-CN>函数：</span></span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:楷体'>&nbsp;</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:21.0pt'><span
lang=ZH-CN style='font-family:楷体'>表一：调用进程调度函数</span><span style='font-family:
楷体'>schedule<span lang=ZH-CN>的位置和原因</span></span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=44 valign=top style='width:43.8pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=ZH-CN style='font-family:楷体'>编号</span></p>
  </td>
  <td width=139 valign=top style='width:138.5pt;border:solid windowtext 1.0pt;
  border-left:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=ZH-CN style='font-family:楷体'>位置</span></p>
  </td>
  <td width=263 valign=top style='width:262.5pt;border:solid windowtext 1.0pt;
  border-left:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=ZH-CN style='font-family:楷体'>原因</span></p>
  </td>
 </tr>
 <tr>
  <td width=44 valign=top style='width:43.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-family:楷体'>1</span></p>
  </td>
  <td width=139 valign=top style='width:138.5pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-family:楷体'>proc.c::do_exit</span></p>
  </td>
  <td width=263 valign=top style='width:262.5pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=ZH-CN style='font-family:楷体'>用户线程执行结束，主动放弃</span><span
  style='font-family:楷体'>CPU<span lang=ZH-CN>控制权。</span></span></p>
  </td>
 </tr>
 <tr>
  <td width=44 valign=top style='width:43.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-family:楷体'>2</span></p>
  </td>
  <td width=139 valign=top style='width:138.5pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-family:楷体'>proc.c::do_wait</span></p>
  </td>
  <td width=263 valign=top style='width:262.5pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=ZH-CN style='font-family:楷体'>用户线程等待子进程结束，主动放弃</span><span
  style='font-family:楷体'>CPU<span lang=ZH-CN>控制权。</span></span></p>
  </td>
 </tr>
 <tr>
  <td width=44 valign=top style='width:43.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-family:楷体'>3</span></p>
  </td>
  <td width=139 valign=top style='width:138.5pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-family:楷体'>proc.c::init_main</span></p>
  </td>
  <td width=263 valign=top style='width:262.5pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=1 style='margin-left:18.0pt;text-indent:-18.0pt'><span
  style='font-family:楷体'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span
  style='font-family:楷体'>initproc<span lang=ZH-CN>内核线程等待所有用户进程结束，如果没有结束，就主动放弃</span>CPU<span
  lang=ZH-CN>控制权</span>;</span></p>
  <p class=1 style='margin-left:18.0pt;text-indent:-18.0pt'><span
  style='font-family:楷体'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span
  style='font-family:楷体'>initproc<span lang=ZH-CN>内核线程在所有用户进程结束后，让</span>kswapd<span
  lang=ZH-CN>内核线程执行</span>10<span lang=ZH-CN>次，用于回收空闲内存资源</span></span></p>
  </td>
 </tr>
 <tr>
  <td width=44 valign=top style='width:43.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-family:楷体'>4</span></p>
  </td>
  <td width=139 valign=top style='width:138.5pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-family:楷体'>proc.c::cpu_idle</span></p>
  </td>
  <td width=263 valign=top style='width:262.5pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-family:楷体'>idleproc<span lang=ZH-CN>内核线程的工作就是等待有处于就绪态的进程或线程，如果有就调用</span>schedule<span
  lang=ZH-CN>函数</span></span></p>
  </td>
 </tr>
 <tr>
  <td width=44 valign=top style='width:43.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-family:楷体'>5</span></p>
  </td>
  <td width=139 valign=top style='width:138.5pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-family:楷体'>sync.h::lock</span></p>
  </td>
  <td width=263 valign=top style='width:262.5pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=ZH-CN style='font-family:楷体'>在获取锁的过程中，如果无法得到锁，则主动放弃</span><span
  style='font-family:楷体'>CPU<span lang=ZH-CN>控制权</span></span></p>
  </td>
 </tr>
 <tr>
  <td width=44 valign=top style='width:43.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-family:楷体'>6</span></p>
  </td>
  <td width=139 valign=top style='width:138.5pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-family:楷体'>trap.c::trap</span></p>
  </td>
  <td width=263 valign=top style='width:262.5pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=ZH-CN style='font-family:楷体'>如果在当前进程在用户态被打断去，且当前进程控制块的成员变量</span><span
  style='font-family:楷体'>need_resched<span lang=ZH-CN>设置为</span>1<span
  lang=ZH-CN>，则当前线程会放弃</span>CPU<span lang=ZH-CN>控制权</span></span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>仔细分析上述位置，第</span><span
style='font-size:12.0pt;font-family:楷体'>1<span lang=ZH-CN>、</span>2<span
lang=ZH-CN>、</span>5<span lang=ZH-CN>处的执行位置体现了由于获取某种资源一时等不到满足、进程要退出、进程要睡眠等原因而不得不主动放弃</span>CPU<span
lang=ZH-CN>。第</span>3<span lang=ZH-CN>、</span>4<span lang=ZH-CN>处的执行位置比较特殊，</span>initproc<span
lang=ZH-CN>内核线程等待用户进程结束而执行</span>schedule<span lang=ZH-CN>函数；</span>idle<span
lang=ZH-CN>内核线程在没有进程处于就绪态时才执行，一旦有了就绪态的进程，它将执行</span>schedule<span lang=ZH-CN>函数完成进程调度。这里只有第</span>6<span
lang=ZH-CN>处的位置比较特殊：</span></span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=487 valign=top style='width:487.0pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体;color:navy'>if</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>(!</span></b><span style='font-size:10.0pt;font-family:
  楷体'>in_kernel<b>)</b></span><span style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>{</span></b><span style='font-size:
  10.0pt;font-family:楷体;color:gray'><br>
              <span lang=ZH-CN>……</span></span></p>
  <p><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体;color:navy'>if</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>(</span></b><span style='font-size:10.0pt;font-family:
  楷体'>current<b>-&gt;</b>need_resched<b>)</b></span><span style='font-size:
  10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:10.0pt;font-family:
  楷体'>{</span></b><span style='font-size:10.0pt;font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体'>schedule<b>();</b><span
  style='color:gray'><br>
  </span></span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>}</span></b><span style='font-size:
  10.0pt;font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>}</span></b></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>这里表明了只有当进程在用户态执行到“任意”某处用户代码位置时发生了中断，且当前进程控制块成员变量</span><span
style='font-size:12.0pt;font-family:楷体'>need_resched<span lang=ZH-CN>为</span>1<span
lang=ZH-CN>（表示需要调度了）时，才会执行</span>shedule<span lang=ZH-CN>函数。这实际上体现了对用户进程的可抢占性。如果没有第一行的</span>if<span
lang=ZH-CN>语句，那么就可以体现对内核代码的可抢占性。但如果要把这一行</span>if<span lang=ZH-CN>语句去掉，我们就不得不实现对</span>ucore<span
lang=ZH-CN>中的所有全局变量的互斥访问操作，以防止所谓的</span>race condition<span lang=ZH-CN>现象，这样</span>ucore<span
lang=ZH-CN>的实现复杂度会增加不少。</span></span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
style='font-size:12.0pt'>3.4.2 </span></b><b><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>进程切换过程</span></b></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>进程调度函数</span><span
style='font-size:12.0pt;font-family:楷体'>schedule<span lang=ZH-CN>选择了下一个将占用</span>CPU<span
lang=ZH-CN>执行的进程后，将调用进程切换，从而让新的进程得以执行。通过实验四和实验五的理解，应该已经对进程调度和上下文切换有了初步的认识。在实验五中，结合调度器框架的设计，可对</span>
ucore <span lang=ZH-CN>中的进程切换以及堆栈的维护和使用等有更加深刻的认识。假定有两个用户进程，在二者进行进程切换的过程中，具体的步骤如下：</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>首先在执行某进程</span><span
style='font-size:12.0pt;font-family:楷体'>A<span lang=ZH-CN>的用户代码时，出现了一个</span>
trap  (<span lang=ZH-CN>例如是一个外设产生的中断</span>)<span lang=ZH-CN>，这 个时候就会从进程</span>A<span
lang=ZH-CN>的用户态切换到内核态</span>(<span lang=ZH-CN>过程</span>(1))<span lang=ZH-CN>，并且保存好进程</span>A<span
lang=ZH-CN>的</span>trapframe<span lang=ZH-CN>； 当内核态处理中断时发现需要进行进程切换时，</span>ucore<span
lang=ZH-CN>要通过</span>schedule<span lang=ZH-CN>函数选择下一个将占用</span>CPU<span
lang=ZH-CN>执行的进程（即进程</span>B<span lang=ZH-CN>），然后会调用</span>proc_run<span
lang=ZH-CN>函数，</span>proc_run<span lang=ZH-CN>函数进一步调用</span>switch_to<span
lang=ZH-CN>函数，切换到进程</span>B<span lang=ZH-CN>的内核态</span>(<span lang=ZH-CN>过程</span>(2))<span
lang=ZH-CN>，继续进程</span>B<span lang=ZH-CN>上一次在内核态的操作，并通过</span>iret<span
lang=ZH-CN>指令，最终将执行权转交给进程</span>B<span lang=ZH-CN>的用户空间</span>(<span
lang=ZH-CN>过程</span>(3))<span lang=ZH-CN>。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>当进程</span><span
style='font-size:12.0pt;font-family:楷体'>B<span lang=ZH-CN>由于某种原因发生中断之后</span>(<span
lang=ZH-CN>过程</span>(4))<span lang=ZH-CN>，会从进程</span>B<span lang=ZH-CN>的用户态切换到内核态，并且保存好进程</span>B<span
lang=ZH-CN>的</span>trapframe<span lang=ZH-CN>；当内核态处理中断时发现需要进行进程切换时，即需要切换到进程</span>A<span
lang=ZH-CN>，</span>ucore<span lang=ZH-CN>再次切换到进程</span>A(<span lang=ZH-CN>过程</span>(5))<span
lang=ZH-CN>，会执行进程</span>A<span lang=ZH-CN>上一次在内核调用</span> schedule (<span
lang=ZH-CN>具体还要跟踪到</span> switch_to <span lang=ZH-CN>函数</span>) <span
lang=ZH-CN>函数返回后的下一行代码，这行代码当然还是在进程</span>A<span lang=ZH-CN>的上一次中断处理流程中。最后当进程</span>
A<span lang=ZH-CN>的中断处理完毕的时候，执行权又会反交给进程</span>A<span lang=ZH-CN>的用户代码</span>(<span
lang=ZH-CN>过程</span>(6))<span lang=ZH-CN>。这就是在只有两个进程的情况下，进程切换间的大体流程。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>几点需要强调的是：</span></p>

<p class=MsoNormal style='margin-top:.9pt;margin-right:0cm;margin-bottom:0cm;
margin-left:14.15pt;margin-bottom:.0001pt;text-autospace:none'><span
style='font-size:12.0pt;font-family:楷体;color:black'>a) </span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:black;letter-spacing:-.05pt'>需要透彻理解</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black;letter-spacing:
-.25pt'>在</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black;letter-spacing:-.05pt'>进程切换以</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:black'>后，<span style='letter-spacing:
-.05pt'>程序是从哪里开始执行</span>的<span style='letter-spacing:-.15pt'>？需要注意到</span><span
style='letter-spacing:-.05pt'>虽然指令还是同一</span>个</span><span style='font-size:
12.0pt;font-family:楷体;color:black'>cpu<span lang=ZH-CN>上执行</span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>，但是此时已经是另外一个进程在执行了，且使用的资源已经完全不同了。</span></p>

<p class=MsoNormal style='margin-top:.9pt;margin-right:0cm;margin-bottom:0cm;
margin-left:14.15pt;margin-bottom:.0001pt;text-autospace:none'><span
style='font-size:12.0pt;font-family:楷体;color:black'>b)  <span lang=ZH-CN>内核在第一个程序运行的时候，需要进行哪些操作？有了实验四和实验五的经验，可以确定，内核启动第一个用户进程的过程，实际上是从进程启动时的内核状态切换到该用户进程的内核状态的过程，而且该用户进程在用户态的起始入口应该是</span>forkret<span
lang=ZH-CN>。</span></span></p>

<p class=MsoNormal align=left style='margin-left:5.65pt;text-align:left;
text-autospace:none'><b><span style='font-size:14.0pt'>3.5   </span></b><b><span
lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>调度框架和调度算法</span></b></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
style='font-size:12.0pt'>3.5.1 </span></b><b><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>设计思路</span></b></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>实行一个进程调度策略，到底需要实现哪些基本功能对应的数据结构？首先考虑到一个无论哪种调度算法都需要选择一个就绪进程来占用</span><span
style='font-size:12.0pt;font-family:楷体'>CPU<span lang=ZH-CN>运行。为此我们可把就绪进程组织起来，可用队列（双向链表）、二叉树、红黑树、数组…等不同的组织方式。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在操作方面，如果需要选择一个就绪进程，就可以从基于某种组织方式的就绪进程集合中选择出一个进程执行。需要注意，这里“选择”和“出”是两个操作，选择是在集合中挑选一个“合适”的进程，“出”意味着离开就绪进程集合。另外考虑到一个处于运行态的进程还会由于某种原因（比如时间片用完了）回到就绪态而不能继续占用</span><span
style='font-size:12.0pt;font-family:楷体'>CPU<span lang=ZH-CN>执行，这就会重新进入到就绪进程集合中。这两种情况就形成了调度器相关的三个基本操作：在就绪进程集合中选择、进入就绪进程集合和离开就绪进程集合。这三个操作属于调度器的基本操作。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在进程的执行过程中，就绪进程的等待时间和执行进程的执行时间是影响调度选择的重要因素，这两个因素随着时间的流逝和各种事件的发生在不停地变化，比如处于就绪态的进程等待调度的时间在增长，处于运行态的进程所消耗的时间片在减少等。这些进程状态变化的情况需要及时让进程调度器知道，便于选择更合适的进程执行。所以这种进程变化的情况就形成了调度器相关的一个变化感知操作：</span><span
style='font-size:12.0pt;font-family:楷体'> timer<span lang=ZH-CN>时间事件感知操作。这样在进程运行或等待的过程中，调度器可以调整进程控制块中与进程调度相关的属性值（比如消耗的时间片、进程优先级等），并可能导致对进程组织形式的调整（比如以时间片大小的顺序来重排双向链表等），并最终可能导致调选择新的进程占用</span>CPU<span
lang=ZH-CN>运行。这个操作属于调度器的进程调度属性调整操作。</span></span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
style='font-size:12.0pt'>3.5.2 </span></b><b><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>数据结构</span></b></p>

<p class=MsoNormal align=left style='margin-top:1.4pt;margin-right:0cm;
margin-bottom:0cm;margin-left:5.3pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:14.0pt;font-family:楷体'>在理解框架之前，需要先了解一下调度器框架所需要的数据结构。</span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'> 通常的操作系统中，进程池是很大的（虽然在</span><span
style='font-size:12.0pt;font-family:楷体'> ucore <span lang=ZH-CN>中，</span>MAX_PROCESS
<span lang=ZH-CN>很小）。 在</span> ucore <span lang=ZH-CN>中，调度器引入</span> run-queue<span
lang=ZH-CN>（简称</span>rq, <span lang=ZH-CN>即运行队列）的概念，通过链表结构管理进程。</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'> 由于目前</span><span
style='font-size:12.0pt;font-family:楷体'> ucore <span lang=ZH-CN>设计运行在单</span>
CPU<span lang=ZH-CN>上，其内部只有一个全局的运行队列，用来管理系统内全部的进程。</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'> 运行队列通过链表的形式进行组织。链表的每一个节点是一个</span><span
style='font-size:12.0pt;font-family:楷体'>list_entry_t, <span lang=ZH-CN>每个</span>list_entry_t
<span lang=ZH-CN>又对应到了</span> struct proc_struct *, <span lang=ZH-CN>这其间的转换是通过宏</span>
le2proc <span lang=ZH-CN>来完成 的。具体来说，我们知道在</span> struct proc_struct <span
lang=ZH-CN>中有一个叫</span> run_link <span lang=ZH-CN>的</span> list_entry_t<span
lang=ZH-CN>， 因此可以通过偏移量逆向找到对因某个</span> run_list<span lang=ZH-CN>的</span> struct
proc_struct<span lang=ZH-CN>。即 </span></span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>进程结构指针</span><span style='font-size:12.0pt;font-family:
楷体'> proc = le2proc(<span lang=ZH-CN>链表节点指针</span>, run_link)<span lang=ZH-CN>。</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt;text-autospace:
none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'> 为了保证调度器接口的通用性，</span><span
style='font-size:12.0pt;font-family:楷体'>ucore <span lang=ZH-CN>调度框架定义了如下接口，该接口中，几乎全部成员变量均为函数指针。具体的功能会在后面的框架说明中介绍。</span></span></p>

<p class=MsoNormal style='text-indent:21.0pt;text-autospace:none'><span
style='font-family:楷体'>&nbsp;</span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:26.7pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=376 valign=top style='width:375.6pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>1   struct sched_class {</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>2   // <span lang=ZH-CN>调度器的名字</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>3   const char *name;</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>4   // <span lang=ZH-CN>初始化运行队列</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>5   void (*init) (struct run_queue *rq);</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>6   // <span lang=ZH-CN>将进程</span> p <span lang=ZH-CN>插入队列</span>
  rq</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>7   void (*enqueue) (struct run_queue *rq, struct proc_struct
  *p);</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>8   // <span lang=ZH-CN>将进程</span> p <span lang=ZH-CN>从队列</span>
  rq <span lang=ZH-CN>中删除</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>9   void (*dequeue) (struct run_queue *rq, struct proc_struct
  *p);</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>10  // <span lang=ZH-CN>返回 运行队列 中下一个可执行的进程</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>11  struct proc_struct* (*pick_next) (struct run_queue *rq);</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>12  // timetick <span lang=ZH-CN>处理函数</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>13  void (*proc_tick)(struct  run_queue* rq, struct
  proc_struct* p);</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>14  };</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='text-indent:21.0pt;text-autospace:none'><span
style='font-family:楷体'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-top:2.45pt;margin-right:0cm;
margin-bottom:0cm;margin-left:21.65pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:宋体;
color:black'>•</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black;letter-spacing:1.55pt'> </span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体;color:black'>此外，</span><span style='font-size:12.0pt;
font-family:楷体;color:black'>pr<span style='letter-spacing:.3pt'>o</span>c.h<span
style='letter-spacing:2.4pt'> </span></span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体;color:black'>中的</span><span style='font-size:12.0pt;
font-family:楷体;color:black'> struct proc_struct <span lang=ZH-CN>中也记录了一些调度相关的信息：</span></span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:26.7pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=376 valign=top style='width:375.6pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>1   struct proc_struct {</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>2   // . . .</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>3   // <span lang=ZH-CN>该进程是否需要调度，只对当前进程有效</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>4   volatile bool need_resched;</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>5   // <span lang=ZH-CN>该进程的调度链表结构，该结构内部的连接组成了 运行队列 列表</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>6   list_entry_t run_link;</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>7   // <span lang=ZH-CN>该进程剩余的时间片，只对当前进程有效</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>8   int time_slice;</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>9   // round-robin <span lang=ZH-CN>调度器并不会用到以下成员</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>10  // <span lang=ZH-CN>该进程在优先队列中的节点，仅在</span> LAB6 <span
  lang=ZH-CN>使用</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>11  skew_heap_entry_t  lab6_run_pool;</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>12  // <span lang=ZH-CN>该进程的调度优先级，仅在</span> LAB6 <span
  lang=ZH-CN>使用</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>13  uint32_t lab6_priority;</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>14  // <span lang=ZH-CN>该进程的调度步进值，仅在</span> LAB6 <span
  lang=ZH-CN>使用</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>15  uint32_t lab6_stride;</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-size:9.0pt;
  font-family:楷体'>16  };</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal align=left style='margin-top:2.45pt;margin-right:0cm;
margin-bottom:0cm;margin-left:21.65pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span style='font-size:11.0pt;font-family:楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在此次实验中，你需要了解</span><span
style='font-size:12.0pt;font-family:楷体'> default_sched.c <span lang=ZH-CN>中的实现</span>RR<span
lang=ZH-CN>调度算法的函数。在该文件中，你可以看到</span>ucore <span lang=ZH-CN>已经为</span> RR <span
lang=ZH-CN>调度算法创建好了一个名为</span> RR_sched_class <span lang=ZH-CN>的调度策略类。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>通过数据结构</span><span
style='font-size:12.0pt;font-family:楷体'> struct run_queue <span lang=ZH-CN>来描述完整的
</span>run_queue<span lang=ZH-CN>（运行队列）。它的主要结构如下：</span></span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:26.7pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=376 valign=top style='width:375.6pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='text-autospace:none'><span style='font-family:楷体;
  color:black'>1   struct run_queue {</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-family:楷体;
  color:black'>2   //<span lang=ZH-CN>其运行队列的哨兵结构，可以看作是队列头和尾</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-family:楷体;
  color:black'>3   list_entry_t run_list;</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-family:楷体;
  color:black'>4   //<span lang=ZH-CN>优先队列形式的进程容器，只在</span> LAB6 <span
  lang=ZH-CN>中使用</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-family:楷体;
  color:black'>5   skew_heap_entry_t  *lab6_run_pool;</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-family:楷体;
  color:black'>6   //<span lang=ZH-CN>表示其内部的进程总数</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-family:楷体;
  color:black'>7   unsigned int proc_num;</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-family:楷体;
  color:black'>8   //<span lang=ZH-CN>每个进程一轮占用的最多时间片</span></span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-family:楷体;
  color:black'>9   int max_time_slice;</span></p>
  <p class=MsoNormal style='text-autospace:none'><span style='font-family:楷体;
  color:black'>10  };</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='text-indent:21.0pt;text-autospace:none'><span
style='font-family:楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt;text-autospace:none'><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>在</span><span
style='font-size:12.0pt;font-family:楷体'> ucore <span lang=ZH-CN>框架中，运行队列存储的是当前可以调度的进程，所以，只有状态为</span>
runnable<span lang=ZH-CN>的进程才能够进入运行队列。当前正在运行的进程并不会在运行队列中，这一点需要注意。</span></span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
style='font-size:12.0pt'>3.5.3 </span></b><b><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>调度点的相关关键函数</span></b></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>虽然进程各种状态变化的原因和导致的调度处理各异，但其实仔细观察各个流程的共性部分，会发现其中只涉及了三个关键调度相关函数：</span><span
style='font-size:12.0pt;font-family:楷体'>wakup_proc<span lang=ZH-CN>、</span>shedule<span
lang=ZH-CN>、</span>run_timer_list<span lang=ZH-CN>。如果我们能够让这三个调度相关函数的实现与具体调度算法无关，那么就可以认为</span>ucore<span
lang=ZH-CN>实现了一个与调度算法无关的调度框架。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt;
font-family:楷体'>wakeup_proc<span lang=ZH-CN>函数其实完成了把一个就绪进程放入到就绪进程队列中的工作，为此还调用了一个调度类接口函数</span>sched_class_enqueue<span
lang=ZH-CN>，这使得</span>wakeup_proc<span lang=ZH-CN>的实现与具体调度算法无关。</span>schedule<span
lang=ZH-CN>函数完成了与调度框架和调度算法相关三件事情</span>:<span lang=ZH-CN>把当前继续占用</span>CPU<span
lang=ZH-CN>执行的运行进程放放入到就绪进程队列中，从就绪进程队列中选择一个“合适”就绪进程，把这个“合适”的就绪进程从就绪进程队列中摘除。通过调用三个调度类接口函数</span>sched_class_enqueue<span
lang=ZH-CN>、</span>sched_class_pick_next<span lang=ZH-CN>、</span>sched_class_enqueue<span
lang=ZH-CN>来使得完成这三件事情与具体的调度算法无关。</span>run_timer_list<span lang=ZH-CN>函数在每次</span>timer<span
lang=ZH-CN>中断处理过程中被调用，从而可用来调用调度算法所需的</span></span><span style='font-size:12.0pt;
font-family:楷体'>timer<span lang=ZH-CN>时间事件感知操作，</span></span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>调整相关进程的</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>进程调度相关的属性值。通过调用</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>调度类接口函数</span><span style='font-size:
12.0pt;font-family:楷体'>sched_class_proc_tick<span lang=ZH-CN>使得此操作与具体调度算法无关。</span></span></p>

<p class=MsoNormal style='text-indent:25.5pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>这里涉及了一系列调度类接口函数：</span></p>

<p class=1 style='margin-left:45.4pt;text-indent:-21.0pt'><span
style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:楷体'>sched_class_enqueue</span></p>

<p class=1 style='margin-left:45.4pt;text-indent:-21.0pt'><span
style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:楷体'>sched_class_dequeue</span></p>

<p class=1 style='margin-left:45.4pt;text-indent:-21.0pt'><span
style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:楷体'>sched_class_pick_next</span></p>

<p class=1 style='margin-left:45.4pt;text-indent:-21.0pt'><span
style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:楷体'>sched_class_proc_tick</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>这</span><span style='font-size:12.0pt;
font-family:楷体'>4<span lang=ZH-CN>个函数的实现其实就是调用某基于</span>sched_class<span
lang=ZH-CN>数据结构的特定调度算法实现的</span>4<span lang=ZH-CN>个指针函数。采用这样的调度类框架后，如果我们需要实现一个新的调度算法，则我们需要定义一个针对此算法的调度类的实例，一个就绪进程队列的组织结构描述就行了，其他的事情都可交给调度类框架来完成。</span></span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
style='font-size:12.0pt'>3.5.4 RR</span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>调度算法实现</span></b></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt;
font-family:楷体'>RR<span lang=ZH-CN>调度算法的调度思想 是让所有</span> runnable<span
lang=ZH-CN>态的进程分时轮流使用</span>CPU<span lang=ZH-CN>时间。</span>RR<span lang=ZH-CN>调度器维护当前</span>runnable<span
lang=ZH-CN>进程的有序运行队列。当前进程的时间片用完之后，调度器将当前进程放置到运行队列的尾部，再从其头部取出进程进行调度。</span>RR<span
lang=ZH-CN>调度算法的就绪队列在组织结构上也是一个双向链表，只是增加了一个成员变量，表明在此就绪进程队列中的最大执行时间片。而且在进程控制块</span>proc_struct<span
lang=ZH-CN>中增加了一个成员变量</span>time_slice<span lang=ZH-CN>，用来记录进程当前的可运行时间片段。这是由于</span>RR<span
lang=ZH-CN>调度算法需要考虑执行进程的运行时间不能太长。在每个</span>timer<span lang=ZH-CN>到时的时候，操作系统会递减当前执行进程的</span>time_slice<span
lang=ZH-CN>，当</span>time_slice<span lang=ZH-CN>为</span>0<span lang=ZH-CN>时，就意味着这个进程运行了一段时间（这个时间片段称为进程的时间片），需要把</span>CPU<span
lang=ZH-CN>让给其他进程执行，于是操作系统就需要让此进程重新回到</span>rq<span lang=ZH-CN>的队列尾，且重置此进程的时间片为就绪队列的成员变量最大时间片</span>max_time_slice<span
lang=ZH-CN>值，然后再从</span>rq<span lang=ZH-CN>的队列头取出一个新的进程执行。下面来分析一下其调度算法的实现。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt;
font-family:楷体'>RR_enqueue<span lang=ZH-CN>的函数实现如下表所示。即把某进程的进程控制块指针放入到</span>rq<span
lang=ZH-CN>队列末尾，且如果进程控制块的时间片为</span>0<span lang=ZH-CN>，则需要把它重置为</span>rq<span
lang=ZH-CN>成员变量</span>max_time_slice<span lang=ZH-CN>。这表示如果进程在当前的执行时间片已经用完，需要等到下一次有机会运行时，才能再执行一段时间。</span></span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=487 valign=top style='width:487.0pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p><b><span style='font-size:10.0pt;font-family:楷体;color:navy'>static</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体;color:navy'>void</span></b><span style='font-size:10.0pt;
  font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;font-family:楷体'>RR_enqueue<b>(<span
  style='color:navy'>struct</span></b></span><span style='font-size:10.0pt;
  color:gray'>&nbsp;</span><span style='font-size:10.0pt;font-family:楷体'>run_queue</span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>*</span></b><span style='font-size:10.0pt;font-family:
  楷体'>rq<b>,</b></span><span style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体;color:navy'>struct</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><span style='font-size:10.0pt;
  font-family:楷体'>proc_struct</span><span style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>*</span></b><span style='font-size:
  10.0pt;font-family:楷体'>proc<b>)</b></span><span style='font-size:10.0pt;
  color:gray'>&nbsp;</span><b><span style='font-size:10.0pt;font-family:楷体'>{</span></b><span
  style='font-size:10.0pt;font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体'>assert<b>(</b>list_empty<b>(&amp;(</b>proc<b>-&gt;</b>run_link<b>)));</b><span
  style='color:gray'><br>
  </span></span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体'>list_add_before<b>(&amp;(</b>rq<b>-&gt;</b>run_list<b>),</b></span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>&amp;(</span></b><span style='font-size:10.0pt;
  font-family:楷体'>proc<b>-&gt;</b>run_link<b>));</b><span style='color:gray'><br>
  </span></span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体;color:navy'>if</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>(</span></b><span style='font-size:10.0pt;font-family:
  楷体'>proc<b>-&gt;</b>time_slice</span><span style='font-size:10.0pt;
  color:gray'>&nbsp;</span><b><span style='font-size:10.0pt;font-family:楷体'>==</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><span style='font-size:10.0pt;
  font-family:楷体;color:teal'>0</span><span style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>||</span></b><span style='font-size:
  10.0pt;color:gray'>&nbsp;</span><span style='font-size:10.0pt;font-family:
  楷体'>proc<b>-&gt;</b>time_slice</span><span style='font-size:10.0pt;
  color:gray'>&nbsp;</span><b><span style='font-size:10.0pt;font-family:楷体'>&gt;</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><span style='font-size:10.0pt;
  font-family:楷体'>rq<b>-&gt;</b>max_time_slice<b>)</b></span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>{</span></b><span style='font-size:10.0pt;font-family:
  楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体'>proc<b>-&gt;</b>time_slice</span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>=</span></b><span style='font-size:10.0pt;color:gray'>&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体'>rq<b>-&gt;</b>max_time_slice<b>;</b><span
  style='color:gray'><br>
  </span></span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>}</span></b><span style='font-size:
  10.0pt;font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体'>proc<b>-&gt;</b>rq</span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>=</span></b><span style='font-size:10.0pt;color:gray'>&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体'>rq<b>;</b><span style='color:gray'><br>
  </span></span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体'>rq<b>-&gt;</b>proc_num</span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>++;</span></b><span style='font-size:10.0pt;
  font-family:楷体;color:gray'><br>
  </span><b><span style='font-size:10.0pt;font-family:楷体'>}</span></b></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='text-indent:25.5pt'><span style='font-family:楷体;
color:black'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt;
font-family:楷体'>RR_pick_next<span lang=ZH-CN>的函数实现如下表所示。</span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>即选取就绪进程队列</span><span
style='font-size:12.0pt;font-family:楷体;color:black'>rq<span lang=ZH-CN>中的队头队列元素，并把队列元素转换成进程控制块指针。</span></span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=487 valign=top style='width:487.0pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p><b><span style='font-size:10.0pt;font-family:楷体;color:navy'>static</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体;color:navy'>struct</span></b><span style='font-size:
  10.0pt;color:gray'>&nbsp;</span><span style='font-size:10.0pt;font-family:
  楷体'>proc_struct</span><span style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>*</span></b><span style='font-size:
  10.0pt;font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;font-family:楷体'>FCFS_pick_next<b>(<span
  style='color:navy'>struct</span></b></span><span style='font-size:10.0pt;
  color:gray'>&nbsp;</span><span style='font-size:10.0pt;font-family:楷体'>run_queue</span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>*</span></b><span style='font-size:10.0pt;font-family:
  楷体'>rq<b>)</b></span><span style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>{</span></b><span style='font-size:
  10.0pt;font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体'>list_entry_t</span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>*</span></b><span style='font-size:10.0pt;font-family:
  楷体'>le</span><span style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>=</span></b><span style='font-size:
  10.0pt;color:gray'>&nbsp;</span><span style='font-size:10.0pt;font-family:
  楷体'>list_next<b>(&amp;(</b>rq<b>-&gt;</b>run_list<b>));</b><span
  style='color:gray'><br>
  </span></span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体;color:navy'>if</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>(</span></b><span style='font-size:10.0pt;font-family:
  楷体'>le</span><span style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>!=</span></b><span style='font-size:
  10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:10.0pt;font-family:
  楷体'>&amp;(</span></b><span style='font-size:10.0pt;font-family:楷体'>rq<b>-&gt;</b>run_list<b>))</b></span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>{</span></b><span style='font-size:10.0pt;font-family:
  楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体;color:navy'>return</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><span style='font-size:10.0pt;
  font-family:楷体'>le2proc<b>(</b>le<b>,</b></span><span style='font-size:10.0pt;
  color:gray'>&nbsp;</span><span style='font-size:10.0pt;font-family:楷体'>run_link<b>);</b><span
  style='color:gray'><br>
  </span></span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>}</span></b><span style='font-size:
  10.0pt;font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体;color:navy'>return</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><span style='font-size:10.0pt;
  font-family:楷体'>NULL<b>;</b><span style='color:gray'><br>
  </span><b>}</b></span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal><span style='font-family:楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt;
font-family:楷体'>RR_dequeue<span lang=ZH-CN>的函数实现如下表所示。</span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>即把就绪进程队列</span><span
style='font-size:12.0pt;font-family:楷体;color:black'>rq<span lang=ZH-CN>的进程控制块指针的队列元素删除，并把表示就绪进程个数的</span>proc_num<span
lang=ZH-CN>减一。</span></span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=487 valign=top style='width:487.0pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p><b><span style='font-size:10.0pt;font-family:楷体;color:navy'>static</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体;color:navy'>void</span></b><span style='font-size:10.0pt;
  font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;font-family:楷体'>FCFS_dequeue<b>(<span
  style='color:navy'>struct</span></b></span><span style='font-size:10.0pt;
  color:gray'>&nbsp;</span><span style='font-size:10.0pt;font-family:楷体'>run_queue</span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>*</span></b><span style='font-size:10.0pt;font-family:
  楷体'>rq<b>,</b></span><span style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体;color:navy'>struct</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><span style='font-size:10.0pt;
  font-family:楷体'>proc_struct</span><span style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>*</span></b><span style='font-size:
  10.0pt;font-family:楷体'>proc<b>)</b></span><span style='font-size:10.0pt;
  color:gray'>&nbsp;</span><b><span style='font-size:10.0pt;font-family:楷体'>{</span></b><span
  style='font-size:10.0pt;font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体'>assert<b>(!</b>list_empty<b>(&amp;(</b>proc<b>-&gt;</b>run_link<b>))</b></span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>&amp;&amp;</span></b><span style='font-size:10.0pt;
  color:gray'>&nbsp;</span><span style='font-size:10.0pt;font-family:楷体'>proc<b>-&gt;</b>rq</span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>==</span></b><span style='font-size:10.0pt;color:gray'>&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体'>rq<b>);</b><span style='color:gray'><br>
  </span></span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体'>list_del_init<b>(&amp;(</b>proc<b>-&gt;</b>run_link<b>));</b><span
  style='color:gray'><br>
  </span></span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体'>rq<b>-&gt;</b>proc_num</span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>--;</span></b><span style='font-size:10.0pt;
  font-family:楷体;color:gray'><br>
  </span><b><span style='font-size:10.0pt;font-family:楷体'>}</span></b></p>
  </td>
 </tr>
</table>

<p class=MsoNormal><span style='font-family:楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt;
font-family:楷体'>RR_proc_tick<span lang=ZH-CN>的函数实现如下表所示。</span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>即每次</span><span
style='font-size:12.0pt;font-family:楷体;color:black'>timer<span lang=ZH-CN>到时后，</span>trap<span
lang=ZH-CN>函数将会间接调用此函数来把当前执行进程的时间片</span>time_slice<span lang=ZH-CN>减一。如果</span>time_slice<span
lang=ZH-CN>降到零，则设置此进程成员变量</span>need_resched<span lang=ZH-CN>标识为</span>1<span
lang=ZH-CN>，这样在下一次中断来后执行</span>trap<span lang=ZH-CN>函数时，会由于当前进程程成员变量</span>need_resched<span
lang=ZH-CN>标识为</span>1<span lang=ZH-CN>而执行</span>schedule<span lang=ZH-CN>函数，从而把当前执行进程放回就绪队列末尾，而从就绪队列头取出在就绪队列上等待时间最久的那个就绪进程执行。</span></span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=487 valign=top style='width:487.0pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p><b><span style='font-size:10.0pt;font-family:楷体;color:navy'>static</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体;color:navy'>void</span></b><span style='font-size:10.0pt;
  font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;font-family:楷体'>RR_proc_tick<b>(<span
  style='color:navy'>struct</span></b></span><span style='font-size:10.0pt;
  color:gray'>&nbsp;</span><span style='font-size:10.0pt;font-family:楷体'>run_queue</span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>*</span></b><span style='font-size:10.0pt;font-family:
  楷体'>rq<b>,</b></span><span style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体;color:navy'>struct</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><span style='font-size:10.0pt;
  font-family:楷体'>proc_struct</span><span style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>*</span></b><span style='font-size:
  10.0pt;font-family:楷体'>proc<b>)</b></span><span style='font-size:10.0pt;
  color:gray'>&nbsp;</span><b><span style='font-size:10.0pt;font-family:楷体'>{</span></b><span
  style='font-size:10.0pt;font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体;color:navy'>if</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>(</span></b><span style='font-size:10.0pt;font-family:
  楷体'>proc<b>-&gt;</b>time_slice</span><span style='font-size:10.0pt;
  color:gray'>&nbsp;</span><b><span style='font-size:10.0pt;font-family:楷体'>&gt;</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><span style='font-size:10.0pt;
  font-family:楷体;color:teal'>0</span><b><span style='font-size:10.0pt;
  font-family:楷体'>)</span></b><span style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>{</span></b><span style='font-size:
  10.0pt;font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体'>proc<b>-&gt;</b>time_slice</span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>--;</span></b><span style='font-size:10.0pt;
  font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>}</span></b><span style='font-size:
  10.0pt;font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体;color:navy'>if</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>(</span></b><span style='font-size:10.0pt;font-family:
  楷体'>proc<b>-&gt;</b>time_slice</span><span style='font-size:10.0pt;
  color:gray'>&nbsp;</span><b><span style='font-size:10.0pt;font-family:楷体'>==</span></b><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><span style='font-size:10.0pt;
  font-family:楷体;color:teal'>0</span><b><span style='font-size:10.0pt;
  font-family:楷体'>)</span></b><span style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>{</span></b><span style='font-size:
  10.0pt;font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体'>proc<b>-&gt;</b>need_resched</span><span
  style='font-size:10.0pt;color:gray'>&nbsp;</span><b><span style='font-size:
  10.0pt;font-family:楷体'>=</span></b><span style='font-size:10.0pt;color:gray'>&nbsp;</span><span
  style='font-size:10.0pt;font-family:楷体;color:teal'>1</span><b><span
  style='font-size:10.0pt;font-family:楷体'>;</span></b><span style='font-size:
  10.0pt;font-family:楷体;color:gray'><br>
  </span><span style='font-size:10.0pt;color:gray'>&nbsp;&nbsp;&nbsp;&nbsp;</span><b><span
  style='font-size:10.0pt;font-family:楷体'>}</span></b><span style='font-size:
  10.0pt;font-family:楷体;color:gray'><br>
  </span><b><span style='font-size:10.0pt;font-family:楷体'>}</span></b></p>
  </td>
 </tr>
</table>

<p class=MsoNormal align=left style='margin-top:.2pt;text-align:left;
line-height:5.0pt;text-autospace:none'><span style='font-size:5.0pt;font-family:
楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:5.65pt;text-align:left;
text-autospace:none'><b><span style='font-size:14.0pt'>3.6   Stride Scheduling</span></b></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
style='font-size:12.0pt'>3.6.1 </span></b><b><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>基本思路</span></b></p>

<p class=MsoNormal style='text-indent:25.95pt'><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:red'>【提示】请先看练习</span></b><b><span
style='font-size:12.0pt;font-family:楷体;color:red'>2<span lang=ZH-CN>中提到的论文。理解后在看下面的内容。</span></span></b></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>考察</span><span style='font-size:12.0pt;
font-family:楷体'> round-robin <span lang=ZH-CN>调度器，在假设所有进程都充分使用了其拥有的</span> CPU <span
lang=ZH-CN>时间资源的情况下，所有进程得到的</span> CPU <span lang=ZH-CN>时间应该是相等的。但是有时候我们希望调度器能够更智能地为每个进程分配合理的</span>
CPU <span lang=ZH-CN>资源。假设我们为不同的进程分配不同的优先级，则我们有可能希望每个进程得到的时间资源与他们的优先级成正比关系。</span>Stride<span
lang=ZH-CN>调度是基于这种想法的一个较为典型和简单的算法。除了简单易于实现以外，它还有如下的特点：</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'> 可控性：如我们之前所希望的，可以证明</span><span
style='font-size:12.0pt;font-family:楷体'> Stride  Scheduling <span lang=ZH-CN>对进程的调度次数正比于其优先级。</span></span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:-.25pt'><span
lang=ZH-CN style='font-size:12.0pt;font-family:宋体'>•</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'> 确定性：在不考虑计时器事件的情况下，整个调度机制都是可预知和重现的。 该算法的基本思想可以考虑如下：</span></p>

<p class=MsoNormal style='margin-left:46.9pt;text-indent:-8.05pt'><span
style='font-size:12.0pt;font-family:楷体'>1.  <span lang=ZH-CN>为每个</span>runnable<span
lang=ZH-CN>的进程设置一个当前状态</span> stride<span lang=ZH-CN>，表示该进程当前的调度权。另外定义其对应的</span>pass
<span lang=ZH-CN>值，表示对应进程在调度后，</span>stride <span lang=ZH-CN>需要进行的累加值。</span></span></p>

<p class=MsoNormal style='margin-left:46.9pt;text-indent:-8.05pt'><span
style='font-size:12.0pt;font-family:楷体'>2.  <span lang=ZH-CN>每次需要调度时，从当前</span>
runnable <span lang=ZH-CN>态的进程中选择</span> stride  <span lang=ZH-CN>最小的进程调度。</span></span></p>

<p class=MsoNormal style='margin-left:46.9pt;text-indent:-8.05pt'><span
style='font-size:12.0pt;font-family:楷体'>3.  <span lang=ZH-CN>对于获得调度的进程</span>P<span
lang=ZH-CN>，将对应的</span>stride<span lang=ZH-CN>加上其对应的步长</span> pass<span
lang=ZH-CN>（只与进程的优先权有关系）。</span></span></p>

<p class=MsoNormal style='margin-left:46.9pt;text-indent:-8.05pt'><span
style='font-size:12.0pt;font-family:楷体'>4.  <span lang=ZH-CN>在一段固定的时间之后，回到</span>
2.<span lang=ZH-CN>步骤，重新调度当前</span>stride<span lang=ZH-CN>最小的进程。 可以证明，如果令</span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:84.0pt;
text-autospace:none'><span style='font-size:12.0pt;font-family:楷体'>P.pass
=BigStride / P.priority</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>其中</span><span style='font-size:12.0pt;
font-family:楷体'> P.priority <span lang=ZH-CN>表示进程的优先权（大于</span> 1<span
lang=ZH-CN>），而</span> BigStride <span lang=ZH-CN>表示一个预先定义的大常数，则该调度方案为每个进程分配的时间将与其优先级成正比。证明过程我们在这里略去，有兴趣的同学可以在网上查找相关资料。将该调度器应用到</span>
ucore <span lang=ZH-CN>的调度器框架中来，则需要将调度器接口实现如下：</span></span></p>

<p class=MsoNormal align=left style='margin-top:1.4pt;margin-right:0cm;
margin-bottom:0cm;margin-left:21.65pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体;
color:black'>•</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black;letter-spacing:2.65pt'> </span><span style='font-size:12.0pt;
font-family:楷体;color:black'>init:</span></p>

<p class=MsoNormal align=left style='margin-top:4.0pt;margin-right:0cm;
margin-bottom:0cm;margin-left:44.85pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>初始化调度器类的信息（如果有的话<span
style='letter-spacing:-3.25pt'>）</span>。</span></p>

<p class=MsoNormal align=left style='margin-left:44.85pt;text-align:left;
line-height:17.55pt;text-autospace:none'><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体;color:black;vertical-align:sub'>–</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:black;vertical-align:sub'> <span
style='letter-spacing:.7pt'> </span></span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体;color:black;vertical-align:sub;letter-spacing:.35pt'>初始化当前</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black;vertical-align:
sub'>的</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black;vertical-align:sub'>运行队列</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体;color:black;vertical-align:sub;letter-spacing:.35pt'>为一个空的容器结</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black;vertical-align:
sub'>构<span style='letter-spacing:-6.1pt'>。</span>（<span style='letter-spacing:
.35pt'>比如</span>和</span><span style='font-size:12.0pt;font-family:楷体;
color:black;vertical-align:sub'>RR<span lang=ZH-CN>调度算法</span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>一样，初始化为一个有序列表）</span></p>

<p class=MsoNormal align=left style='margin-left:21.65pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体;
color:black'>•</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black;letter-spacing:2.75pt'> </span><span style='font-size:12.0pt;
font-family:楷体;color:black'>enqueue</span></p>

<p class=MsoNormal align=left style='margin-top:4.0pt;margin-right:0cm;
margin-bottom:0cm;margin-left:44.85pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>初始化刚进入</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>运行</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>队列的进程<span
style='letter-spacing:-.55pt'> </span></span><span style='font-size:12.0pt;
font-family:楷体;color:black'>pr<span style='letter-spacing:.3pt'>o</span>c</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>的</span><span
style='font-size:12.0pt;font-family:楷体;color:black'>stride</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>属性。</span></p>

<p class=MsoNormal align=left style='margin-left:44.85pt;text-align:left;
line-height:17.55pt;text-autospace:none'><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体;color:black;vertical-align:sub'>–</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:black;vertical-align:sub'> <span
style='letter-spacing:.7pt'> </span></span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体;color:black;vertical-align:sub'>将<span style='letter-spacing:
-.15pt'> </span></span><span style='font-size:12.0pt;font-family:楷体;color:black;
vertical-align:sub'>pr<span style='letter-spacing:.3pt'>o</span>c</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black;vertical-align:
sub'>插入放入</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black;vertical-align:sub'>运行队列</span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体;color:black;vertical-align:sub'>中去（注意：这里并不要求放置在队列头部<span
style='letter-spacing:-3.25pt'>）</span>。</span></p>

<p class=MsoNormal align=left style='margin-left:21.65pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体;
color:black'>•</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black;letter-spacing:2.75pt'> </span><span style='font-size:12.0pt;
font-family:楷体;color:black'>dequeue</span></p>

<p class=MsoNormal align=left style='margin-top:4.0pt;margin-right:0cm;
margin-bottom:0cm;margin-left:44.85pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>从</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>运行队列</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>中删除相应的元素。</span></p>

<p class=MsoNormal align=left style='margin-left:21.65pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:宋体;
color:black'>•</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black;letter-spacing:1.55pt'> </span><span style='font-size:12.0pt;
font-family:楷体;color:black'>pi<span style='letter-spacing:-.3pt'>c</span>k<span
style='letter-spacing:1.75pt'> </span>next</span></p>

<p class=MsoNormal align=left style='margin-top:4.0pt;margin-right:0cm;
margin-bottom:0cm;margin-left:44.85pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>扫描整个</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>运行队列</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>，返回其中</span><span
style='font-size:12.0pt;font-family:楷体;color:black'>stride</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>值最小的对应进程。</span></p>

<p class=MsoNormal align=left style='margin-left:44.85pt;text-align:left;
line-height:17.55pt;text-autospace:none'><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体;color:black;vertical-align:sub'>–</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:black;vertical-align:sub'> <span
style='letter-spacing:.7pt'> </span></span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体;color:black;vertical-align:sub;letter-spacing:-.7pt'>更新对应进程</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black;vertical-align:
sub'>的</span><span style='font-size:12.0pt;font-family:楷体;color:black;
vertical-align:sub'>stride</span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体;color:black;vertical-align:sub'>值<span style='letter-spacing:
-3.4pt'>，</span>即</span></p>

<p class=MsoNormal align=left style='margin-left:44.85pt;text-align:left;
text-indent:30.0pt;line-height:17.55pt;text-autospace:none'><span
style='font-size:12.0pt;font-family:楷体;color:black;vertical-align:sub'>pass<span
style='letter-spacing:-.4pt'> </span>=<span style='letter-spacing:-.75pt'> </span>BIG<span
style='letter-spacing:-.9pt'>_</span>STRIDE<span style='letter-spacing:.35pt'> </span>/<span
style='letter-spacing:-.75pt'> </span>P<span style='letter-spacing:-.65pt'>-</span>&gt;priority;<span
style='letter-spacing:2.05pt'> </span>P<span style='letter-spacing:-.7pt'>-</span>&gt;stride</span><span
style='font-size:12.0pt;font-family:楷体;color:black'> +=<span style='letter-spacing:
.65pt'> </span>pass</span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体;color:black'>。</span></p>

<p class=MsoNormal style='text-indent:33.75pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:宋体;color:black'>•</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:black;letter-spacing:1.55pt'> </span><span
style='font-size:12.0pt;font-family:楷体'>proc tick:</span></p>

<p class=MsoNormal align=left style='margin-top:4.0pt;margin-right:0cm;
margin-bottom:0cm;margin-left:44.85pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black'>–</span><span style='font-size:12.0pt;font-family:楷体;color:black'> 
<span lang=ZH-CN>检测当前进程是否已用完分配的时间片。如果时间片用完，应该正确设置进程 结构的相关标记来引起进程切换。</span></span></p>

<p class=MsoNormal align=left style='margin-top:4.0pt;margin-right:0cm;
margin-bottom:0cm;margin-left:44.85pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:12.0pt;font-family:楷体;
color:black'>–</span><span style='font-size:12.0pt;font-family:楷体;color:black'> 
<span lang=ZH-CN>一个</span> process <span lang=ZH-CN>最多可以连续运行</span>
rq.max_time_slice<span lang=ZH-CN>个时间片。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>在具体实现时，有一个需要注意的地方：</span><span
style='font-size:12.0pt;font-family:楷体'>stride<span lang=ZH-CN>属性的溢出问题，在之前的实现里面
我们并没有考虑</span> stride  <span lang=ZH-CN>的数值范围，而这个值在理论上是不断增加的，在</span> stride<span
lang=ZH-CN>溢出以后，基于</span> stride<span lang=ZH-CN>的比较可能会出现错误。比如假设当前存在两个进程</span>A<span
lang=ZH-CN>和</span>B<span lang=ZH-CN>，</span>stride<span lang=ZH-CN>属性采用</span>16<span
lang=ZH-CN>位无符号整数进行存储。</span></span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体;color:black'>当前队列中元素如下（假设当前运行的进程已经被重新放置进</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体;color:black'>运行队列</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体;color:black'>中<span
style='letter-spacing:-3.25pt'>）</span>：</span></p>

<p class=MsoNormal align=left style='margin-top:.05pt;text-align:left;
line-height:12.0pt;text-autospace:none'>

<table cellpadding=0 cellspacing=0 align=left>
 <tr>
  <td width=32 height=0></td>
 </tr>
 <tr>
  <td></td>
  <td><img width=285 height=62 src="lab6.files/image001.png"></td>
 </tr>
</table>

<br clear=ALL>
</p>

<p class=MsoNormal align=left style='margin-left:27.1pt;text-align:left;
line-height:15.15pt;text-autospace:none'><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>此时应该选择<span style='letter-spacing:-.65pt'> </span></span><span
style='font-size:12.0pt;font-family:楷体'>A<span style='letter-spacing:1.15pt'> </span></span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>作为调度的进程，而在一轮调度后，队列将如下：</span></p>

<p class=MsoNormal align=left style='margin-top:.3pt;text-align:left;
line-height:10.0pt;text-autospace:none'>

<table cellpadding=0 cellspacing=0 align=left>
 <tr>
  <td width=29 height=0></td>
 </tr>
 <tr>
  <td></td>
  <td><img width=286 height=61 src="lab6.files/image002.png"></td>
 </tr>
</table>

<br clear=ALL>
</p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>可以看到由于溢出的出现，进程间</span><span
style='font-size:12.0pt;font-family:楷体'>stride<span lang=ZH-CN>的理论比较和实际比较结果出现了偏差。我们首先在理论上分析这个问题：令</span>PASS_MAX<span
lang=ZH-CN>为当前所有进程里最大的步进值。则我们可以证明如下结论：对每次</span> Stride <span lang=ZH-CN>调度器的调度步骤中，有其最大的步进值</span>STRIDE_MAX<span
lang=ZH-CN>和最小的步进值</span>STRIDE_MIN <span lang=ZH-CN>之差：</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt;
font-family:楷体'>STRIDE_MAX </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>–</span><span style='font-size:12.0pt;font-family:楷体'>
STRIDE_MIN &lt;= PASS_MAX</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>提问 </span><span style='font-size:12.0pt;
font-family:楷体'>1<span lang=ZH-CN>：如何证明该结论？ 有了该结论，在加上之前对优先级有</span>Priority
&gt; 1 <span lang=ZH-CN>限制，我们有</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt;
font-family:楷体'>STRIDE_MAX </span><span lang=ZH-CN style='font-size:12.0pt;
font-family:楷体'>–</span><span style='font-size:12.0pt;font-family:楷体'>
STRIDE_MIN &lt;= BIG_STRIDE</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>于是我们只要将</span><span style='font-size:
12.0pt;font-family:楷体'>BigStride<span lang=ZH-CN>取在某个范围之内，即可保证对于任意两个</span>
Stride <span lang=ZH-CN>之差都会在机器整数表示的范围之内。而我们可以通过其与</span>0<span lang=ZH-CN>的比较结构，来得到两个</span>
Stride<span lang=ZH-CN>的大小关系。在上例中，虽然在直接的数值表示上</span> 98 &lt; 65535<span
lang=ZH-CN>，但是</span> 98 - 65535 <span lang=ZH-CN>的结果用带符号的</span> 16<span
lang=ZH-CN>位整数表示的结果为</span>99, <span lang=ZH-CN>与理论值之差相等。所以在这个意义下</span> 98
&gt; 65535<span lang=ZH-CN>。 基于这种特殊考虑的比较方法，即便</span> Stride<span lang=ZH-CN>有可能溢出，我们仍能够得到理论上的当前最小</span>Stride<span
lang=ZH-CN>，并做出正确的调度决定。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>提问</span><span style='font-size:12.0pt;
font-family:楷体'> 2<span lang=ZH-CN>：在</span> ucore <span lang=ZH-CN>中，目前</span>
Stride<span lang=ZH-CN>是采用无符号的</span>32<span lang=ZH-CN>位整数表示。则</span>BigStride<span
lang=ZH-CN>应该取多少，才能保证比较的正确性？</span></span></p>

<p class=MsoNormal align=left style='margin-top:.15pt;text-align:left;
line-height:9.5pt;text-autospace:none'><span style='font-size:9.5pt;font-family:
楷体'>&nbsp;</span></p>

<p class=MsoNormal style='margin-right:34.95pt;text-autospace:none'><b><span
style='font-size:12.0pt'>3.6.2  </span></b><b><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>使用优先队列实现</span></b><b><span
style='font-size:12.0pt'> Stride Scheduling</span></b></p>

<p class=MsoNormal align=left style='text-align:left;line-height:6.0pt;
text-autospace:none'><span style='font-size:6.0pt;font-family:楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>在上述的实现描述中，对于每一次</span><span
style='font-size:12.0pt;font-family:楷体'>pick_next<span lang=ZH-CN>函数，我们都需要完整地扫描来获得当前最小的</span>stride<span
lang=ZH-CN>及其进程。这在进程非常多的时候是非常耗时和低效的，有兴趣的同学可以在实 现了基于列表扫描的</span>Stride<span
lang=ZH-CN>调度器之后比较一下</span>priority<span lang=ZH-CN>程序在</span>Round-Robin<span
lang=ZH-CN>及</span>Stride<span lang=ZH-CN>调度器下各自的运行时间。考虑到其调度选择于优先队列的抽象逻辑一致，我们考虑使用优化的优先队列数据结构实现该调度。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>优先队列是这样一种数据结构：使用者可以快速的插入和删除队列中的元素，并且在预先指定的顺序下快速取得当前在队列中的最小（或者最大）值及其对应元素。可以看到，这样的数据结构非常符合</span><span
style='font-size:12.0pt;font-family:楷体'> Stride  <span lang=ZH-CN>调度器的实现。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>本次实验提供了</span><span style='font-size:
12.0pt;font-family:楷体'>libs/skew_heap.h  <span lang=ZH-CN>作为优先队列的一个实现，该实现定义相关的结构和接口，其中主要包括：</span></span></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='margin-left:19.6pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=376 valign=top style='width:375.65pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:9.0pt;font-family:楷体'>1   // <span
  lang=ZH-CN>优先队列节点的结构</span></span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;font-family:楷体'>2   typedef
  struct skew_heap_entry  skew_heap_entry_t;</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;font-family:楷体'>3   // <span
  lang=ZH-CN>初始化一个队列节点</span></span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;font-family:楷体'>4   void
  skew_heap_init(skew_heap_entry_t *a);</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;font-family:楷体'>5   // <span
  lang=ZH-CN>将节点</span> b <span lang=ZH-CN>插入至以节点 </span>a <span lang=ZH-CN>为队列头的队列中去，返回插入后的队列</span></span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;font-family:楷体'>6   skew_heap_entry_t 
  *skew_heap_insert(skew_heap_entry_t  *a,</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;font-family:楷体'>7                                        skew_heap_entry_t 
  *b,</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;font-family:楷体'>8                                        compare_f
  comp);</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;font-family:楷体'>9   // <span
  lang=ZH-CN>将节点</span> b <span lang=ZH-CN>插入从以节点</span> a <span lang=ZH-CN>为队列头的队列中去，返回删除后的队列</span></span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;font-family:楷体'>10      skew_heap_entry_t 
  *skew_heap_remove(skew_heap_entry_t  *a,</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;font-family:楷体'>11                                          
  skew_heap_entry_t  *b,</span></p>
  <p class=MsoNormal><span style='font-size:9.0pt;font-family:楷体'>12                                          
  compare_f comp);</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal><span style='font-family:楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>其中优先队列的顺序是由比较函数</span><span
style='font-size:12.0pt;font-family:楷体'>comp<span lang=ZH-CN>决定的，</span>sched_stride.c<span
lang=ZH-CN>中提供了</span>proc_stride_comp_f<span lang=ZH-CN>比较器用来比较两个</span>stride<span
lang=ZH-CN>的大小，你可以直接使用它。当使用优先队列作为</span>Stride<span lang=ZH-CN>调度器的实现方式之后，运行队列结构也需要作相关改变，其中包括：</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:宋体'>•</span><span style='font-size:12.0pt;
font-family:楷体'> struct run_queue<span lang=ZH-CN>中的</span>lab6_run_pool<span
lang=ZH-CN>指针，在使用优先队列的实现中表示当前优先队列 的头元素，如果优先队列为空，则其指向空指针（</span>NULL<span
lang=ZH-CN>）。</span></span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:宋体'>•</span><span style='font-size:12.0pt;
font-family:楷体'> struct proc_struct<span lang=ZH-CN>中的</span>lab6_run_pool<span
lang=ZH-CN>结构，表示当前进程对应的优先队列节点。 本次实验已经修改了系统相关部分的代码，使得其能够很好地适应</span>LAB6 <span
lang=ZH-CN>新加入的数据结构和接口。而在实验中我们需要做的是用优先队列实现一个正确和高效的</span>Stride<span
lang=ZH-CN>调</span></span><span lang=ZH-CN style='font-size:12.0pt;font-family:
楷体;color:black'>度器，如果用较简略的伪代码描述，则有：</span></p>

<p class=MsoNormal align=left style='margin-top:.45pt;text-align:left;
line-height:7.5pt;text-autospace:none'><span style='font-size:7.5pt;font-family:
楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:21.65pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:宋体;
color:black'>•</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black;letter-spacing:1.55pt'> </span><span style='font-size:11.0pt;
font-family:楷体;color:black'>init(rq)</span><span style='font-size:11.0pt;
font-family:楷体;color:black'>:</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;text-align:left;
line-height:5.0pt;text-autospace:none'><span style='font-size:5.0pt;font-family:
楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:44.85pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
style='font-size:11.0pt;font-family:楷体;color:black'>Initialize<span
style='letter-spacing:2.4pt'> </span>rq-&gt;run_list</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;margin-right:0cm;
margin-bottom:0cm;margin-left:44.85pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
style='font-size:11.0pt;font-family:楷体;color:black'>Set<span style='letter-spacing:
.85pt'> </span>rq-&gt;lab6<span style='letter-spacing:.2pt'>_</span>run<span
style='letter-spacing:-.9pt'>_</span>pool<span style='letter-spacing:1.1pt'> </span>to<span
style='letter-spacing:.7pt'> </span>NULL</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;margin-right:0cm;
margin-bottom:0cm;margin-left:44.85pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
style='font-size:11.0pt;font-family:楷体;color:black'>Set<span style='letter-spacing:
.85pt'> </span>rq-&gt;proc<span style='letter-spacing:.2pt'>_</span>num<span
style='letter-spacing:.85pt'> </span>to<span style='letter-spacing:.7pt'> </span>0</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;text-align:left;
line-height:5.0pt;text-autospace:none'><span style='font-size:5.0pt;font-family:
楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:21.65pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:宋体;
color:black'>•</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black;letter-spacing:1.55pt'> </span><span style='font-size:11.0pt;
font-family:楷体;color:black'>enqueue(rq,<span style='letter-spacing:2.6pt'> </span>proc)</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;text-align:left;
line-height:5.0pt;text-autospace:none'><span style='font-size:5.0pt;font-family:
楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:44.85pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
style='font-size:11.0pt;font-family:楷体;color:black'>Initialize<span
style='letter-spacing:2.4pt'> </span>proc-&gt;time<span style='letter-spacing:
.65pt'>_</span>slice</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;margin-right:0cm;
margin-bottom:0cm;margin-left:44.85pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
style='font-size:11.0pt;font-family:楷体;color:black'>Insert<span
style='letter-spacing:1.5pt'> </span>proc-&gt;lab6<span style='letter-spacing:
.65pt'>_</span>run<span style='letter-spacing:-.9pt'>_</span>pool<span
style='letter-spacing:1.1pt'> </span>into<span style='letter-spacing:1.15pt'> </span>rq-&gt;lab6<span
style='letter-spacing:.2pt'>_</span>run<span style='letter-spacing:-.9pt'>_</span>pool</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;margin-right:0cm;
margin-bottom:0cm;margin-left:44.85pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
style='font-size:11.0pt;font-family:楷体;color:black'>rq-&gt;proc<span
style='letter-spacing:.15pt'>_</span>num<span style='letter-spacing:.9pt'> </span>++</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;text-align:left;
line-height:5.0pt;text-autospace:none'><span style='font-size:5.0pt;font-family:
楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:21.65pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:宋体;
color:black'>•</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black;letter-spacing:1.55pt'> </span><span style='font-size:11.0pt;
font-family:楷体;color:black'>dequeue(rq,<span style='letter-spacing:2.6pt'> </span>proc)</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;text-align:left;
line-height:5.0pt;text-autospace:none'><span style='font-size:5.0pt;font-family:
楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:44.85pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
style='font-size:11.0pt;font-family:楷体;color:black'>Remove<span
style='letter-spacing:1.5pt'> </span>proc-&gt;lab6<span style='letter-spacing:
.65pt'>_</span>run<span style='letter-spacing:-.9pt'>_</span>pool<span
style='letter-spacing:1.1pt'> </span>from<span style='letter-spacing:1.15pt'> </span>rq-&gt;lab6<span
style='letter-spacing:.2pt'>_</span>run<span style='letter-spacing:-.9pt'>_</span>pool</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;margin-right:0cm;
margin-bottom:0cm;margin-left:44.85pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
style='font-size:11.0pt;font-family:楷体;color:black'>rq-&gt;proc<span
style='letter-spacing:.15pt'>_</span>num<span style='letter-spacing:.9pt'> </span>--</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;text-align:left;
line-height:5.0pt;text-autospace:none'><span style='font-size:5.0pt;font-family:
楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:21.65pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:宋体;
color:black'>•</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black;letter-spacing:1.55pt'> </span><span style='font-size:11.0pt;
font-family:楷体;color:black'>pick<span style='letter-spacing:-.7pt'>_</span>next(rq)</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;text-align:left;
line-height:5.0pt;text-autospace:none'><span style='font-size:5.0pt;font-family:
楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:44.85pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
style='font-size:11.0pt;font-family:楷体;color:black'>If<span style='letter-spacing:
.65pt'> </span>rq-&gt;lab6<span style='letter-spacing:.2pt'>_</span>run<span
style='letter-spacing:-.9pt'>_</span>pool<span style='letter-spacing:1.15pt'> </span>==<span
style='letter-spacing:.7pt'> </span>NULL,<span style='letter-spacing:1.35pt'> </span>return<span
style='letter-spacing:1.55pt'> </span>NULL</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;margin-right:0cm;
margin-bottom:0cm;margin-left:44.85pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
style='font-size:11.0pt;font-family:楷体;color:black'>Find<span style='letter-spacing:
1.1pt'> </span>the<span style='letter-spacing:.9pt'> </span>proc<span
style='letter-spacing:1.15pt'> </span>corresponding<span style='letter-spacing:
3.1pt'> </span>to<span style='letter-spacing:.7pt'> </span>the<span
style='letter-spacing:.9pt'> </span>pointer<span style='letter-spacing:1.8pt'> </span>rq-&gt;lab6<span
style='letter-spacing:.2pt'>_</span>run<span style='letter-spacing:-.9pt'>_</span>pool</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;margin-right:0cm;
margin-bottom:0cm;margin-left:44.85pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
style='font-size:11.0pt;font-family:楷体;color:black'>proc-&gt;lab6<span
style='letter-spacing:.65pt'>_</span>stride<span style='letter-spacing:1.5pt'> </span>+=<span
style='letter-spacing:.7pt'> </span>BIG<span style='letter-spacing:-.9pt'>_</span>STRIDE<span
style='letter-spacing:1.5pt'> </span>/<span style='letter-spacing:.45pt'> </span>proc-&gt;lab6<span
style='letter-spacing:.65pt'>_</span>priority</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;margin-right:0cm;
margin-bottom:0cm;margin-left:44.85pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
style='font-size:11.0pt;font-family:楷体;color:black'>Return<span
style='letter-spacing:1.5pt'> </span>proc</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;text-align:left;
line-height:5.0pt;text-autospace:none'><span style='font-size:5.0pt;font-family:
楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:21.65pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:宋体;
color:black'>•</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black;letter-spacing:1.55pt'> </span><span style='font-size:11.0pt;
font-family:楷体;color:black'>proc<span style='letter-spacing:-.7pt'>_</span>tick(rq,<span
style='letter-spacing:2.0pt'> </span>proc)</span><span style='font-size:11.0pt;
font-family:楷体;color:black'>:</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;text-align:left;
line-height:5.0pt;text-autospace:none'><span style='font-size:5.0pt;font-family:
楷体;color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-left:44.85pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
style='font-size:11.0pt;font-family:楷体;color:black'>If<span style='letter-spacing:
.65pt'> </span>proc-&gt;time<span style='letter-spacing:.65pt'>_</span>slice<span
style='letter-spacing:1.3pt'> </span>&gt;<span style='letter-spacing:.45pt'> </span>0,<span
style='letter-spacing:.7pt'> </span>proc-&gt;time<span style='letter-spacing:
.65pt'>_</span>slice<span style='letter-spacing:1.3pt'> </span>--</span></p>

<p class=MsoNormal align=left style='margin-top:.35pt;margin-right:0cm;
margin-bottom:0cm;margin-left:44.85pt;margin-bottom:.0001pt;text-align:left;
text-autospace:none'><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'>–</span><span lang=ZH-CN style='font-size:11.0pt;font-family:楷体;
color:black'> <span style='letter-spacing:.7pt'> </span></span><span
style='font-size:11.0pt;font-family:楷体;color:black'>If<span style='letter-spacing:
.65pt'> </span>proc-&gt;time<span style='letter-spacing:.65pt'>_</span>slice<span
style='letter-spacing:1.3pt'> </span>==<span style='letter-spacing:.7pt'> </span>0,<span
style='letter-spacing:.7pt'> </span>set<span style='letter-spacing:.9pt'> </span>the<span
style='letter-spacing:.9pt'> </span>flag<span style='letter-spacing:1.15pt'> </span>proc-&gt;need<span
style='letter-spacing:.65pt'>_</span>resched</span></p>

<p class=MsoNormalIndent style='text-indent:25.5pt'><span style='font-family:
楷体'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;text-autospace:none'><b><span
style='font-size:14.0pt;font-family:楷体;letter-spacing:.05pt'>4 <span
lang=ZH-CN>实验报告要求</span></span></b></p>

<p class=MsoNormalIndent style='text-indent:25.5pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>从网站上下载</span><span style='font-size:
12.0pt;font-family:楷体'>lab6.zip<span lang=ZH-CN>后，解压得到本文档和代码目录</span> lab6<span
lang=ZH-CN>，完成实验中的各个练习。完成代码编写并检查无误后，在对应目录下执行</span> make handin <span
lang=ZH-CN>任务，即会自动生成</span> lab6-handin.tar.gz<span lang=ZH-CN>。最后请一定提前或按时提交到网络学堂上。</span></span></p>

<p class=MsoNormalIndent style='text-indent:25.5pt'><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>注意有“</span><span style='font-size:12.0pt;
font-family:楷体'>LAB6<span lang=ZH-CN>”的注释，主要是修改</span>default_sched_swide_c<span
lang=ZH-CN>中的内容。代码中所有需要完成的地方</span></span><span lang=ZH-CN style='font-size:
12.0pt;font-family:楷体'>（</span><span style='font-size:12.0pt'>challenge</span><span
lang=ZH-CN style='font-size:12.0pt;font-family:楷体'>除外）</span><span lang=ZH-CN
style='font-size:12.0pt;font-family:楷体'>都有“</span><span style='font-size:12.0pt;
font-family:楷体'>LAB6<span lang=ZH-CN>”和“</span>YOUR CODE<span lang=ZH-CN>”的注释，请在提交时特别注意保持注释，并将“</span>YOUR
CODE<span lang=ZH-CN>”替换为自己的学号，并且将所有标有对应注释的部分填上正确的代码。</span></span></p>

<p class=MsoNormal><span style='font-size:12.0pt;font-family:楷体'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;text-autospace:none'><b><span
lang=ZH-CN style='font-size:14.0pt;font-family:楷体;letter-spacing:.05pt'>附录：执行</span></b><b><span
style='font-size:14.0pt;font-family:楷体;letter-spacing:.05pt'>priority<span
lang=ZH-CN>大致的显示输出</span></span></b></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=462 valign=top style='width:461.8pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>$ make run-priority</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>......</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>check_swap() succeeded!</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>++ setup timer interrupts</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>kernel_execve: pid = 2, name = &quot;priority&quot;.</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>main: fork ok,now need to wait pids.</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>child pid 7, acc 2492000, time 2001</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>child pid 6, acc 1944000, time 2001</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>child pid 4, acc 960000, time 2002</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>child pid 5, acc 1488000, time 2003</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>child pid 3, acc 540000, time 2004</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>main: pid 3, acc 540000, time 2004</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>main: pid 4, acc 960000, time 2004</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>main: pid 5, acc 1488000, time 2004</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>main: pid 6, acc 1944000, time 2004</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>main: pid 7, acc 2492000, time 2004</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>main: wait pids over</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>stride sched correct result: 1 2 3 4 5</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>all user-mode processes have quit.</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>init check memory pass.</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>kernel panic at kern/process/proc.c:426:</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>    initproc exit.</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>&nbsp;</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>Welcome to the kernel debug monitor!!</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>Type 'help' for a list of commands.</span></p>
  <p class=MsoNormal align=left style='margin-right:9.35pt;text-align:left;
  line-height:80%;text-autospace:none'><span style='line-height:80%;font-family:
  楷体;color:black'>K&gt; </span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal style='margin-top:.9pt;text-autospace:none'><span
style='font-size:11.0pt;font-family:楷体;color:black'>&nbsp;</span></p>

</div>

</body>

</html>
